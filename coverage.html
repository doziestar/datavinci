
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<title>ai: Go Coverage Report</title>
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">ai/main.go (0.0%)</option>
				
				<option value="file1">auth/ent/client.go (44.6%)</option>
				
				<option value="file2">auth/ent/ent.go (17.0%)</option>
				
				<option value="file3">auth/ent/enttest/enttest.go (42.3%)</option>
				
				<option value="file4">auth/ent/hook/hook.go (0.0%)</option>
				
				<option value="file5">auth/ent/migrate/migrate.go (57.1%)</option>
				
				<option value="file6">auth/ent/migrate/schema.go (100.0%)</option>
				
				<option value="file7">auth/ent/mutation.go (22.8%)</option>
				
				<option value="file8">auth/ent/role.go (43.5%)</option>
				
				<option value="file9">auth/ent/role/role.go (7.7%)</option>
				
				<option value="file10">auth/ent/role/where.go (14.8%)</option>
				
				<option value="file11">auth/ent/role_create.go (44.8%)</option>
				
				<option value="file12">auth/ent/role_delete.go (57.7%)</option>
				
				<option value="file13">auth/ent/role_query.go (35.9%)</option>
				
				<option value="file14">auth/ent/role_update.go (25.1%)</option>
				
				<option value="file15">auth/ent/runtime/runtime.go (100.0%)</option>
				
				<option value="file16">auth/ent/schema/role.go (66.7%)</option>
				
				<option value="file17">auth/ent/schema/token.go (66.7%)</option>
				
				<option value="file18">auth/ent/schema/user.go (83.3%)</option>
				
				<option value="file19">auth/ent/token.go (41.0%)</option>
				
				<option value="file20">auth/ent/token/token.go (19.0%)</option>
				
				<option value="file21">auth/ent/token/where.go (17.1%)</option>
				
				<option value="file22">auth/ent/token_create.go (47.1%)</option>
				
				<option value="file23">auth/ent/token_delete.go (46.2%)</option>
				
				<option value="file24">auth/ent/token_query.go (18.5%)</option>
				
				<option value="file25">auth/ent/token_update.go (32.8%)</option>
				
				<option value="file26">auth/ent/tx.go (0.0%)</option>
				
				<option value="file27">auth/ent/user.go (69.0%)</option>
				
				<option value="file28">auth/ent/user/user.go (5.0%)</option>
				
				<option value="file29">auth/ent/user/where.go (12.2%)</option>
				
				<option value="file30">auth/ent/user_create.go (41.2%)</option>
				
				<option value="file31">auth/ent/user_delete.go (61.5%)</option>
				
				<option value="file32">auth/ent/user_query.go (31.7%)</option>
				
				<option value="file33">auth/ent/user_update.go (22.0%)</option>
				
				<option value="file34">auth/internal/auth/main.go (0.0%)</option>
				
				<option value="file35">auth/internal/auth/service/auth_service.go (0.0%)</option>
				
				<option value="file36">auth/internal/authz/main.go (0.0%)</option>
				
				<option value="file37">auth/internal/authz/service/authz_service.go (0.0%)</option>
				
				<option value="file38">auth/internal/db/db.go (0.0%)</option>
				
				<option value="file39">auth/internal/interceptor/interceptor.go (91.7%)</option>
				
				<option value="file40">auth/internal/interceptor/utils.go (89.0%)</option>
				
				<option value="file41">auth/internal/repository/role.go (78.8%)</option>
				
				<option value="file42">auth/internal/repository/token.go (92.9%)</option>
				
				<option value="file43">auth/internal/repository/user.go (87.5%)</option>
				
				<option value="file44">auth/pb/auth.pb.go (0.0%)</option>
				
				<option value="file45">auth/pb/auth_grpc.pb.go (0.0%)</option>
				
				<option value="file46">auth/pb/authorization.pb.go (0.0%)</option>
				
				<option value="file47">auth/pb/authorization_grpc.pb.go (0.0%)</option>
				
				<option value="file48">auth/pb/common.pb.go (0.0%)</option>
				
				<option value="file49">auth/pkg/limiter.go (100.0%)</option>
				
				<option value="file50">auth/pkg/password_hash.go (89.5%)</option>
				
				<option value="file51">auth/pkg/token_generator.go (100.0%)</option>
				
				<option value="file52">datasource/cmd/main.go (0.0%)</option>
				
				<option value="file53">datasource/connectors/api.go (0.0%)</option>
				
				<option value="file54">datasource/connectors/factory.go (0.0%)</option>
				
				<option value="file55">datasource/connectors/file.go (0.0%)</option>
				
				<option value="file56">datasource/connectors/mongo.go (0.0%)</option>
				
				<option value="file57">datasource/connectors/redis.go (0.0%)</option>
				
				<option value="file58">datasource/connectors/sql.go (0.0%)</option>
				
				<option value="file59">datasource/grpc/connector.pb.go (0.0%)</option>
				
				<option value="file60">datasource/grpc/connector_grpc.pb.go (0.0%)</option>
				
				<option value="file61">datasource/grpc/server/datasource.go (0.0%)</option>
				
				<option value="file62">datasource/managers/manager.go (0.0%)</option>
				
				<option value="file63">datasource/managers/query/query.go (0.0%)</option>
				
				<option value="file64">datasource/managers/transform/transform.go (0.0%)</option>
				
				<option value="file65">datasource/managers/transform/utils.go (0.0%)</option>
				
				<option value="file66">pkg/common/encoder/base64.go (100.0%)</option>
				
				<option value="file67">pkg/common/errors/error.go (91.0%)</option>
				
				<option value="file68">pkg/common/retry/retry.go (86.2%)</option>
				
				<option value="file69">pkg/config/config.go (0.0%)</option>
				
				<option value="file70">realtime/main.go (0.0%)</option>
				
				<option value="file71">report/main.go (0.0%)</option>
				
				<option value="file72">visualization/api/proto/visualization.pb.go (0.0%)</option>
				
				<option value="file73">visualization/api/proto/visualization_grpc.pb.go (0.0%)</option>
				
				<option value="file74">visualization/cmd/server/main.go (0.0%)</option>
				
				<option value="file75">visualization/data/client.go (0.0%)</option>
				
				<option value="file76">visualization/data/client/connector.pb.go (0.0%)</option>
				
				<option value="file77">visualization/data/client/connector_grpc.pb.go (0.0%)</option>
				
				<option value="file78">visualization/internal/processor/aggregator.go (0.0%)</option>
				
				<option value="file79">visualization/internal/processor/data_processor.go (0.0%)</option>
				
				<option value="file80">visualization/internal/service/visualization_service.go (0.0%)</option>
				
				<option value="file81">visualization/renderers/renderers.go (0.0%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">no coverage</span>
				<span class="cov1">low coverage</span>
				<span class="cov2">*</span>
				<span class="cov3">*</span>
				<span class="cov4">*</span>
				<span class="cov5">*</span>
				<span class="cov6">*</span>
				<span class="cov7">*</span>
				<span class="cov8">*</span>
				<span class="cov9">*</span>
				<span class="cov10">high coverage</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">package main

func main() <span class="cov0" title="0">{
        println("Hello, world!")
}</span>
</pre>
		
		<pre class="file" id="file1" style="display: none">// Code generated by ent, DO NOT EDIT.

package ent

import (
        "context"
        "errors"
        "fmt"
        "log"
        "reflect"

        "auth/ent/migrate"

        "auth/ent/role"
        "auth/ent/token"
        "auth/ent/user"

        "entgo.io/ent"
        "entgo.io/ent/dialect"
        "entgo.io/ent/dialect/sql"
        "entgo.io/ent/dialect/sql/sqlgraph"
)

// Client is the client that holds all ent builders.
type Client struct {
        config
        // Schema is the client for creating, migrating and dropping schema.
        Schema *migrate.Schema
        // Role is the client for interacting with the Role builders.
        Role *RoleClient
        // Token is the client for interacting with the Token builders.
        Token *TokenClient
        // User is the client for interacting with the User builders.
        User *UserClient
}

// NewClient creates a new client configured with the given options.
func NewClient(opts ...Option) *Client <span class="cov4" title="6">{
        client := &amp;Client{config: newConfig(opts...)}
        client.init()
        return client
}</span>

func (c *Client) init() <span class="cov4" title="6">{
        c.Schema = migrate.NewSchema(c.driver)
        c.Role = NewRoleClient(c.config)
        c.Token = NewTokenClient(c.config)
        c.User = NewUserClient(c.config)
}</span>

type (
        // config is the configuration for the client and its builder.
        config struct {
                // driver used for executing database requests.
                driver dialect.Driver
                // debug enable a debug logging.
                debug bool
                // log used for logging on debug mode.
                log func(...any)
                // hooks to execute on mutations.
                hooks *hooks
                // interceptors to execute on queries.
                inters *inters
        }
        // Option function to configure the client.
        Option func(*config)
)

// newConfig creates a new config for the client.
func newConfig(opts ...Option) config <span class="cov4" title="6">{
        cfg := config{log: log.Println, hooks: &amp;hooks{}, inters: &amp;inters{}}
        cfg.options(opts...)
        return cfg
}</span>

// options applies the options on the config object.
func (c *config) options(opts ...Option) <span class="cov4" title="6">{
        for _, opt := range opts </span><span class="cov4" title="6">{
                opt(c)
        }</span>
        <span class="cov4" title="6">if c.debug </span><span class="cov0" title="0">{
                c.driver = dialect.Debug(c.driver, c.log)
        }</span>
}

// Debug enables debug logging on the ent.Driver.
func Debug() Option <span class="cov0" title="0">{
        return func(c *config) </span><span class="cov0" title="0">{
                c.debug = true
        }</span>
}

// Log sets the logging function for debug mode.
func Log(fn func(...any)) Option <span class="cov0" title="0">{
        return func(c *config) </span><span class="cov0" title="0">{
                c.log = fn
        }</span>
}

// Driver configures the client driver.
func Driver(driver dialect.Driver) Option <span class="cov4" title="6">{
        return func(c *config) </span><span class="cov4" title="6">{
                c.driver = driver
        }</span>
}

// Open opens a database/sql.DB specified by the driver name and
// the data source name, and returns a new client attached to it.
// Optional parameters can be added for configuring the client.
func Open(driverName, dataSourceName string, options ...Option) (*Client, error) <span class="cov4" title="6">{
        switch driverName </span>{
        case dialect.MySQL, dialect.Postgres, dialect.SQLite:<span class="cov4" title="6">
                drv, err := sql.Open(driverName, dataSourceName)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov4" title="6">return NewClient(append(options, Driver(drv))...), nil</span>
        default:<span class="cov0" title="0">
                return nil, fmt.Errorf("unsupported driver: %q", driverName)</span>
        }
}

// ErrTxStarted is returned when trying to start a new transaction from a transactional client.
var ErrTxStarted = errors.New("ent: cannot start a transaction within a transaction")

// Tx returns a new transactional client. The provided context
// is used until the transaction is committed or rolled back.
func (c *Client) Tx(ctx context.Context) (*Tx, error) <span class="cov0" title="0">{
        if _, ok := c.driver.(*txDriver); ok </span><span class="cov0" title="0">{
                return nil, ErrTxStarted
        }</span>
        <span class="cov0" title="0">tx, err := newTx(ctx, c.driver)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("ent: starting a transaction: %w", err)
        }</span>
        <span class="cov0" title="0">cfg := c.config
        cfg.driver = tx
        return &amp;Tx{
                ctx:    ctx,
                config: cfg,
                Role:   NewRoleClient(cfg),
                Token:  NewTokenClient(cfg),
                User:   NewUserClient(cfg),
        }, nil</span>
}

// BeginTx returns a transactional client with specified options.
func (c *Client) BeginTx(ctx context.Context, opts *sql.TxOptions) (*Tx, error) <span class="cov0" title="0">{
        if _, ok := c.driver.(*txDriver); ok </span><span class="cov0" title="0">{
                return nil, errors.New("ent: cannot start a transaction within a transaction")
        }</span>
        <span class="cov0" title="0">tx, err := c.driver.(interface {
                BeginTx(context.Context, *sql.TxOptions) (dialect.Tx, error)
        }).BeginTx(ctx, opts)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("ent: starting a transaction: %w", err)
        }</span>
        <span class="cov0" title="0">cfg := c.config
        cfg.driver = &amp;txDriver{tx: tx, drv: c.driver}
        return &amp;Tx{
                ctx:    ctx,
                config: cfg,
                Role:   NewRoleClient(cfg),
                Token:  NewTokenClient(cfg),
                User:   NewUserClient(cfg),
        }, nil</span>
}

// Debug returns a new debug-client. It's used to get verbose logging on specific operations.
//
//        client.Debug().
//                Role.
//                Query().
//                Count(ctx)
func (c *Client) Debug() *Client <span class="cov0" title="0">{
        if c.debug </span><span class="cov0" title="0">{
                return c
        }</span>
        <span class="cov0" title="0">cfg := c.config
        cfg.driver = dialect.Debug(c.driver, c.log)
        client := &amp;Client{config: cfg}
        client.init()
        return client</span>
}

// Close closes the database connection and prevents new queries from starting.
func (c *Client) Close() error <span class="cov4" title="6">{
        return c.driver.Close()
}</span>

// Use adds the mutation hooks to all the entity clients.
// In order to add hooks to a specific client, call: `client.Node.Use(...)`.
func (c *Client) Use(hooks ...Hook) <span class="cov0" title="0">{
        c.Role.Use(hooks...)
        c.Token.Use(hooks...)
        c.User.Use(hooks...)
}</span>

// Intercept adds the query interceptors to all the entity clients.
// In order to add interceptors to a specific client, call: `client.Node.Intercept(...)`.
func (c *Client) Intercept(interceptors ...Interceptor) <span class="cov0" title="0">{
        c.Role.Intercept(interceptors...)
        c.Token.Intercept(interceptors...)
        c.User.Intercept(interceptors...)
}</span>

// Mutate implements the ent.Mutator interface.
func (c *Client) Mutate(ctx context.Context, m Mutation) (Value, error) <span class="cov0" title="0">{
        switch m := m.(type) </span>{
        case *RoleMutation:<span class="cov0" title="0">
                return c.Role.mutate(ctx, m)</span>
        case *TokenMutation:<span class="cov0" title="0">
                return c.Token.mutate(ctx, m)</span>
        case *UserMutation:<span class="cov0" title="0">
                return c.User.mutate(ctx, m)</span>
        default:<span class="cov0" title="0">
                return nil, fmt.Errorf("ent: unknown mutation type %T", m)</span>
        }
}

// RoleClient is a client for the Role schema.
type RoleClient struct {
        config
}

// NewRoleClient returns a client for the Role from the given config.
func NewRoleClient(c config) *RoleClient <span class="cov5" title="7">{
        return &amp;RoleClient{config: c}
}</span>

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `role.Hooks(f(g(h())))`.
func (c *RoleClient) Use(hooks ...Hook) <span class="cov0" title="0">{
        c.hooks.Role = append(c.hooks.Role, hooks...)
}</span>

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `role.Intercept(f(g(h())))`.
func (c *RoleClient) Intercept(interceptors ...Interceptor) <span class="cov0" title="0">{
        c.inters.Role = append(c.inters.Role, interceptors...)
}</span>

// Create returns a builder for creating a Role entity.
func (c *RoleClient) Create() *RoleCreate <span class="cov8" title="34">{
        mutation := newRoleMutation(c.config, OpCreate)
        return &amp;RoleCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}</span>

// CreateBulk returns a builder for creating a bulk of Role entities.
func (c *RoleClient) CreateBulk(builders ...*RoleCreate) *RoleCreateBulk <span class="cov0" title="0">{
        return &amp;RoleCreateBulk{config: c.config, builders: builders}
}</span>

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *RoleClient) MapCreateBulk(slice any, setFunc func(*RoleCreate, int)) *RoleCreateBulk <span class="cov0" title="0">{
        rv := reflect.ValueOf(slice)
        if rv.Kind() != reflect.Slice </span><span class="cov0" title="0">{
                return &amp;RoleCreateBulk{err: fmt.Errorf("calling to RoleClient.MapCreateBulk with wrong type %T, need slice", slice)}
        }</span>
        <span class="cov0" title="0">builders := make([]*RoleCreate, rv.Len())
        for i := 0; i &lt; rv.Len(); i++ </span><span class="cov0" title="0">{
                builders[i] = c.Create()
                setFunc(builders[i], i)
        }</span>
        <span class="cov0" title="0">return &amp;RoleCreateBulk{config: c.config, builders: builders}</span>
}

// Update returns an update builder for Role.
func (c *RoleClient) Update() *RoleUpdate <span class="cov0" title="0">{
        mutation := newRoleMutation(c.config, OpUpdate)
        return &amp;RoleUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}</span>

// UpdateOne returns an update builder for the given entity.
func (c *RoleClient) UpdateOne(r *Role) *RoleUpdateOne <span class="cov1" title="1">{
        mutation := newRoleMutation(c.config, OpUpdateOne, withRole(r))
        return &amp;RoleUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}</span>

// UpdateOneID returns an update builder for the given id.
func (c *RoleClient) UpdateOneID(id string) *RoleUpdateOne <span class="cov3" title="3">{
        mutation := newRoleMutation(c.config, OpUpdateOne, withRoleID(id))
        return &amp;RoleUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}</span>

// Delete returns a delete builder for Role.
func (c *RoleClient) Delete() *RoleDelete <span class="cov3" title="3">{
        mutation := newRoleMutation(c.config, OpDelete)
        return &amp;RoleDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}</span>

// DeleteOne returns a builder for deleting the given entity.
func (c *RoleClient) DeleteOne(r *Role) *RoleDeleteOne <span class="cov0" title="0">{
        return c.DeleteOneID(r.ID)
}</span>

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *RoleClient) DeleteOneID(id string) *RoleDeleteOne <span class="cov1" title="1">{
        builder := c.Delete().Where(role.ID(id))
        builder.mutation.id = &amp;id
        builder.mutation.op = OpDeleteOne
        return &amp;RoleDeleteOne{builder}
}</span>

// Query returns a query builder for Role.
func (c *RoleClient) Query() *RoleQuery <span class="cov7" title="18">{
        return &amp;RoleQuery{
                config: c.config,
                ctx:    &amp;QueryContext{Type: TypeRole},
                inters: c.Interceptors(),
        }
}</span>

// Get returns a Role entity by its id.
func (c *RoleClient) Get(ctx context.Context, id string) (*Role, error) <span class="cov0" title="0">{
        return c.Query().Where(role.ID(id)).Only(ctx)
}</span>

// GetX is like Get, but panics if an error occurs.
func (c *RoleClient) GetX(ctx context.Context, id string) *Role <span class="cov0" title="0">{
        obj, err := c.Get(ctx, id)
        if err != nil </span><span class="cov0" title="0">{
                panic(err)</span>
        }
        <span class="cov0" title="0">return obj</span>
}

// QueryUsers queries the users edge of a Role.
func (c *RoleClient) QueryUsers(r *Role) *UserQuery <span class="cov1" title="1">{
        query := (&amp;UserClient{config: c.config}).Query()
        query.path = func(context.Context) (fromV *sql.Selector, _ error) </span><span class="cov1" title="1">{
                id := r.ID
                step := sqlgraph.NewStep(
                        sqlgraph.From(role.Table, role.FieldID, id),
                        sqlgraph.To(user.Table, user.FieldID),
                        sqlgraph.Edge(sqlgraph.M2M, true, role.UsersTable, role.UsersPrimaryKey...),
                )
                fromV = sqlgraph.Neighbors(r.driver.Dialect(), step)
                return fromV, nil
        }</span>
        <span class="cov1" title="1">return query</span>
}

// Hooks returns the client hooks.
func (c *RoleClient) Hooks() []Hook <span class="cov9" title="41">{
        return c.hooks.Role
}</span>

// Interceptors returns the client interceptors.
func (c *RoleClient) Interceptors() []Interceptor <span class="cov7" title="18">{
        return c.inters.Role
}</span>

func (c *RoleClient) mutate(ctx context.Context, m *RoleMutation) (Value, error) <span class="cov0" title="0">{
        switch m.Op() </span>{
        case OpCreate:<span class="cov0" title="0">
                return (&amp;RoleCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)</span>
        case OpUpdate:<span class="cov0" title="0">
                return (&amp;RoleUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)</span>
        case OpUpdateOne:<span class="cov0" title="0">
                return (&amp;RoleUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)</span>
        case OpDelete, OpDeleteOne:<span class="cov0" title="0">
                return (&amp;RoleDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)</span>
        default:<span class="cov0" title="0">
                return nil, fmt.Errorf("ent: unknown Role mutation op: %q", m.Op())</span>
        }
}

// TokenClient is a client for the Token schema.
type TokenClient struct {
        config
}

// NewTokenClient returns a client for the Token from the given config.
func NewTokenClient(c config) *TokenClient <span class="cov5" title="8">{
        return &amp;TokenClient{config: c}
}</span>

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `token.Hooks(f(g(h())))`.
func (c *TokenClient) Use(hooks ...Hook) <span class="cov0" title="0">{
        c.hooks.Token = append(c.hooks.Token, hooks...)
}</span>

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `token.Intercept(f(g(h())))`.
func (c *TokenClient) Intercept(interceptors ...Interceptor) <span class="cov0" title="0">{
        c.inters.Token = append(c.inters.Token, interceptors...)
}</span>

// Create returns a builder for creating a Token entity.
func (c *TokenClient) Create() *TokenCreate <span class="cov6" title="13">{
        mutation := newTokenMutation(c.config, OpCreate)
        return &amp;TokenCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}</span>

// CreateBulk returns a builder for creating a bulk of Token entities.
func (c *TokenClient) CreateBulk(builders ...*TokenCreate) *TokenCreateBulk <span class="cov0" title="0">{
        return &amp;TokenCreateBulk{config: c.config, builders: builders}
}</span>

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *TokenClient) MapCreateBulk(slice any, setFunc func(*TokenCreate, int)) *TokenCreateBulk <span class="cov0" title="0">{
        rv := reflect.ValueOf(slice)
        if rv.Kind() != reflect.Slice </span><span class="cov0" title="0">{
                return &amp;TokenCreateBulk{err: fmt.Errorf("calling to TokenClient.MapCreateBulk with wrong type %T, need slice", slice)}
        }</span>
        <span class="cov0" title="0">builders := make([]*TokenCreate, rv.Len())
        for i := 0; i &lt; rv.Len(); i++ </span><span class="cov0" title="0">{
                builders[i] = c.Create()
                setFunc(builders[i], i)
        }</span>
        <span class="cov0" title="0">return &amp;TokenCreateBulk{config: c.config, builders: builders}</span>
}

// Update returns an update builder for Token.
func (c *TokenClient) Update() *TokenUpdate <span class="cov4" title="4">{
        mutation := newTokenMutation(c.config, OpUpdate)
        return &amp;TokenUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}</span>

// UpdateOne returns an update builder for the given entity.
func (c *TokenClient) UpdateOne(t *Token) *TokenUpdateOne <span class="cov1" title="1">{
        mutation := newTokenMutation(c.config, OpUpdateOne, withToken(t))
        return &amp;TokenUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}</span>

// UpdateOneID returns an update builder for the given id.
func (c *TokenClient) UpdateOneID(id string) *TokenUpdateOne <span class="cov0" title="0">{
        mutation := newTokenMutation(c.config, OpUpdateOne, withTokenID(id))
        return &amp;TokenUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}</span>

// Delete returns a delete builder for Token.
func (c *TokenClient) Delete() *TokenDelete <span class="cov1" title="1">{
        mutation := newTokenMutation(c.config, OpDelete)
        return &amp;TokenDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}</span>

// DeleteOne returns a builder for deleting the given entity.
func (c *TokenClient) DeleteOne(t *Token) *TokenDeleteOne <span class="cov0" title="0">{
        return c.DeleteOneID(t.ID)
}</span>

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *TokenClient) DeleteOneID(id string) *TokenDeleteOne <span class="cov0" title="0">{
        builder := c.Delete().Where(token.ID(id))
        builder.mutation.id = &amp;id
        builder.mutation.op = OpDeleteOne
        return &amp;TokenDeleteOne{builder}
}</span>

// Query returns a query builder for Token.
func (c *TokenClient) Query() *TokenQuery <span class="cov6" title="10">{
        return &amp;TokenQuery{
                config: c.config,
                ctx:    &amp;QueryContext{Type: TypeToken},
                inters: c.Interceptors(),
        }
}</span>

// Get returns a Token entity by its id.
func (c *TokenClient) Get(ctx context.Context, id string) (*Token, error) <span class="cov4" title="4">{
        return c.Query().Where(token.ID(id)).Only(ctx)
}</span>

// GetX is like Get, but panics if an error occurs.
func (c *TokenClient) GetX(ctx context.Context, id string) *Token <span class="cov0" title="0">{
        obj, err := c.Get(ctx, id)
        if err != nil </span><span class="cov0" title="0">{
                panic(err)</span>
        }
        <span class="cov0" title="0">return obj</span>
}

// QueryUser queries the user edge of a Token.
func (c *TokenClient) QueryUser(t *Token) *UserQuery <span class="cov1" title="1">{
        query := (&amp;UserClient{config: c.config}).Query()
        query.path = func(context.Context) (fromV *sql.Selector, _ error) </span><span class="cov1" title="1">{
                id := t.ID
                step := sqlgraph.NewStep(
                        sqlgraph.From(token.Table, token.FieldID, id),
                        sqlgraph.To(user.Table, user.FieldID),
                        sqlgraph.Edge(sqlgraph.M2O, true, token.UserTable, token.UserColumn),
                )
                fromV = sqlgraph.Neighbors(t.driver.Dialect(), step)
                return fromV, nil
        }</span>
        <span class="cov1" title="1">return query</span>
}

// Hooks returns the client hooks.
func (c *TokenClient) Hooks() []Hook <span class="cov7" title="19">{
        return c.hooks.Token
}</span>

// Interceptors returns the client interceptors.
func (c *TokenClient) Interceptors() []Interceptor <span class="cov6" title="10">{
        return c.inters.Token
}</span>

func (c *TokenClient) mutate(ctx context.Context, m *TokenMutation) (Value, error) <span class="cov0" title="0">{
        switch m.Op() </span>{
        case OpCreate:<span class="cov0" title="0">
                return (&amp;TokenCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)</span>
        case OpUpdate:<span class="cov0" title="0">
                return (&amp;TokenUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)</span>
        case OpUpdateOne:<span class="cov0" title="0">
                return (&amp;TokenUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)</span>
        case OpDelete, OpDeleteOne:<span class="cov0" title="0">
                return (&amp;TokenDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)</span>
        default:<span class="cov0" title="0">
                return nil, fmt.Errorf("ent: unknown Token mutation op: %q", m.Op())</span>
        }
}

// UserClient is a client for the User schema.
type UserClient struct {
        config
}

// NewUserClient returns a client for the User from the given config.
func NewUserClient(c config) *UserClient <span class="cov5" title="8">{
        return &amp;UserClient{config: c}
}</span>

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `user.Hooks(f(g(h())))`.
func (c *UserClient) Use(hooks ...Hook) <span class="cov0" title="0">{
        c.hooks.User = append(c.hooks.User, hooks...)
}</span>

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `user.Intercept(f(g(h())))`.
func (c *UserClient) Intercept(interceptors ...Interceptor) <span class="cov0" title="0">{
        c.inters.User = append(c.inters.User, interceptors...)
}</span>

// Create returns a builder for creating a User entity.
func (c *UserClient) Create() *UserCreate <span class="cov9" title="44">{
        mutation := newUserMutation(c.config, OpCreate)
        return &amp;UserCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}</span>

// CreateBulk returns a builder for creating a bulk of User entities.
func (c *UserClient) CreateBulk(builders ...*UserCreate) *UserCreateBulk <span class="cov0" title="0">{
        return &amp;UserCreateBulk{config: c.config, builders: builders}
}</span>

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *UserClient) MapCreateBulk(slice any, setFunc func(*UserCreate, int)) *UserCreateBulk <span class="cov0" title="0">{
        rv := reflect.ValueOf(slice)
        if rv.Kind() != reflect.Slice </span><span class="cov0" title="0">{
                return &amp;UserCreateBulk{err: fmt.Errorf("calling to UserClient.MapCreateBulk with wrong type %T, need slice", slice)}
        }</span>
        <span class="cov0" title="0">builders := make([]*UserCreate, rv.Len())
        for i := 0; i &lt; rv.Len(); i++ </span><span class="cov0" title="0">{
                builders[i] = c.Create()
                setFunc(builders[i], i)
        }</span>
        <span class="cov0" title="0">return &amp;UserCreateBulk{config: c.config, builders: builders}</span>
}

// Update returns an update builder for User.
func (c *UserClient) Update() *UserUpdate <span class="cov0" title="0">{
        mutation := newUserMutation(c.config, OpUpdate)
        return &amp;UserUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}</span>

// UpdateOne returns an update builder for the given entity.
func (c *UserClient) UpdateOne(u *User) *UserUpdateOne <span class="cov3" title="3">{
        mutation := newUserMutation(c.config, OpUpdateOne, withUser(u))
        return &amp;UserUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}</span>

// UpdateOneID returns an update builder for the given id.
func (c *UserClient) UpdateOneID(id string) *UserUpdateOne <span class="cov6" title="10">{
        mutation := newUserMutation(c.config, OpUpdateOne, withUserID(id))
        return &amp;UserUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}</span>

// Delete returns a delete builder for User.
func (c *UserClient) Delete() *UserDelete <span class="cov3" title="3">{
        mutation := newUserMutation(c.config, OpDelete)
        return &amp;UserDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}</span>

// DeleteOne returns a builder for deleting the given entity.
func (c *UserClient) DeleteOne(u *User) *UserDeleteOne <span class="cov0" title="0">{
        return c.DeleteOneID(u.ID)
}</span>

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *UserClient) DeleteOneID(id string) *UserDeleteOne <span class="cov2" title="2">{
        builder := c.Delete().Where(user.ID(id))
        builder.mutation.id = &amp;id
        builder.mutation.op = OpDeleteOne
        return &amp;UserDeleteOne{builder}
}</span>

// Query returns a query builder for User.
func (c *UserClient) Query() *UserQuery <span class="cov8" title="30">{
        return &amp;UserQuery{
                config: c.config,
                ctx:    &amp;QueryContext{Type: TypeUser},
                inters: c.Interceptors(),
        }
}</span>

// Get returns a User entity by its id.
func (c *UserClient) Get(ctx context.Context, id string) (*User, error) <span class="cov1" title="1">{
        return c.Query().Where(user.ID(id)).Only(ctx)
}</span>

// GetX is like Get, but panics if an error occurs.
func (c *UserClient) GetX(ctx context.Context, id string) *User <span class="cov0" title="0">{
        obj, err := c.Get(ctx, id)
        if err != nil </span><span class="cov0" title="0">{
                panic(err)</span>
        }
        <span class="cov0" title="0">return obj</span>
}

// QueryRoles queries the roles edge of a User.
func (c *UserClient) QueryRoles(u *User) *RoleQuery <span class="cov1" title="1">{
        query := (&amp;RoleClient{config: c.config}).Query()
        query.path = func(context.Context) (fromV *sql.Selector, _ error) </span><span class="cov1" title="1">{
                id := u.ID
                step := sqlgraph.NewStep(
                        sqlgraph.From(user.Table, user.FieldID, id),
                        sqlgraph.To(role.Table, role.FieldID),
                        sqlgraph.Edge(sqlgraph.M2M, false, user.RolesTable, user.RolesPrimaryKey...),
                )
                fromV = sqlgraph.Neighbors(u.driver.Dialect(), step)
                return fromV, nil
        }</span>
        <span class="cov1" title="1">return query</span>
}

// QueryTokens queries the tokens edge of a User.
func (c *UserClient) QueryTokens(u *User) *TokenQuery <span class="cov1" title="1">{
        query := (&amp;TokenClient{config: c.config}).Query()
        query.path = func(context.Context) (fromV *sql.Selector, _ error) </span><span class="cov1" title="1">{
                id := u.ID
                step := sqlgraph.NewStep(
                        sqlgraph.From(user.Table, user.FieldID, id),
                        sqlgraph.To(token.Table, token.FieldID),
                        sqlgraph.Edge(sqlgraph.O2M, false, user.TokensTable, user.TokensColumn),
                )
                fromV = sqlgraph.Neighbors(u.driver.Dialect(), step)
                return fromV, nil
        }</span>
        <span class="cov1" title="1">return query</span>
}

// Hooks returns the client hooks.
func (c *UserClient) Hooks() []Hook <span class="cov10" title="60">{
        hooks := c.hooks.User
        return append(hooks[:len(hooks):len(hooks)], user.Hooks[:]...)
}</span>

// Interceptors returns the client interceptors.
func (c *UserClient) Interceptors() []Interceptor <span class="cov8" title="30">{
        return c.inters.User
}</span>

func (c *UserClient) mutate(ctx context.Context, m *UserMutation) (Value, error) <span class="cov0" title="0">{
        switch m.Op() </span>{
        case OpCreate:<span class="cov0" title="0">
                return (&amp;UserCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)</span>
        case OpUpdate:<span class="cov0" title="0">
                return (&amp;UserUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)</span>
        case OpUpdateOne:<span class="cov0" title="0">
                return (&amp;UserUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)</span>
        case OpDelete, OpDeleteOne:<span class="cov0" title="0">
                return (&amp;UserDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)</span>
        default:<span class="cov0" title="0">
                return nil, fmt.Errorf("ent: unknown User mutation op: %q", m.Op())</span>
        }
}

// hooks and interceptors per client, for fast access.
type (
        hooks struct {
                Role, Token, User []ent.Hook
        }
        inters struct {
                Role, Token, User []ent.Interceptor
        }
)
</pre>
		
		<pre class="file" id="file2" style="display: none">// Code generated by ent, DO NOT EDIT.

package ent

import (
        "auth/ent/role"
        "auth/ent/token"
        "auth/ent/user"
        "context"
        "errors"
        "fmt"
        "reflect"
        "sync"

        "entgo.io/ent"
        "entgo.io/ent/dialect/sql"
        "entgo.io/ent/dialect/sql/sqlgraph"
)

// ent aliases to avoid import conflicts in user's code.
type (
        Op            = ent.Op
        Hook          = ent.Hook
        Value         = ent.Value
        Query         = ent.Query
        QueryContext  = ent.QueryContext
        Querier       = ent.Querier
        QuerierFunc   = ent.QuerierFunc
        Interceptor   = ent.Interceptor
        InterceptFunc = ent.InterceptFunc
        Traverser     = ent.Traverser
        TraverseFunc  = ent.TraverseFunc
        Policy        = ent.Policy
        Mutator       = ent.Mutator
        Mutation      = ent.Mutation
        MutateFunc    = ent.MutateFunc
)

type clientCtxKey struct{}

// FromContext returns a Client stored inside a context, or nil if there isn't one.
func FromContext(ctx context.Context) *Client <span class="cov0" title="0">{
        c, _ := ctx.Value(clientCtxKey{}).(*Client)
        return c
}</span>

// NewContext returns a new context with the given Client attached.
func NewContext(parent context.Context, c *Client) context.Context <span class="cov0" title="0">{
        return context.WithValue(parent, clientCtxKey{}, c)
}</span>

type txCtxKey struct{}

// TxFromContext returns a Tx stored inside a context, or nil if there isn't one.
func TxFromContext(ctx context.Context) *Tx <span class="cov0" title="0">{
        tx, _ := ctx.Value(txCtxKey{}).(*Tx)
        return tx
}</span>

// NewTxContext returns a new context with the given Tx attached.
func NewTxContext(parent context.Context, tx *Tx) context.Context <span class="cov0" title="0">{
        return context.WithValue(parent, txCtxKey{}, tx)
}</span>

// OrderFunc applies an ordering on the sql selector.
// Deprecated: Use Asc/Desc functions or the package builders instead.
type OrderFunc func(*sql.Selector)

var (
        initCheck   sync.Once
        columnCheck sql.ColumnCheck
)

// columnChecker checks if the column exists in the given table.
func checkColumn(table, column string) error <span class="cov0" title="0">{
        initCheck.Do(func() </span><span class="cov0" title="0">{
                columnCheck = sql.NewColumnCheck(map[string]func(string) bool{
                        role.Table:  role.ValidColumn,
                        token.Table: token.ValidColumn,
                        user.Table:  user.ValidColumn,
                })
        }</span>)
        <span class="cov0" title="0">return columnCheck(table, column)</span>
}

// Asc applies the given fields in ASC order.
func Asc(fields ...string) func(*sql.Selector) <span class="cov0" title="0">{
        return func(s *sql.Selector) </span><span class="cov0" title="0">{
                for _, f := range fields </span><span class="cov0" title="0">{
                        if err := checkColumn(s.TableName(), f); err != nil </span><span class="cov0" title="0">{
                                s.AddError(&amp;ValidationError{Name: f, err: fmt.Errorf("ent: %w", err)})
                        }</span>
                        <span class="cov0" title="0">s.OrderBy(sql.Asc(s.C(f)))</span>
                }
        }
}

// Desc applies the given fields in DESC order.
func Desc(fields ...string) func(*sql.Selector) <span class="cov0" title="0">{
        return func(s *sql.Selector) </span><span class="cov0" title="0">{
                for _, f := range fields </span><span class="cov0" title="0">{
                        if err := checkColumn(s.TableName(), f); err != nil </span><span class="cov0" title="0">{
                                s.AddError(&amp;ValidationError{Name: f, err: fmt.Errorf("ent: %w", err)})
                        }</span>
                        <span class="cov0" title="0">s.OrderBy(sql.Desc(s.C(f)))</span>
                }
        }
}

// AggregateFunc applies an aggregation step on the group-by traversal/selector.
type AggregateFunc func(*sql.Selector) string

// As is a pseudo aggregation function for renaming another other functions with custom names. For example:
//
//        GroupBy(field1, field2).
//        Aggregate(ent.As(ent.Sum(field1), "sum_field1"), (ent.As(ent.Sum(field2), "sum_field2")).
//        Scan(ctx, &amp;v)
func As(fn AggregateFunc, end string) AggregateFunc <span class="cov0" title="0">{
        return func(s *sql.Selector) string </span><span class="cov0" title="0">{
                return sql.As(fn(s), end)
        }</span>
}

// Count applies the "count" aggregation function on each group.
func Count() AggregateFunc <span class="cov0" title="0">{
        return func(s *sql.Selector) string </span><span class="cov0" title="0">{
                return sql.Count("*")
        }</span>
}

// Max applies the "max" aggregation function on the given field of each group.
func Max(field string) AggregateFunc <span class="cov0" title="0">{
        return func(s *sql.Selector) string </span><span class="cov0" title="0">{
                if err := checkColumn(s.TableName(), field); err != nil </span><span class="cov0" title="0">{
                        s.AddError(&amp;ValidationError{Name: field, err: fmt.Errorf("ent: %w", err)})
                        return ""
                }</span>
                <span class="cov0" title="0">return sql.Max(s.C(field))</span>
        }
}

// Mean applies the "mean" aggregation function on the given field of each group.
func Mean(field string) AggregateFunc <span class="cov0" title="0">{
        return func(s *sql.Selector) string </span><span class="cov0" title="0">{
                if err := checkColumn(s.TableName(), field); err != nil </span><span class="cov0" title="0">{
                        s.AddError(&amp;ValidationError{Name: field, err: fmt.Errorf("ent: %w", err)})
                        return ""
                }</span>
                <span class="cov0" title="0">return sql.Avg(s.C(field))</span>
        }
}

// Min applies the "min" aggregation function on the given field of each group.
func Min(field string) AggregateFunc <span class="cov0" title="0">{
        return func(s *sql.Selector) string </span><span class="cov0" title="0">{
                if err := checkColumn(s.TableName(), field); err != nil </span><span class="cov0" title="0">{
                        s.AddError(&amp;ValidationError{Name: field, err: fmt.Errorf("ent: %w", err)})
                        return ""
                }</span>
                <span class="cov0" title="0">return sql.Min(s.C(field))</span>
        }
}

// Sum applies the "sum" aggregation function on the given field of each group.
func Sum(field string) AggregateFunc <span class="cov0" title="0">{
        return func(s *sql.Selector) string </span><span class="cov0" title="0">{
                if err := checkColumn(s.TableName(), field); err != nil </span><span class="cov0" title="0">{
                        s.AddError(&amp;ValidationError{Name: field, err: fmt.Errorf("ent: %w", err)})
                        return ""
                }</span>
                <span class="cov0" title="0">return sql.Sum(s.C(field))</span>
        }
}

// ValidationError returns when validating a field or edge fails.
type ValidationError struct {
        Name string // Field or edge name.
        err  error
}

// Error implements the error interface.
func (e *ValidationError) Error() string <span class="cov0" title="0">{
        return e.err.Error()
}</span>

// Unwrap implements the errors.Wrapper interface.
func (e *ValidationError) Unwrap() error <span class="cov0" title="0">{
        return e.err
}</span>

// IsValidationError returns a boolean indicating whether the error is a validation error.
func IsValidationError(err error) bool <span class="cov0" title="0">{
        if err == nil </span><span class="cov0" title="0">{
                return false
        }</span>
        <span class="cov0" title="0">var e *ValidationError
        return errors.As(err, &amp;e)</span>
}

// NotFoundError returns when trying to fetch a specific entity and it was not found in the database.
type NotFoundError struct {
        label string
}

// Error implements the error interface.
func (e *NotFoundError) Error() string <span class="cov0" title="0">{
        return "ent: " + e.label + " not found"
}</span>

// IsNotFound returns a boolean indicating whether the error is a not found error.
func IsNotFound(err error) bool <span class="cov1" title="1">{
        if err == nil </span><span class="cov0" title="0">{
                return false
        }</span>
        <span class="cov1" title="1">var e *NotFoundError
        return errors.As(err, &amp;e)</span>
}

// MaskNotFound masks not found error.
func MaskNotFound(err error) error <span class="cov0" title="0">{
        if IsNotFound(err) </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov0" title="0">return err</span>
}

// NotSingularError returns when trying to fetch a singular entity and more then one was found in the database.
type NotSingularError struct {
        label string
}

// Error implements the error interface.
func (e *NotSingularError) Error() string <span class="cov0" title="0">{
        return "ent: " + e.label + " not singular"
}</span>

// IsNotSingular returns a boolean indicating whether the error is a not singular error.
func IsNotSingular(err error) bool <span class="cov0" title="0">{
        if err == nil </span><span class="cov0" title="0">{
                return false
        }</span>
        <span class="cov0" title="0">var e *NotSingularError
        return errors.As(err, &amp;e)</span>
}

// NotLoadedError returns when trying to get a node that was not loaded by the query.
type NotLoadedError struct {
        edge string
}

// Error implements the error interface.
func (e *NotLoadedError) Error() string <span class="cov0" title="0">{
        return "ent: " + e.edge + " edge was not loaded"
}</span>

// IsNotLoaded returns a boolean indicating whether the error is a not loaded error.
func IsNotLoaded(err error) bool <span class="cov0" title="0">{
        if err == nil </span><span class="cov0" title="0">{
                return false
        }</span>
        <span class="cov0" title="0">var e *NotLoadedError
        return errors.As(err, &amp;e)</span>
}

// ConstraintError returns when trying to create/update one or more entities and
// one or more of their constraints failed. For example, violation of edge or
// field uniqueness.
type ConstraintError struct {
        msg  string
        wrap error
}

// Error implements the error interface.
func (e ConstraintError) Error() string <span class="cov3" title="4">{
        return "ent: constraint failed: " + e.msg
}</span>

// Unwrap implements the errors.Wrapper interface.
func (e *ConstraintError) Unwrap() error <span class="cov0" title="0">{
        return e.wrap
}</span>

// IsConstraintError returns a boolean indicating whether the error is a constraint failure.
func IsConstraintError(err error) bool <span class="cov0" title="0">{
        if err == nil </span><span class="cov0" title="0">{
                return false
        }</span>
        <span class="cov0" title="0">var e *ConstraintError
        return errors.As(err, &amp;e)</span>
}

// selector embedded by the different Select/GroupBy builders.
type selector struct {
        label string
        flds  *[]string
        fns   []AggregateFunc
        scan  func(context.Context, any) error
}

// ScanX is like Scan, but panics if an error occurs.
func (s *selector) ScanX(ctx context.Context, v any) <span class="cov0" title="0">{
        if err := s.scan(ctx, v); err != nil </span><span class="cov0" title="0">{
                panic(err)</span>
        }
}

// Strings returns list of strings from a selector. It is only allowed when selecting one field.
func (s *selector) Strings(ctx context.Context) ([]string, error) <span class="cov0" title="0">{
        if len(*s.flds) &gt; 1 </span><span class="cov0" title="0">{
                return nil, errors.New("ent: Strings is not achievable when selecting more than 1 field")
        }</span>
        <span class="cov0" title="0">var v []string
        if err := s.scan(ctx, &amp;v); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return v, nil</span>
}

// StringsX is like Strings, but panics if an error occurs.
func (s *selector) StringsX(ctx context.Context) []string <span class="cov0" title="0">{
        v, err := s.Strings(ctx)
        if err != nil </span><span class="cov0" title="0">{
                panic(err)</span>
        }
        <span class="cov0" title="0">return v</span>
}

// String returns a single string from a selector. It is only allowed when selecting one field.
func (s *selector) String(ctx context.Context) (_ string, err error) <span class="cov0" title="0">{
        var v []string
        if v, err = s.Strings(ctx); err != nil </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov0" title="0">switch len(v) </span>{
        case 1:<span class="cov0" title="0">
                return v[0], nil</span>
        case 0:<span class="cov0" title="0">
                err = &amp;NotFoundError{s.label}</span>
        default:<span class="cov0" title="0">
                err = fmt.Errorf("ent: Strings returned %d results when one was expected", len(v))</span>
        }
        <span class="cov0" title="0">return</span>
}

// StringX is like String, but panics if an error occurs.
func (s *selector) StringX(ctx context.Context) string <span class="cov0" title="0">{
        v, err := s.String(ctx)
        if err != nil </span><span class="cov0" title="0">{
                panic(err)</span>
        }
        <span class="cov0" title="0">return v</span>
}

// Ints returns list of ints from a selector. It is only allowed when selecting one field.
func (s *selector) Ints(ctx context.Context) ([]int, error) <span class="cov0" title="0">{
        if len(*s.flds) &gt; 1 </span><span class="cov0" title="0">{
                return nil, errors.New("ent: Ints is not achievable when selecting more than 1 field")
        }</span>
        <span class="cov0" title="0">var v []int
        if err := s.scan(ctx, &amp;v); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return v, nil</span>
}

// IntsX is like Ints, but panics if an error occurs.
func (s *selector) IntsX(ctx context.Context) []int <span class="cov0" title="0">{
        v, err := s.Ints(ctx)
        if err != nil </span><span class="cov0" title="0">{
                panic(err)</span>
        }
        <span class="cov0" title="0">return v</span>
}

// Int returns a single int from a selector. It is only allowed when selecting one field.
func (s *selector) Int(ctx context.Context) (_ int, err error) <span class="cov0" title="0">{
        var v []int
        if v, err = s.Ints(ctx); err != nil </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov0" title="0">switch len(v) </span>{
        case 1:<span class="cov0" title="0">
                return v[0], nil</span>
        case 0:<span class="cov0" title="0">
                err = &amp;NotFoundError{s.label}</span>
        default:<span class="cov0" title="0">
                err = fmt.Errorf("ent: Ints returned %d results when one was expected", len(v))</span>
        }
        <span class="cov0" title="0">return</span>
}

// IntX is like Int, but panics if an error occurs.
func (s *selector) IntX(ctx context.Context) int <span class="cov0" title="0">{
        v, err := s.Int(ctx)
        if err != nil </span><span class="cov0" title="0">{
                panic(err)</span>
        }
        <span class="cov0" title="0">return v</span>
}

// Float64s returns list of float64s from a selector. It is only allowed when selecting one field.
func (s *selector) Float64s(ctx context.Context) ([]float64, error) <span class="cov0" title="0">{
        if len(*s.flds) &gt; 1 </span><span class="cov0" title="0">{
                return nil, errors.New("ent: Float64s is not achievable when selecting more than 1 field")
        }</span>
        <span class="cov0" title="0">var v []float64
        if err := s.scan(ctx, &amp;v); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return v, nil</span>
}

// Float64sX is like Float64s, but panics if an error occurs.
func (s *selector) Float64sX(ctx context.Context) []float64 <span class="cov0" title="0">{
        v, err := s.Float64s(ctx)
        if err != nil </span><span class="cov0" title="0">{
                panic(err)</span>
        }
        <span class="cov0" title="0">return v</span>
}

// Float64 returns a single float64 from a selector. It is only allowed when selecting one field.
func (s *selector) Float64(ctx context.Context) (_ float64, err error) <span class="cov0" title="0">{
        var v []float64
        if v, err = s.Float64s(ctx); err != nil </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov0" title="0">switch len(v) </span>{
        case 1:<span class="cov0" title="0">
                return v[0], nil</span>
        case 0:<span class="cov0" title="0">
                err = &amp;NotFoundError{s.label}</span>
        default:<span class="cov0" title="0">
                err = fmt.Errorf("ent: Float64s returned %d results when one was expected", len(v))</span>
        }
        <span class="cov0" title="0">return</span>
}

// Float64X is like Float64, but panics if an error occurs.
func (s *selector) Float64X(ctx context.Context) float64 <span class="cov0" title="0">{
        v, err := s.Float64(ctx)
        if err != nil </span><span class="cov0" title="0">{
                panic(err)</span>
        }
        <span class="cov0" title="0">return v</span>
}

// Bools returns list of bools from a selector. It is only allowed when selecting one field.
func (s *selector) Bools(ctx context.Context) ([]bool, error) <span class="cov0" title="0">{
        if len(*s.flds) &gt; 1 </span><span class="cov0" title="0">{
                return nil, errors.New("ent: Bools is not achievable when selecting more than 1 field")
        }</span>
        <span class="cov0" title="0">var v []bool
        if err := s.scan(ctx, &amp;v); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return v, nil</span>
}

// BoolsX is like Bools, but panics if an error occurs.
func (s *selector) BoolsX(ctx context.Context) []bool <span class="cov0" title="0">{
        v, err := s.Bools(ctx)
        if err != nil </span><span class="cov0" title="0">{
                panic(err)</span>
        }
        <span class="cov0" title="0">return v</span>
}

// Bool returns a single bool from a selector. It is only allowed when selecting one field.
func (s *selector) Bool(ctx context.Context) (_ bool, err error) <span class="cov0" title="0">{
        var v []bool
        if v, err = s.Bools(ctx); err != nil </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov0" title="0">switch len(v) </span>{
        case 1:<span class="cov0" title="0">
                return v[0], nil</span>
        case 0:<span class="cov0" title="0">
                err = &amp;NotFoundError{s.label}</span>
        default:<span class="cov0" title="0">
                err = fmt.Errorf("ent: Bools returned %d results when one was expected", len(v))</span>
        }
        <span class="cov0" title="0">return</span>
}

// BoolX is like Bool, but panics if an error occurs.
func (s *selector) BoolX(ctx context.Context) bool <span class="cov0" title="0">{
        v, err := s.Bool(ctx)
        if err != nil </span><span class="cov0" title="0">{
                panic(err)</span>
        }
        <span class="cov0" title="0">return v</span>
}

// withHooks invokes the builder operation with the given hooks, if any.
func withHooks[V Value, M any, PM interface {
        *M
        Mutation
}](ctx context.Context, exec func(context.Context) (V, error), mutation PM, hooks []Hook) (value V, err error) <span class="cov10" title="120">{
        if len(hooks) == 0 </span><span class="cov8" title="60">{
                return exec(ctx)
        }</span>
        <span class="cov8" title="60">var mut Mutator = MutateFunc(func(ctx context.Context, m Mutation) (Value, error) </span><span class="cov8" title="60">{
                mutationT, ok := any(m).(PM)
                if !ok </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("unexpected mutation type %T", m)
                }</span>
                // Set the mutation to the builder.
                <span class="cov8" title="60">*mutation = *mutationT
                return exec(ctx)</span>
        })
        <span class="cov8" title="60">for i := len(hooks) - 1; i &gt;= 0; i-- </span><span class="cov8" title="60">{
                if hooks[i] == nil </span><span class="cov0" title="0">{
                        return value, fmt.Errorf("ent: uninitialized hook (forgotten import ent/runtime?)")
                }</span>
                <span class="cov8" title="60">mut = hooks[i](mut)</span>
        }
        <span class="cov8" title="60">v, err := mut.Mutate(ctx, mutation)
        if err != nil </span><span class="cov2" title="2">{
                return value, err
        }</span>
        <span class="cov8" title="58">nv, ok := v.(V)
        if !ok </span><span class="cov0" title="0">{
                return value, fmt.Errorf("unexpected node type %T returned from %T", v, mutation)
        }</span>
        <span class="cov8" title="58">return nv, nil</span>
}

// setContextOp returns a new context with the given QueryContext attached (including its op) in case it does not exist.
func setContextOp(ctx context.Context, qc *QueryContext, op string) context.Context <span class="cov9" title="90">{
        if ent.QueryFromContext(ctx) == nil </span><span class="cov8" title="54">{
                qc.Op = op
                ctx = ent.NewQueryContext(ctx, qc)
        }</span>
        <span class="cov9" title="90">return ctx</span>
}

func querierAll[V Value, Q interface {
        sqlAll(context.Context, ...queryHook) (V, error)
}]() Querier <span class="cov8" title="50">{
        return QuerierFunc(func(ctx context.Context, q Query) (Value, error) </span><span class="cov8" title="50">{
                query, ok := q.(Q)
                if !ok </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("unexpected query type %T", q)
                }</span>
                <span class="cov8" title="50">return query.sqlAll(ctx)</span>
        })
}

func querierCount[Q interface {
        sqlCount(context.Context) (int, error)
}]() Querier <span class="cov3" title="4">{
        return QuerierFunc(func(ctx context.Context, q Query) (Value, error) </span><span class="cov3" title="4">{
                query, ok := q.(Q)
                if !ok </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("unexpected query type %T", q)
                }</span>
                <span class="cov3" title="4">return query.sqlCount(ctx)</span>
        })
}

func withInterceptors[V Value](ctx context.Context, q Query, qr Querier, inters []Interceptor) (v V, err error) <span class="cov8" title="58">{
        for i := len(inters) - 1; i &gt;= 0; i-- </span><span class="cov0" title="0">{
                qr = inters[i].Intercept(qr)
        }</span>
        <span class="cov8" title="58">rv, err := qr.Query(ctx, q)
        if err != nil </span><span class="cov0" title="0">{
                return v, err
        }</span>
        <span class="cov8" title="58">vt, ok := rv.(V)
        if !ok </span><span class="cov0" title="0">{
                return v, fmt.Errorf("unexpected type %T returned from %T. expected type: %T", vt, q, v)
        }</span>
        <span class="cov8" title="58">return vt, nil</span>
}

func scanWithInterceptors[Q1 ent.Query, Q2 interface {
        sqlScan(context.Context, Q1, any) error
}](ctx context.Context, rootQuery Q1, selectOrGroup Q2, inters []Interceptor, v any) error <span class="cov0" title="0">{
        rv := reflect.ValueOf(v)
        var qr Querier = QuerierFunc(func(ctx context.Context, q Query) (Value, error) </span><span class="cov0" title="0">{
                query, ok := q.(Q1)
                if !ok </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("unexpected query type %T", q)
                }</span>
                <span class="cov0" title="0">if err := selectOrGroup.sqlScan(ctx, query, v); err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">if k := rv.Kind(); k == reflect.Pointer &amp;&amp; rv.Elem().CanInterface() </span><span class="cov0" title="0">{
                        return rv.Elem().Interface(), nil
                }</span>
                <span class="cov0" title="0">return v, nil</span>
        })
        <span class="cov0" title="0">for i := len(inters) - 1; i &gt;= 0; i-- </span><span class="cov0" title="0">{
                qr = inters[i].Intercept(qr)
        }</span>
        <span class="cov0" title="0">vv, err := qr.Query(ctx, rootQuery)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">switch rv2 := reflect.ValueOf(vv); </span>{
        case rv.IsNil(), rv2.IsNil(), rv.Kind() != reflect.Pointer:<span class="cov0" title="0"></span>
        case rv.Type() == rv2.Type():<span class="cov0" title="0">
                rv.Elem().Set(rv2.Elem())</span>
        case rv.Elem().Type() == rv2.Type():<span class="cov0" title="0">
                rv.Elem().Set(rv2)</span>
        }
        <span class="cov0" title="0">return nil</span>
}

// queryHook describes an internal hook for the different sqlAll methods.
type queryHook func(context.Context, *sqlgraph.QuerySpec)
</pre>
		
		<pre class="file" id="file3" style="display: none">// Code generated by ent, DO NOT EDIT.

package enttest

import (
        "auth/ent"
        "context"

        // required by schema hooks.
        _ "auth/ent/runtime"

        "auth/ent/migrate"

        "entgo.io/ent/dialect/sql/schema"
)

type (
        // TestingT is the interface that is shared between
        // testing.T and testing.B and used by enttest.
        TestingT interface {
                FailNow()
                Error(...any)
        }

        // Option configures client creation.
        Option func(*options)

        options struct {
                opts        []ent.Option
                migrateOpts []schema.MigrateOption
        }
)

// WithOptions forwards options to client creation.
func WithOptions(opts ...ent.Option) Option <span class="cov0" title="0">{
        return func(o *options) </span><span class="cov0" title="0">{
                o.opts = append(o.opts, opts...)
        }</span>
}

// WithMigrateOptions forwards options to auto migration.
func WithMigrateOptions(opts ...schema.MigrateOption) Option <span class="cov0" title="0">{
        return func(o *options) </span><span class="cov0" title="0">{
                o.migrateOpts = append(o.migrateOpts, opts...)
        }</span>
}

func newOptions(opts []Option) *options <span class="cov10" title="6">{
        o := &amp;options{}
        for _, opt := range opts </span><span class="cov0" title="0">{
                opt(o)
        }</span>
        <span class="cov10" title="6">return o</span>
}

// Open calls ent.Open and auto-run migration.
func Open(t TestingT, driverName, dataSourceName string, opts ...Option) *ent.Client <span class="cov10" title="6">{
        o := newOptions(opts)
        c, err := ent.Open(driverName, dataSourceName, o.opts...)
        if err != nil </span><span class="cov0" title="0">{
                t.Error(err)
                t.FailNow()
        }</span>
        <span class="cov10" title="6">migrateSchema(t, c, o)
        return c</span>
}

// NewClient calls ent.NewClient and auto-run migration.
func NewClient(t TestingT, opts ...Option) *ent.Client <span class="cov0" title="0">{
        o := newOptions(opts)
        c := ent.NewClient(o.opts...)
        migrateSchema(t, c, o)
        return c
}</span>
func migrateSchema(t TestingT, c *ent.Client, o *options) <span class="cov10" title="6">{
        tables, err := schema.CopyTables(migrate.Tables)
        if err != nil </span><span class="cov0" title="0">{
                t.Error(err)
                t.FailNow()
        }</span>
        <span class="cov10" title="6">if err := migrate.Create(context.Background(), c.Schema, tables, o.migrateOpts...); err != nil </span><span class="cov0" title="0">{
                t.Error(err)
                t.FailNow()
        }</span>
}
</pre>
		
		<pre class="file" id="file4" style="display: none">// Code generated by ent, DO NOT EDIT.

package hook

import (
        "auth/ent"
        "context"
        "fmt"
)

// The RoleFunc type is an adapter to allow the use of ordinary
// function as Role mutator.
type RoleFunc func(context.Context, *ent.RoleMutation) (ent.Value, error)

// Mutate calls f(ctx, m).
func (f RoleFunc) Mutate(ctx context.Context, m ent.Mutation) (ent.Value, error) <span class="cov0" title="0">{
        if mv, ok := m.(*ent.RoleMutation); ok </span><span class="cov0" title="0">{
                return f(ctx, mv)
        }</span>
        <span class="cov0" title="0">return nil, fmt.Errorf("unexpected mutation type %T. expect *ent.RoleMutation", m)</span>
}

// The TokenFunc type is an adapter to allow the use of ordinary
// function as Token mutator.
type TokenFunc func(context.Context, *ent.TokenMutation) (ent.Value, error)

// Mutate calls f(ctx, m).
func (f TokenFunc) Mutate(ctx context.Context, m ent.Mutation) (ent.Value, error) <span class="cov0" title="0">{
        if mv, ok := m.(*ent.TokenMutation); ok </span><span class="cov0" title="0">{
                return f(ctx, mv)
        }</span>
        <span class="cov0" title="0">return nil, fmt.Errorf("unexpected mutation type %T. expect *ent.TokenMutation", m)</span>
}

// The UserFunc type is an adapter to allow the use of ordinary
// function as User mutator.
type UserFunc func(context.Context, *ent.UserMutation) (ent.Value, error)

// Mutate calls f(ctx, m).
func (f UserFunc) Mutate(ctx context.Context, m ent.Mutation) (ent.Value, error) <span class="cov0" title="0">{
        if mv, ok := m.(*ent.UserMutation); ok </span><span class="cov0" title="0">{
                return f(ctx, mv)
        }</span>
        <span class="cov0" title="0">return nil, fmt.Errorf("unexpected mutation type %T. expect *ent.UserMutation", m)</span>
}

// Condition is a hook condition function.
type Condition func(context.Context, ent.Mutation) bool

// And groups conditions with the AND operator.
func And(first, second Condition, rest ...Condition) Condition <span class="cov0" title="0">{
        return func(ctx context.Context, m ent.Mutation) bool </span><span class="cov0" title="0">{
                if !first(ctx, m) || !second(ctx, m) </span><span class="cov0" title="0">{
                        return false
                }</span>
                <span class="cov0" title="0">for _, cond := range rest </span><span class="cov0" title="0">{
                        if !cond(ctx, m) </span><span class="cov0" title="0">{
                                return false
                        }</span>
                }
                <span class="cov0" title="0">return true</span>
        }
}

// Or groups conditions with the OR operator.
func Or(first, second Condition, rest ...Condition) Condition <span class="cov0" title="0">{
        return func(ctx context.Context, m ent.Mutation) bool </span><span class="cov0" title="0">{
                if first(ctx, m) || second(ctx, m) </span><span class="cov0" title="0">{
                        return true
                }</span>
                <span class="cov0" title="0">for _, cond := range rest </span><span class="cov0" title="0">{
                        if cond(ctx, m) </span><span class="cov0" title="0">{
                                return true
                        }</span>
                }
                <span class="cov0" title="0">return false</span>
        }
}

// Not negates a given condition.
func Not(cond Condition) Condition <span class="cov0" title="0">{
        return func(ctx context.Context, m ent.Mutation) bool </span><span class="cov0" title="0">{
                return !cond(ctx, m)
        }</span>
}

// HasOp is a condition testing mutation operation.
func HasOp(op ent.Op) Condition <span class="cov0" title="0">{
        return func(_ context.Context, m ent.Mutation) bool </span><span class="cov0" title="0">{
                return m.Op().Is(op)
        }</span>
}

// HasAddedFields is a condition validating `.AddedField` on fields.
func HasAddedFields(field string, fields ...string) Condition <span class="cov0" title="0">{
        return func(_ context.Context, m ent.Mutation) bool </span><span class="cov0" title="0">{
                if _, exists := m.AddedField(field); !exists </span><span class="cov0" title="0">{
                        return false
                }</span>
                <span class="cov0" title="0">for _, field := range fields </span><span class="cov0" title="0">{
                        if _, exists := m.AddedField(field); !exists </span><span class="cov0" title="0">{
                                return false
                        }</span>
                }
                <span class="cov0" title="0">return true</span>
        }
}

// HasClearedFields is a condition validating `.FieldCleared` on fields.
func HasClearedFields(field string, fields ...string) Condition <span class="cov0" title="0">{
        return func(_ context.Context, m ent.Mutation) bool </span><span class="cov0" title="0">{
                if exists := m.FieldCleared(field); !exists </span><span class="cov0" title="0">{
                        return false
                }</span>
                <span class="cov0" title="0">for _, field := range fields </span><span class="cov0" title="0">{
                        if exists := m.FieldCleared(field); !exists </span><span class="cov0" title="0">{
                                return false
                        }</span>
                }
                <span class="cov0" title="0">return true</span>
        }
}

// HasFields is a condition validating `.Field` on fields.
func HasFields(field string, fields ...string) Condition <span class="cov0" title="0">{
        return func(_ context.Context, m ent.Mutation) bool </span><span class="cov0" title="0">{
                if _, exists := m.Field(field); !exists </span><span class="cov0" title="0">{
                        return false
                }</span>
                <span class="cov0" title="0">for _, field := range fields </span><span class="cov0" title="0">{
                        if _, exists := m.Field(field); !exists </span><span class="cov0" title="0">{
                                return false
                        }</span>
                }
                <span class="cov0" title="0">return true</span>
        }
}

// If executes the given hook under condition.
//
//        hook.If(ComputeAverage, And(HasFields(...), HasAddedFields(...)))
func If(hk ent.Hook, cond Condition) ent.Hook <span class="cov0" title="0">{
        return func(next ent.Mutator) ent.Mutator </span><span class="cov0" title="0">{
                return ent.MutateFunc(func(ctx context.Context, m ent.Mutation) (ent.Value, error) </span><span class="cov0" title="0">{
                        if cond(ctx, m) </span><span class="cov0" title="0">{
                                return hk(next).Mutate(ctx, m)
                        }</span>
                        <span class="cov0" title="0">return next.Mutate(ctx, m)</span>
                })
        }
}

// On executes the given hook only for the given operation.
//
//        hook.On(Log, ent.Delete|ent.Create)
func On(hk ent.Hook, op ent.Op) ent.Hook <span class="cov0" title="0">{
        return If(hk, HasOp(op))
}</span>

// Unless skips the given hook only for the given operation.
//
//        hook.Unless(Log, ent.Update|ent.UpdateOne)
func Unless(hk ent.Hook, op ent.Op) ent.Hook <span class="cov0" title="0">{
        return If(hk, Not(HasOp(op)))
}</span>

// FixedError is a hook returning a fixed error.
func FixedError(err error) ent.Hook <span class="cov0" title="0">{
        return func(ent.Mutator) ent.Mutator </span><span class="cov0" title="0">{
                return ent.MutateFunc(func(context.Context, ent.Mutation) (ent.Value, error) </span><span class="cov0" title="0">{
                        return nil, err
                }</span>)
        }
}

// Reject returns a hook that rejects all operations that match op.
//
//        func (T) Hooks() []ent.Hook {
//                return []ent.Hook{
//                        Reject(ent.Delete|ent.Update),
//                }
//        }
func Reject(op ent.Op) ent.Hook <span class="cov0" title="0">{
        hk := FixedError(fmt.Errorf("%s operation is not allowed", op))
        return On(hk, op)
}</span>

// Chain acts as a list of hooks and is effectively immutable.
// Once created, it will always hold the same set of hooks in the same order.
type Chain struct {
        hooks []ent.Hook
}

// NewChain creates a new chain of hooks.
func NewChain(hooks ...ent.Hook) Chain <span class="cov0" title="0">{
        return Chain{append([]ent.Hook(nil), hooks...)}
}</span>

// Hook chains the list of hooks and returns the final hook.
func (c Chain) Hook() ent.Hook <span class="cov0" title="0">{
        return func(mutator ent.Mutator) ent.Mutator </span><span class="cov0" title="0">{
                for i := len(c.hooks) - 1; i &gt;= 0; i-- </span><span class="cov0" title="0">{
                        mutator = c.hooks[i](mutator)
                }</span>
                <span class="cov0" title="0">return mutator</span>
        }
}

// Append extends a chain, adding the specified hook
// as the last ones in the mutation flow.
func (c Chain) Append(hooks ...ent.Hook) Chain <span class="cov0" title="0">{
        newHooks := make([]ent.Hook, 0, len(c.hooks)+len(hooks))
        newHooks = append(newHooks, c.hooks...)
        newHooks = append(newHooks, hooks...)
        return Chain{newHooks}
}</span>

// Extend extends a chain, adding the specified chain
// as the last ones in the mutation flow.
func (c Chain) Extend(chain Chain) Chain <span class="cov0" title="0">{
        return c.Append(chain.hooks...)
}</span>
</pre>
		
		<pre class="file" id="file5" style="display: none">// Code generated by ent, DO NOT EDIT.

package migrate

import (
        "context"
        "fmt"
        "io"

        "entgo.io/ent/dialect"
        "entgo.io/ent/dialect/sql/schema"
)

var (
        // WithGlobalUniqueID sets the universal ids options to the migration.
        // If this option is enabled, ent migration will allocate a 1&lt;&lt;32 range
        // for the ids of each entity (table).
        // Note that this option cannot be applied on tables that already exist.
        WithGlobalUniqueID = schema.WithGlobalUniqueID
        // WithDropColumn sets the drop column option to the migration.
        // If this option is enabled, ent migration will drop old columns
        // that were used for both fields and edges. This defaults to false.
        WithDropColumn = schema.WithDropColumn
        // WithDropIndex sets the drop index option to the migration.
        // If this option is enabled, ent migration will drop old indexes
        // that were defined in the schema. This defaults to false.
        // Note that unique constraints are defined using `UNIQUE INDEX`,
        // and therefore, it's recommended to enable this option to get more
        // flexibility in the schema changes.
        WithDropIndex = schema.WithDropIndex
        // WithForeignKeys enables creating foreign-key in schema DDL. This defaults to true.
        WithForeignKeys = schema.WithForeignKeys
)

// Schema is the API for creating, migrating and dropping a schema.
type Schema struct {
        drv dialect.Driver
}

// NewSchema creates a new schema client.
func NewSchema(drv dialect.Driver) *Schema <span class="cov10" title="6">{ return &amp;Schema{drv: drv} }</span>

// Create creates all schema resources.
func (s *Schema) Create(ctx context.Context, opts ...schema.MigrateOption) error <span class="cov0" title="0">{
        return Create(ctx, s, Tables, opts...)
}</span>

// Create creates all table resources using the given schema driver.
func Create(ctx context.Context, s *Schema, tables []*schema.Table, opts ...schema.MigrateOption) error <span class="cov10" title="6">{
        migrate, err := schema.NewMigrate(s.drv, opts...)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("ent/migrate: %w", err)
        }</span>
        <span class="cov10" title="6">return migrate.Create(ctx, tables...)</span>
}

// WriteTo writes the schema changes to w instead of running them against the database.
//
//        if err := client.Schema.WriteTo(context.Background(), os.Stdout); err != nil {
//                log.Fatal(err)
//        }
func (s *Schema) WriteTo(ctx context.Context, w io.Writer, opts ...schema.MigrateOption) error <span class="cov0" title="0">{
        return Create(ctx, &amp;Schema{drv: &amp;schema.WriteDriver{Writer: w, Driver: s.drv}}, Tables, opts...)
}</span>
</pre>
		
		<pre class="file" id="file6" style="display: none">// Code generated by ent, DO NOT EDIT.

package migrate

import (
        "entgo.io/ent/dialect/sql/schema"
        "entgo.io/ent/schema/field"
)

var (
        // RolesColumns holds the columns for the "roles" table.
        RolesColumns = []*schema.Column{
                {Name: "id", Type: field.TypeString},
                {Name: "name", Type: field.TypeString, Unique: true},
                {Name: "permissions", Type: field.TypeJSON},
                {Name: "created_at", Type: field.TypeTime},
                {Name: "updated_at", Type: field.TypeTime},
        }
        // RolesTable holds the schema information for the "roles" table.
        RolesTable = &amp;schema.Table{
                Name:       "roles",
                Columns:    RolesColumns,
                PrimaryKey: []*schema.Column{RolesColumns[0]},
        }
        // TokensColumns holds the columns for the "tokens" table.
        TokensColumns = []*schema.Column{
                {Name: "id", Type: field.TypeString},
                {Name: "token", Type: field.TypeString, Unique: true},
                {Name: "type", Type: field.TypeEnum, Enums: []string{"access", "refresh"}},
                {Name: "expires_at", Type: field.TypeTime},
                {Name: "revoked", Type: field.TypeBool, Default: false},
                {Name: "created_at", Type: field.TypeTime},
                {Name: "updated_at", Type: field.TypeTime},
                {Name: "user_tokens", Type: field.TypeString},
        }
        // TokensTable holds the schema information for the "tokens" table.
        TokensTable = &amp;schema.Table{
                Name:       "tokens",
                Columns:    TokensColumns,
                PrimaryKey: []*schema.Column{TokensColumns[0]},
                ForeignKeys: []*schema.ForeignKey{
                        {
                                Symbol:     "tokens_users_tokens",
                                Columns:    []*schema.Column{TokensColumns[7]},
                                RefColumns: []*schema.Column{UsersColumns[0]},
                                OnDelete:   schema.NoAction,
                        },
                },
        }
        // UsersColumns holds the columns for the "users" table.
        UsersColumns = []*schema.Column{
                {Name: "id", Type: field.TypeString},
                {Name: "username", Type: field.TypeString, Unique: true},
                {Name: "email", Type: field.TypeString, Unique: true},
                {Name: "password", Type: field.TypeString},
                {Name: "created_at", Type: field.TypeTime},
                {Name: "updated_at", Type: field.TypeTime},
        }
        // UsersTable holds the schema information for the "users" table.
        UsersTable = &amp;schema.Table{
                Name:       "users",
                Columns:    UsersColumns,
                PrimaryKey: []*schema.Column{UsersColumns[0]},
        }
        // UserRolesColumns holds the columns for the "user_roles" table.
        UserRolesColumns = []*schema.Column{
                {Name: "user_id", Type: field.TypeString},
                {Name: "role_id", Type: field.TypeString},
        }
        // UserRolesTable holds the schema information for the "user_roles" table.
        UserRolesTable = &amp;schema.Table{
                Name:       "user_roles",
                Columns:    UserRolesColumns,
                PrimaryKey: []*schema.Column{UserRolesColumns[0], UserRolesColumns[1]},
                ForeignKeys: []*schema.ForeignKey{
                        {
                                Symbol:     "user_roles_user_id",
                                Columns:    []*schema.Column{UserRolesColumns[0]},
                                RefColumns: []*schema.Column{UsersColumns[0]},
                                OnDelete:   schema.Cascade,
                        },
                        {
                                Symbol:     "user_roles_role_id",
                                Columns:    []*schema.Column{UserRolesColumns[1]},
                                RefColumns: []*schema.Column{RolesColumns[0]},
                                OnDelete:   schema.Cascade,
                        },
                },
        }
        // Tables holds all the tables in the schema.
        Tables = []*schema.Table{
                RolesTable,
                TokensTable,
                UsersTable,
                UserRolesTable,
        }
)

func init() <span class="cov8" title="1">{
        TokensTable.ForeignKeys[0].RefTable = UsersTable
        UserRolesTable.ForeignKeys[0].RefTable = UsersTable
        UserRolesTable.ForeignKeys[1].RefTable = RolesTable
}</span>
</pre>
		
		<pre class="file" id="file7" style="display: none">// Code generated by ent, DO NOT EDIT.

package ent

import (
        "auth/ent/predicate"
        "auth/ent/role"
        "auth/ent/token"
        "auth/ent/user"
        "context"
        "errors"
        "fmt"
        "sync"
        "time"

        "entgo.io/ent"
        "entgo.io/ent/dialect/sql"
)

const (
        // Operation types.
        OpCreate    = ent.OpCreate
        OpDelete    = ent.OpDelete
        OpDeleteOne = ent.OpDeleteOne
        OpUpdate    = ent.OpUpdate
        OpUpdateOne = ent.OpUpdateOne

        // Node types.
        TypeRole  = "Role"
        TypeToken = "Token"
        TypeUser  = "User"
)

// RoleMutation represents an operation that mutates the Role nodes in the graph.
type RoleMutation struct {
        config
        op                Op
        typ               string
        id                *string
        name              *string
        permissions       *[]string
        appendpermissions []string
        created_at        *time.Time
        updated_at        *time.Time
        clearedFields     map[string]struct{}
        users             map[string]struct{}
        removedusers      map[string]struct{}
        clearedusers      bool
        done              bool
        oldValue          func(context.Context) (*Role, error)
        predicates        []predicate.Role
}

var _ ent.Mutation = (*RoleMutation)(nil)

// roleOption allows management of the mutation configuration using functional options.
type roleOption func(*RoleMutation)

// newRoleMutation creates new mutation for the Role entity.
func newRoleMutation(c config, op Op, opts ...roleOption) *RoleMutation <span class="cov7" title="41">{
        m := &amp;RoleMutation{
                config:        c,
                op:            op,
                typ:           TypeRole,
                clearedFields: make(map[string]struct{}),
        }
        for _, opt := range opts </span><span class="cov3" title="4">{
                opt(m)
        }</span>
        <span class="cov7" title="41">return m</span>
}

// withRoleID sets the ID field of the mutation.
func withRoleID(id string) roleOption <span class="cov2" title="3">{
        return func(m *RoleMutation) </span><span class="cov2" title="3">{
                var (
                        err   error
                        once  sync.Once
                        value *Role
                )
                m.oldValue = func(ctx context.Context) (*Role, error) </span><span class="cov0" title="0">{
                        once.Do(func() </span><span class="cov0" title="0">{
                                if m.done </span><span class="cov0" title="0">{
                                        err = errors.New("querying old values post mutation is not allowed")
                                }</span> else<span class="cov0" title="0"> {
                                        value, err = m.Client().Role.Get(ctx, id)
                                }</span>
                        })
                        <span class="cov0" title="0">return value, err</span>
                }
                <span class="cov2" title="3">m.id = &amp;id</span>
        }
}

// withRole sets the old Role of the mutation.
func withRole(node *Role) roleOption <span class="cov1" title="1">{
        return func(m *RoleMutation) </span><span class="cov1" title="1">{
                m.oldValue = func(context.Context) (*Role, error) </span><span class="cov0" title="0">{
                        return node, nil
                }</span>
                <span class="cov1" title="1">m.id = &amp;node.ID</span>
        }
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m RoleMutation) Client() *Client <span class="cov0" title="0">{
        client := &amp;Client{config: m.config}
        client.init()
        return client
}</span>

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m RoleMutation) Tx() (*Tx, error) <span class="cov0" title="0">{
        if _, ok := m.driver.(*txDriver); !ok </span><span class="cov0" title="0">{
                return nil, errors.New("ent: mutation is not running in a transaction")
        }</span>
        <span class="cov0" title="0">tx := &amp;Tx{config: m.config}
        tx.init()
        return tx, nil</span>
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Role entities.
func (m *RoleMutation) SetID(id string) <span class="cov7" title="34">{
        m.id = &amp;id
}</span>

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *RoleMutation) ID() (id string, exists bool) <span class="cov8" title="72">{
        if m.id == nil </span><span class="cov7" title="34">{
                return
        }</span>
        <span class="cov7" title="38">return *m.id, true</span>
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *RoleMutation) IDs(ctx context.Context) ([]string, error) <span class="cov0" title="0">{
        switch </span>{
        case m.op.Is(OpUpdateOne | OpDeleteOne):<span class="cov0" title="0">
                id, exists := m.ID()
                if exists </span><span class="cov0" title="0">{
                        return []string{id}, nil
                }</span>
                <span class="cov0" title="0">fallthrough</span>
        case m.op.Is(OpUpdate | OpDelete):<span class="cov0" title="0">
                return m.Client().Role.Query().Where(m.predicates...).IDs(ctx)</span>
        default:<span class="cov0" title="0">
                return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)</span>
        }
}

// SetName sets the "name" field.
func (m *RoleMutation) SetName(s string) <span class="cov7" title="35">{
        m.name = &amp;s
}</span>

// Name returns the value of the "name" field in the mutation.
func (m *RoleMutation) Name() (r string, exists bool) <span class="cov8" title="72">{
        v := m.name
        if v == nil </span><span class="cov2" title="3">{
                return
        }</span>
        <span class="cov8" title="69">return *v, true</span>
}

// OldName returns the old "name" field's value of the Role entity.
// If the Role object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RoleMutation) OldName(ctx context.Context) (v string, err error) <span class="cov0" title="0">{
        if !m.op.Is(OpUpdateOne) </span><span class="cov0" title="0">{
                return v, errors.New("OldName is only allowed on UpdateOne operations")
        }</span>
        <span class="cov0" title="0">if m.id == nil || m.oldValue == nil </span><span class="cov0" title="0">{
                return v, errors.New("OldName requires an ID field in the mutation")
        }</span>
        <span class="cov0" title="0">oldValue, err := m.oldValue(ctx)
        if err != nil </span><span class="cov0" title="0">{
                return v, fmt.Errorf("querying old value for OldName: %w", err)
        }</span>
        <span class="cov0" title="0">return oldValue.Name, nil</span>
}

// ResetName resets all changes to the "name" field.
func (m *RoleMutation) ResetName() <span class="cov0" title="0">{
        m.name = nil
}</span>

// SetPermissions sets the "permissions" field.
func (m *RoleMutation) SetPermissions(s []string) <span class="cov7" title="36">{
        m.permissions = &amp;s
        m.appendpermissions = nil
}</span>

// Permissions returns the value of the "permissions" field in the mutation.
func (m *RoleMutation) Permissions() (r []string, exists bool) <span class="cov8" title="72">{
        v := m.permissions
        if v == nil </span><span class="cov2" title="2">{
                return
        }</span>
        <span class="cov8" title="70">return *v, true</span>
}

// OldPermissions returns the old "permissions" field's value of the Role entity.
// If the Role object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RoleMutation) OldPermissions(ctx context.Context) (v []string, err error) <span class="cov0" title="0">{
        if !m.op.Is(OpUpdateOne) </span><span class="cov0" title="0">{
                return v, errors.New("OldPermissions is only allowed on UpdateOne operations")
        }</span>
        <span class="cov0" title="0">if m.id == nil || m.oldValue == nil </span><span class="cov0" title="0">{
                return v, errors.New("OldPermissions requires an ID field in the mutation")
        }</span>
        <span class="cov0" title="0">oldValue, err := m.oldValue(ctx)
        if err != nil </span><span class="cov0" title="0">{
                return v, fmt.Errorf("querying old value for OldPermissions: %w", err)
        }</span>
        <span class="cov0" title="0">return oldValue.Permissions, nil</span>
}

// AppendPermissions adds s to the "permissions" field.
func (m *RoleMutation) AppendPermissions(s []string) <span class="cov1" title="1">{
        m.appendpermissions = append(m.appendpermissions, s...)
}</span>

// AppendedPermissions returns the list of values that were appended to the "permissions" field in this mutation.
func (m *RoleMutation) AppendedPermissions() ([]string, bool) <span class="cov3" title="4">{
        if len(m.appendpermissions) == 0 </span><span class="cov2" title="3">{
                return nil, false
        }</span>
        <span class="cov1" title="1">return m.appendpermissions, true</span>
}

// ResetPermissions resets all changes to the "permissions" field.
func (m *RoleMutation) ResetPermissions() <span class="cov0" title="0">{
        m.permissions = nil
        m.appendpermissions = nil
}</span>

// SetCreatedAt sets the "created_at" field.
func (m *RoleMutation) SetCreatedAt(t time.Time) <span class="cov7" title="34">{
        m.created_at = &amp;t
}</span>

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *RoleMutation) CreatedAt() (r time.Time, exists bool) <span class="cov9" title="106">{
        v := m.created_at
        if v == nil </span><span class="cov7" title="38">{
                return
        }</span>
        <span class="cov8" title="68">return *v, true</span>
}

// OldCreatedAt returns the old "created_at" field's value of the Role entity.
// If the Role object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RoleMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) <span class="cov0" title="0">{
        if !m.op.Is(OpUpdateOne) </span><span class="cov0" title="0">{
                return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
        }</span>
        <span class="cov0" title="0">if m.id == nil || m.oldValue == nil </span><span class="cov0" title="0">{
                return v, errors.New("OldCreatedAt requires an ID field in the mutation")
        }</span>
        <span class="cov0" title="0">oldValue, err := m.oldValue(ctx)
        if err != nil </span><span class="cov0" title="0">{
                return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
        }</span>
        <span class="cov0" title="0">return oldValue.CreatedAt, nil</span>
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *RoleMutation) ResetCreatedAt() <span class="cov0" title="0">{
        m.created_at = nil
}</span>

// SetUpdatedAt sets the "updated_at" field.
func (m *RoleMutation) SetUpdatedAt(t time.Time) <span class="cov7" title="38">{
        m.updated_at = &amp;t
}</span>

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *RoleMutation) UpdatedAt() (r time.Time, exists bool) <span class="cov9" title="110">{
        v := m.updated_at
        if v == nil </span><span class="cov7" title="37">{
                return
        }</span>
        <span class="cov8" title="73">return *v, true</span>
}

// OldUpdatedAt returns the old "updated_at" field's value of the Role entity.
// If the Role object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RoleMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) <span class="cov0" title="0">{
        if !m.op.Is(OpUpdateOne) </span><span class="cov0" title="0">{
                return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
        }</span>
        <span class="cov0" title="0">if m.id == nil || m.oldValue == nil </span><span class="cov0" title="0">{
                return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
        }</span>
        <span class="cov0" title="0">oldValue, err := m.oldValue(ctx)
        if err != nil </span><span class="cov0" title="0">{
                return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
        }</span>
        <span class="cov0" title="0">return oldValue.UpdatedAt, nil</span>
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *RoleMutation) ResetUpdatedAt() <span class="cov0" title="0">{
        m.updated_at = nil
}</span>

// AddUserIDs adds the "users" edge to the User entity by ids.
func (m *RoleMutation) AddUserIDs(ids ...string) <span class="cov2" title="2">{
        if m.users == nil </span><span class="cov2" title="2">{
                m.users = make(map[string]struct{})
        }</span>
        <span class="cov2" title="2">for i := range ids </span><span class="cov2" title="2">{
                m.users[ids[i]] = struct{}{}
        }</span>
}

// ClearUsers clears the "users" edge to the User entity.
func (m *RoleMutation) ClearUsers() <span class="cov0" title="0">{
        m.clearedusers = true
}</span>

// UsersCleared reports if the "users" edge to the User entity was cleared.
func (m *RoleMutation) UsersCleared() bool <span class="cov3" title="4">{
        return m.clearedusers
}</span>

// RemoveUserIDs removes the "users" edge to the User entity by IDs.
func (m *RoleMutation) RemoveUserIDs(ids ...string) <span class="cov0" title="0">{
        if m.removedusers == nil </span><span class="cov0" title="0">{
                m.removedusers = make(map[string]struct{})
        }</span>
        <span class="cov0" title="0">for i := range ids </span><span class="cov0" title="0">{
                delete(m.users, ids[i])
                m.removedusers[ids[i]] = struct{}{}
        }</span>
}

// RemovedUsers returns the removed IDs of the "users" edge to the User entity.
func (m *RoleMutation) RemovedUsersIDs() (ids []string) <span class="cov3" title="4">{
        for id := range m.removedusers </span><span class="cov0" title="0">{
                ids = append(ids, id)
        }</span>
        <span class="cov3" title="4">return</span>
}

// UsersIDs returns the "users" edge IDs in the mutation.
func (m *RoleMutation) UsersIDs() (ids []string) <span class="cov7" title="38">{
        for id := range m.users </span><span class="cov2" title="2">{
                ids = append(ids, id)
        }</span>
        <span class="cov7" title="38">return</span>
}

// ResetUsers resets all changes to the "users" edge.
func (m *RoleMutation) ResetUsers() <span class="cov0" title="0">{
        m.users = nil
        m.clearedusers = false
        m.removedusers = nil
}</span>

// Where appends a list predicates to the RoleMutation builder.
func (m *RoleMutation) Where(ps ...predicate.Role) <span class="cov1" title="1">{
        m.predicates = append(m.predicates, ps...)
}</span>

// WhereP appends storage-level predicates to the RoleMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *RoleMutation) WhereP(ps ...func(*sql.Selector)) <span class="cov0" title="0">{
        p := make([]predicate.Role, len(ps))
        for i := range ps </span><span class="cov0" title="0">{
                p[i] = ps[i]
        }</span>
        <span class="cov0" title="0">m.Where(p...)</span>
}

// Op returns the operation name.
func (m *RoleMutation) Op() Op <span class="cov0" title="0">{
        return m.op
}</span>

// SetOp allows setting the mutation operation.
func (m *RoleMutation) SetOp(op Op) <span class="cov0" title="0">{
        m.op = op
}</span>

// Type returns the node type of this mutation (Role).
func (m *RoleMutation) Type() string <span class="cov0" title="0">{
        return m.typ
}</span>

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *RoleMutation) Fields() []string <span class="cov0" title="0">{
        fields := make([]string, 0, 4)
        if m.name != nil </span><span class="cov0" title="0">{
                fields = append(fields, role.FieldName)
        }</span>
        <span class="cov0" title="0">if m.permissions != nil </span><span class="cov0" title="0">{
                fields = append(fields, role.FieldPermissions)
        }</span>
        <span class="cov0" title="0">if m.created_at != nil </span><span class="cov0" title="0">{
                fields = append(fields, role.FieldCreatedAt)
        }</span>
        <span class="cov0" title="0">if m.updated_at != nil </span><span class="cov0" title="0">{
                fields = append(fields, role.FieldUpdatedAt)
        }</span>
        <span class="cov0" title="0">return fields</span>
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *RoleMutation) Field(name string) (ent.Value, bool) <span class="cov0" title="0">{
        switch name </span>{
        case role.FieldName:<span class="cov0" title="0">
                return m.Name()</span>
        case role.FieldPermissions:<span class="cov0" title="0">
                return m.Permissions()</span>
        case role.FieldCreatedAt:<span class="cov0" title="0">
                return m.CreatedAt()</span>
        case role.FieldUpdatedAt:<span class="cov0" title="0">
                return m.UpdatedAt()</span>
        }
        <span class="cov0" title="0">return nil, false</span>
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *RoleMutation) OldField(ctx context.Context, name string) (ent.Value, error) <span class="cov0" title="0">{
        switch name </span>{
        case role.FieldName:<span class="cov0" title="0">
                return m.OldName(ctx)</span>
        case role.FieldPermissions:<span class="cov0" title="0">
                return m.OldPermissions(ctx)</span>
        case role.FieldCreatedAt:<span class="cov0" title="0">
                return m.OldCreatedAt(ctx)</span>
        case role.FieldUpdatedAt:<span class="cov0" title="0">
                return m.OldUpdatedAt(ctx)</span>
        }
        <span class="cov0" title="0">return nil, fmt.Errorf("unknown Role field %s", name)</span>
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *RoleMutation) SetField(name string, value ent.Value) error <span class="cov0" title="0">{
        switch name </span>{
        case role.FieldName:<span class="cov0" title="0">
                v, ok := value.(string)
                if !ok </span><span class="cov0" title="0">{
                        return fmt.Errorf("unexpected type %T for field %s", value, name)
                }</span>
                <span class="cov0" title="0">m.SetName(v)
                return nil</span>
        case role.FieldPermissions:<span class="cov0" title="0">
                v, ok := value.([]string)
                if !ok </span><span class="cov0" title="0">{
                        return fmt.Errorf("unexpected type %T for field %s", value, name)
                }</span>
                <span class="cov0" title="0">m.SetPermissions(v)
                return nil</span>
        case role.FieldCreatedAt:<span class="cov0" title="0">
                v, ok := value.(time.Time)
                if !ok </span><span class="cov0" title="0">{
                        return fmt.Errorf("unexpected type %T for field %s", value, name)
                }</span>
                <span class="cov0" title="0">m.SetCreatedAt(v)
                return nil</span>
        case role.FieldUpdatedAt:<span class="cov0" title="0">
                v, ok := value.(time.Time)
                if !ok </span><span class="cov0" title="0">{
                        return fmt.Errorf("unexpected type %T for field %s", value, name)
                }</span>
                <span class="cov0" title="0">m.SetUpdatedAt(v)
                return nil</span>
        }
        <span class="cov0" title="0">return fmt.Errorf("unknown Role field %s", name)</span>
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *RoleMutation) AddedFields() []string <span class="cov0" title="0">{
        return nil
}</span>

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *RoleMutation) AddedField(name string) (ent.Value, bool) <span class="cov0" title="0">{
        return nil, false
}</span>

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *RoleMutation) AddField(name string, value ent.Value) error <span class="cov0" title="0">{
        switch name </span>{
        }
        <span class="cov0" title="0">return fmt.Errorf("unknown Role numeric field %s", name)</span>
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *RoleMutation) ClearedFields() []string <span class="cov0" title="0">{
        return nil
}</span>

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *RoleMutation) FieldCleared(name string) bool <span class="cov0" title="0">{
        _, ok := m.clearedFields[name]
        return ok
}</span>

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *RoleMutation) ClearField(name string) error <span class="cov0" title="0">{
        return fmt.Errorf("unknown Role nullable field %s", name)
}</span>

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *RoleMutation) ResetField(name string) error <span class="cov0" title="0">{
        switch name </span>{
        case role.FieldName:<span class="cov0" title="0">
                m.ResetName()
                return nil</span>
        case role.FieldPermissions:<span class="cov0" title="0">
                m.ResetPermissions()
                return nil</span>
        case role.FieldCreatedAt:<span class="cov0" title="0">
                m.ResetCreatedAt()
                return nil</span>
        case role.FieldUpdatedAt:<span class="cov0" title="0">
                m.ResetUpdatedAt()
                return nil</span>
        }
        <span class="cov0" title="0">return fmt.Errorf("unknown Role field %s", name)</span>
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *RoleMutation) AddedEdges() []string <span class="cov0" title="0">{
        edges := make([]string, 0, 1)
        if m.users != nil </span><span class="cov0" title="0">{
                edges = append(edges, role.EdgeUsers)
        }</span>
        <span class="cov0" title="0">return edges</span>
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *RoleMutation) AddedIDs(name string) []ent.Value <span class="cov0" title="0">{
        switch name </span>{
        case role.EdgeUsers:<span class="cov0" title="0">
                ids := make([]ent.Value, 0, len(m.users))
                for id := range m.users </span><span class="cov0" title="0">{
                        ids = append(ids, id)
                }</span>
                <span class="cov0" title="0">return ids</span>
        }
        <span class="cov0" title="0">return nil</span>
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *RoleMutation) RemovedEdges() []string <span class="cov0" title="0">{
        edges := make([]string, 0, 1)
        if m.removedusers != nil </span><span class="cov0" title="0">{
                edges = append(edges, role.EdgeUsers)
        }</span>
        <span class="cov0" title="0">return edges</span>
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *RoleMutation) RemovedIDs(name string) []ent.Value <span class="cov0" title="0">{
        switch name </span>{
        case role.EdgeUsers:<span class="cov0" title="0">
                ids := make([]ent.Value, 0, len(m.removedusers))
                for id := range m.removedusers </span><span class="cov0" title="0">{
                        ids = append(ids, id)
                }</span>
                <span class="cov0" title="0">return ids</span>
        }
        <span class="cov0" title="0">return nil</span>
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *RoleMutation) ClearedEdges() []string <span class="cov0" title="0">{
        edges := make([]string, 0, 1)
        if m.clearedusers </span><span class="cov0" title="0">{
                edges = append(edges, role.EdgeUsers)
        }</span>
        <span class="cov0" title="0">return edges</span>
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *RoleMutation) EdgeCleared(name string) bool <span class="cov0" title="0">{
        switch name </span>{
        case role.EdgeUsers:<span class="cov0" title="0">
                return m.clearedusers</span>
        }
        <span class="cov0" title="0">return false</span>
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *RoleMutation) ClearEdge(name string) error <span class="cov0" title="0">{
        switch name </span>{
        }
        <span class="cov0" title="0">return fmt.Errorf("unknown Role unique edge %s", name)</span>
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *RoleMutation) ResetEdge(name string) error <span class="cov0" title="0">{
        switch name </span>{
        case role.EdgeUsers:<span class="cov0" title="0">
                m.ResetUsers()
                return nil</span>
        }
        <span class="cov0" title="0">return fmt.Errorf("unknown Role edge %s", name)</span>
}

// TokenMutation represents an operation that mutates the Token nodes in the graph.
type TokenMutation struct {
        config
        op            Op
        typ           string
        id            *string
        token         *string
        _type         *token.Type
        expires_at    *time.Time
        revoked       *bool
        created_at    *time.Time
        updated_at    *time.Time
        clearedFields map[string]struct{}
        user          *string
        cleareduser   bool
        done          bool
        oldValue      func(context.Context) (*Token, error)
        predicates    []predicate.Token
}

var _ ent.Mutation = (*TokenMutation)(nil)

// tokenOption allows management of the mutation configuration using functional options.
type tokenOption func(*TokenMutation)

// newTokenMutation creates new mutation for the Token entity.
func newTokenMutation(c config, op Op, opts ...tokenOption) *TokenMutation <span class="cov6" title="19">{
        m := &amp;TokenMutation{
                config:        c,
                op:            op,
                typ:           TypeToken,
                clearedFields: make(map[string]struct{}),
        }
        for _, opt := range opts </span><span class="cov1" title="1">{
                opt(m)
        }</span>
        <span class="cov6" title="19">return m</span>
}

// withTokenID sets the ID field of the mutation.
func withTokenID(id string) tokenOption <span class="cov0" title="0">{
        return func(m *TokenMutation) </span><span class="cov0" title="0">{
                var (
                        err   error
                        once  sync.Once
                        value *Token
                )
                m.oldValue = func(ctx context.Context) (*Token, error) </span><span class="cov0" title="0">{
                        once.Do(func() </span><span class="cov0" title="0">{
                                if m.done </span><span class="cov0" title="0">{
                                        err = errors.New("querying old values post mutation is not allowed")
                                }</span> else<span class="cov0" title="0"> {
                                        value, err = m.Client().Token.Get(ctx, id)
                                }</span>
                        })
                        <span class="cov0" title="0">return value, err</span>
                }
                <span class="cov0" title="0">m.id = &amp;id</span>
        }
}

// withToken sets the old Token of the mutation.
func withToken(node *Token) tokenOption <span class="cov1" title="1">{
        return func(m *TokenMutation) </span><span class="cov1" title="1">{
                m.oldValue = func(context.Context) (*Token, error) </span><span class="cov0" title="0">{
                        return node, nil
                }</span>
                <span class="cov1" title="1">m.id = &amp;node.ID</span>
        }
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m TokenMutation) Client() *Client <span class="cov0" title="0">{
        client := &amp;Client{config: m.config}
        client.init()
        return client
}</span>

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m TokenMutation) Tx() (*Tx, error) <span class="cov0" title="0">{
        if _, ok := m.driver.(*txDriver); !ok </span><span class="cov0" title="0">{
                return nil, errors.New("ent: mutation is not running in a transaction")
        }</span>
        <span class="cov0" title="0">tx := &amp;Tx{config: m.config}
        tx.init()
        return tx, nil</span>
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Token entities.
func (m *TokenMutation) SetID(id string) <span class="cov5" title="13">{
        m.id = &amp;id
}</span>

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *TokenMutation) ID() (id string, exists bool) <span class="cov6" title="27">{
        if m.id == nil </span><span class="cov5" title="13">{
                return
        }</span>
        <span class="cov5" title="14">return *m.id, true</span>
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *TokenMutation) IDs(ctx context.Context) ([]string, error) <span class="cov0" title="0">{
        switch </span>{
        case m.op.Is(OpUpdateOne | OpDeleteOne):<span class="cov0" title="0">
                id, exists := m.ID()
                if exists </span><span class="cov0" title="0">{
                        return []string{id}, nil
                }</span>
                <span class="cov0" title="0">fallthrough</span>
        case m.op.Is(OpUpdate | OpDelete):<span class="cov0" title="0">
                return m.Client().Token.Query().Where(m.predicates...).IDs(ctx)</span>
        default:<span class="cov0" title="0">
                return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)</span>
        }
}

// SetToken sets the "token" field.
func (m *TokenMutation) SetToken(s string) <span class="cov5" title="13">{
        m.token = &amp;s
}</span>

// Token returns the value of the "token" field in the mutation.
func (m *TokenMutation) Token() (r string, exists bool) <span class="cov7" title="31">{
        v := m.token
        if v == nil </span><span class="cov3" title="5">{
                return
        }</span>
        <span class="cov6" title="26">return *v, true</span>
}

// OldToken returns the old "token" field's value of the Token entity.
// If the Token object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TokenMutation) OldToken(ctx context.Context) (v string, err error) <span class="cov0" title="0">{
        if !m.op.Is(OpUpdateOne) </span><span class="cov0" title="0">{
                return v, errors.New("OldToken is only allowed on UpdateOne operations")
        }</span>
        <span class="cov0" title="0">if m.id == nil || m.oldValue == nil </span><span class="cov0" title="0">{
                return v, errors.New("OldToken requires an ID field in the mutation")
        }</span>
        <span class="cov0" title="0">oldValue, err := m.oldValue(ctx)
        if err != nil </span><span class="cov0" title="0">{
                return v, fmt.Errorf("querying old value for OldToken: %w", err)
        }</span>
        <span class="cov0" title="0">return oldValue.Token, nil</span>
}

// ResetToken resets all changes to the "token" field.
func (m *TokenMutation) ResetToken() <span class="cov0" title="0">{
        m.token = nil
}</span>

// SetType sets the "type" field.
func (m *TokenMutation) SetType(t token.Type) <span class="cov5" title="13">{
        m._type = &amp;t
}</span>

// GetType returns the value of the "type" field in the mutation.
func (m *TokenMutation) GetType() (r token.Type, exists bool) <span class="cov7" title="49">{
        v := m._type
        if v == nil </span><span class="cov5" title="10">{
                return
        }</span>
        <span class="cov7" title="39">return *v, true</span>
}

// OldType returns the old "type" field's value of the Token entity.
// If the Token object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TokenMutation) OldType(ctx context.Context) (v token.Type, err error) <span class="cov0" title="0">{
        if !m.op.Is(OpUpdateOne) </span><span class="cov0" title="0">{
                return v, errors.New("OldType is only allowed on UpdateOne operations")
        }</span>
        <span class="cov0" title="0">if m.id == nil || m.oldValue == nil </span><span class="cov0" title="0">{
                return v, errors.New("OldType requires an ID field in the mutation")
        }</span>
        <span class="cov0" title="0">oldValue, err := m.oldValue(ctx)
        if err != nil </span><span class="cov0" title="0">{
                return v, fmt.Errorf("querying old value for OldType: %w", err)
        }</span>
        <span class="cov0" title="0">return oldValue.Type, nil</span>
}

// ResetType resets all changes to the "type" field.
func (m *TokenMutation) ResetType() <span class="cov0" title="0">{
        m._type = nil
}</span>

// SetExpiresAt sets the "expires_at" field.
func (m *TokenMutation) SetExpiresAt(t time.Time) <span class="cov5" title="13">{
        m.expires_at = &amp;t
}</span>

// ExpiresAt returns the value of the "expires_at" field in the mutation.
func (m *TokenMutation) ExpiresAt() (r time.Time, exists bool) <span class="cov7" title="31">{
        v := m.expires_at
        if v == nil </span><span class="cov3" title="5">{
                return
        }</span>
        <span class="cov6" title="26">return *v, true</span>
}

// OldExpiresAt returns the old "expires_at" field's value of the Token entity.
// If the Token object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TokenMutation) OldExpiresAt(ctx context.Context) (v time.Time, err error) <span class="cov0" title="0">{
        if !m.op.Is(OpUpdateOne) </span><span class="cov0" title="0">{
                return v, errors.New("OldExpiresAt is only allowed on UpdateOne operations")
        }</span>
        <span class="cov0" title="0">if m.id == nil || m.oldValue == nil </span><span class="cov0" title="0">{
                return v, errors.New("OldExpiresAt requires an ID field in the mutation")
        }</span>
        <span class="cov0" title="0">oldValue, err := m.oldValue(ctx)
        if err != nil </span><span class="cov0" title="0">{
                return v, fmt.Errorf("querying old value for OldExpiresAt: %w", err)
        }</span>
        <span class="cov0" title="0">return oldValue.ExpiresAt, nil</span>
}

// ResetExpiresAt resets all changes to the "expires_at" field.
func (m *TokenMutation) ResetExpiresAt() <span class="cov0" title="0">{
        m.expires_at = nil
}</span>

// SetRevoked sets the "revoked" field.
func (m *TokenMutation) SetRevoked(b bool) <span class="cov6" title="18">{
        m.revoked = &amp;b
}</span>

// Revoked returns the value of the "revoked" field in the mutation.
func (m *TokenMutation) Revoked() (r bool, exists bool) <span class="cov7" title="44">{
        v := m.revoked
        if v == nil </span><span class="cov5" title="13">{
                return
        }</span>
        <span class="cov7" title="31">return *v, true</span>
}

// OldRevoked returns the old "revoked" field's value of the Token entity.
// If the Token object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TokenMutation) OldRevoked(ctx context.Context) (v bool, err error) <span class="cov0" title="0">{
        if !m.op.Is(OpUpdateOne) </span><span class="cov0" title="0">{
                return v, errors.New("OldRevoked is only allowed on UpdateOne operations")
        }</span>
        <span class="cov0" title="0">if m.id == nil || m.oldValue == nil </span><span class="cov0" title="0">{
                return v, errors.New("OldRevoked requires an ID field in the mutation")
        }</span>
        <span class="cov0" title="0">oldValue, err := m.oldValue(ctx)
        if err != nil </span><span class="cov0" title="0">{
                return v, fmt.Errorf("querying old value for OldRevoked: %w", err)
        }</span>
        <span class="cov0" title="0">return oldValue.Revoked, nil</span>
}

// ResetRevoked resets all changes to the "revoked" field.
func (m *TokenMutation) ResetRevoked() <span class="cov0" title="0">{
        m.revoked = nil
}</span>

// SetCreatedAt sets the "created_at" field.
func (m *TokenMutation) SetCreatedAt(t time.Time) <span class="cov5" title="13">{
        m.created_at = &amp;t
}</span>

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *TokenMutation) CreatedAt() (r time.Time, exists bool) <span class="cov7" title="44">{
        v := m.created_at
        if v == nil </span><span class="cov6" title="18">{
                return
        }</span>
        <span class="cov6" title="26">return *v, true</span>
}

// OldCreatedAt returns the old "created_at" field's value of the Token entity.
// If the Token object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TokenMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) <span class="cov0" title="0">{
        if !m.op.Is(OpUpdateOne) </span><span class="cov0" title="0">{
                return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
        }</span>
        <span class="cov0" title="0">if m.id == nil || m.oldValue == nil </span><span class="cov0" title="0">{
                return v, errors.New("OldCreatedAt requires an ID field in the mutation")
        }</span>
        <span class="cov0" title="0">oldValue, err := m.oldValue(ctx)
        if err != nil </span><span class="cov0" title="0">{
                return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
        }</span>
        <span class="cov0" title="0">return oldValue.CreatedAt, nil</span>
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *TokenMutation) ResetCreatedAt() <span class="cov0" title="0">{
        m.created_at = nil
}</span>

// SetUpdatedAt sets the "updated_at" field.
func (m *TokenMutation) SetUpdatedAt(t time.Time) <span class="cov6" title="18">{
        m.updated_at = &amp;t
}</span>

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *TokenMutation) UpdatedAt() (r time.Time, exists bool) <span class="cov7" title="49">{
        v := m.updated_at
        if v == nil </span><span class="cov6" title="18">{
                return
        }</span>
        <span class="cov7" title="31">return *v, true</span>
}

// OldUpdatedAt returns the old "updated_at" field's value of the Token entity.
// If the Token object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TokenMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) <span class="cov0" title="0">{
        if !m.op.Is(OpUpdateOne) </span><span class="cov0" title="0">{
                return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
        }</span>
        <span class="cov0" title="0">if m.id == nil || m.oldValue == nil </span><span class="cov0" title="0">{
                return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
        }</span>
        <span class="cov0" title="0">oldValue, err := m.oldValue(ctx)
        if err != nil </span><span class="cov0" title="0">{
                return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
        }</span>
        <span class="cov0" title="0">return oldValue.UpdatedAt, nil</span>
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *TokenMutation) ResetUpdatedAt() <span class="cov0" title="0">{
        m.updated_at = nil
}</span>

// SetUserID sets the "user" edge to the User entity by id.
func (m *TokenMutation) SetUserID(id string) <span class="cov5" title="13">{
        m.user = &amp;id
}</span>

// ClearUser clears the "user" edge to the User entity.
func (m *TokenMutation) ClearUser() <span class="cov0" title="0">{
        m.cleareduser = true
}</span>

// UserCleared reports if the "user" edge to the User entity was cleared.
func (m *TokenMutation) UserCleared() bool <span class="cov5" title="10">{
        return m.cleareduser
}</span>

// UserID returns the "user" edge ID in the mutation.
func (m *TokenMutation) UserID() (id string, exists bool) <span class="cov6" title="18">{
        if m.user != nil </span><span class="cov5" title="13">{
                return *m.user, true
        }</span>
        <span class="cov3" title="5">return</span>
}

// UserIDs returns the "user" edge IDs in the mutation.
// Note that IDs always returns len(IDs) &lt;= 1 for unique edges, and you should use
// UserID instead. It exists only for internal usage by the builders.
func (m *TokenMutation) UserIDs() (ids []string) <span class="cov6" title="18">{
        if id := m.user; id != nil </span><span class="cov5" title="13">{
                ids = append(ids, *id)
        }</span>
        <span class="cov6" title="18">return</span>
}

// ResetUser resets all changes to the "user" edge.
func (m *TokenMutation) ResetUser() <span class="cov0" title="0">{
        m.user = nil
        m.cleareduser = false
}</span>

// Where appends a list predicates to the TokenMutation builder.
func (m *TokenMutation) Where(ps ...predicate.Token) <span class="cov3" title="5">{
        m.predicates = append(m.predicates, ps...)
}</span>

// WhereP appends storage-level predicates to the TokenMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *TokenMutation) WhereP(ps ...func(*sql.Selector)) <span class="cov0" title="0">{
        p := make([]predicate.Token, len(ps))
        for i := range ps </span><span class="cov0" title="0">{
                p[i] = ps[i]
        }</span>
        <span class="cov0" title="0">m.Where(p...)</span>
}

// Op returns the operation name.
func (m *TokenMutation) Op() Op <span class="cov0" title="0">{
        return m.op
}</span>

// SetOp allows setting the mutation operation.
func (m *TokenMutation) SetOp(op Op) <span class="cov0" title="0">{
        m.op = op
}</span>

// Type returns the node type of this mutation (Token).
func (m *TokenMutation) Type() string <span class="cov0" title="0">{
        return m.typ
}</span>

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *TokenMutation) Fields() []string <span class="cov0" title="0">{
        fields := make([]string, 0, 6)
        if m.token != nil </span><span class="cov0" title="0">{
                fields = append(fields, token.FieldToken)
        }</span>
        <span class="cov0" title="0">if m._type != nil </span><span class="cov0" title="0">{
                fields = append(fields, token.FieldType)
        }</span>
        <span class="cov0" title="0">if m.expires_at != nil </span><span class="cov0" title="0">{
                fields = append(fields, token.FieldExpiresAt)
        }</span>
        <span class="cov0" title="0">if m.revoked != nil </span><span class="cov0" title="0">{
                fields = append(fields, token.FieldRevoked)
        }</span>
        <span class="cov0" title="0">if m.created_at != nil </span><span class="cov0" title="0">{
                fields = append(fields, token.FieldCreatedAt)
        }</span>
        <span class="cov0" title="0">if m.updated_at != nil </span><span class="cov0" title="0">{
                fields = append(fields, token.FieldUpdatedAt)
        }</span>
        <span class="cov0" title="0">return fields</span>
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *TokenMutation) Field(name string) (ent.Value, bool) <span class="cov0" title="0">{
        switch name </span>{
        case token.FieldToken:<span class="cov0" title="0">
                return m.Token()</span>
        case token.FieldType:<span class="cov0" title="0">
                return m.GetType()</span>
        case token.FieldExpiresAt:<span class="cov0" title="0">
                return m.ExpiresAt()</span>
        case token.FieldRevoked:<span class="cov0" title="0">
                return m.Revoked()</span>
        case token.FieldCreatedAt:<span class="cov0" title="0">
                return m.CreatedAt()</span>
        case token.FieldUpdatedAt:<span class="cov0" title="0">
                return m.UpdatedAt()</span>
        }
        <span class="cov0" title="0">return nil, false</span>
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *TokenMutation) OldField(ctx context.Context, name string) (ent.Value, error) <span class="cov0" title="0">{
        switch name </span>{
        case token.FieldToken:<span class="cov0" title="0">
                return m.OldToken(ctx)</span>
        case token.FieldType:<span class="cov0" title="0">
                return m.OldType(ctx)</span>
        case token.FieldExpiresAt:<span class="cov0" title="0">
                return m.OldExpiresAt(ctx)</span>
        case token.FieldRevoked:<span class="cov0" title="0">
                return m.OldRevoked(ctx)</span>
        case token.FieldCreatedAt:<span class="cov0" title="0">
                return m.OldCreatedAt(ctx)</span>
        case token.FieldUpdatedAt:<span class="cov0" title="0">
                return m.OldUpdatedAt(ctx)</span>
        }
        <span class="cov0" title="0">return nil, fmt.Errorf("unknown Token field %s", name)</span>
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *TokenMutation) SetField(name string, value ent.Value) error <span class="cov0" title="0">{
        switch name </span>{
        case token.FieldToken:<span class="cov0" title="0">
                v, ok := value.(string)
                if !ok </span><span class="cov0" title="0">{
                        return fmt.Errorf("unexpected type %T for field %s", value, name)
                }</span>
                <span class="cov0" title="0">m.SetToken(v)
                return nil</span>
        case token.FieldType:<span class="cov0" title="0">
                v, ok := value.(token.Type)
                if !ok </span><span class="cov0" title="0">{
                        return fmt.Errorf("unexpected type %T for field %s", value, name)
                }</span>
                <span class="cov0" title="0">m.SetType(v)
                return nil</span>
        case token.FieldExpiresAt:<span class="cov0" title="0">
                v, ok := value.(time.Time)
                if !ok </span><span class="cov0" title="0">{
                        return fmt.Errorf("unexpected type %T for field %s", value, name)
                }</span>
                <span class="cov0" title="0">m.SetExpiresAt(v)
                return nil</span>
        case token.FieldRevoked:<span class="cov0" title="0">
                v, ok := value.(bool)
                if !ok </span><span class="cov0" title="0">{
                        return fmt.Errorf("unexpected type %T for field %s", value, name)
                }</span>
                <span class="cov0" title="0">m.SetRevoked(v)
                return nil</span>
        case token.FieldCreatedAt:<span class="cov0" title="0">
                v, ok := value.(time.Time)
                if !ok </span><span class="cov0" title="0">{
                        return fmt.Errorf("unexpected type %T for field %s", value, name)
                }</span>
                <span class="cov0" title="0">m.SetCreatedAt(v)
                return nil</span>
        case token.FieldUpdatedAt:<span class="cov0" title="0">
                v, ok := value.(time.Time)
                if !ok </span><span class="cov0" title="0">{
                        return fmt.Errorf("unexpected type %T for field %s", value, name)
                }</span>
                <span class="cov0" title="0">m.SetUpdatedAt(v)
                return nil</span>
        }
        <span class="cov0" title="0">return fmt.Errorf("unknown Token field %s", name)</span>
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *TokenMutation) AddedFields() []string <span class="cov0" title="0">{
        return nil
}</span>

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *TokenMutation) AddedField(name string) (ent.Value, bool) <span class="cov0" title="0">{
        return nil, false
}</span>

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *TokenMutation) AddField(name string, value ent.Value) error <span class="cov0" title="0">{
        switch name </span>{
        }
        <span class="cov0" title="0">return fmt.Errorf("unknown Token numeric field %s", name)</span>
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *TokenMutation) ClearedFields() []string <span class="cov0" title="0">{
        return nil
}</span>

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *TokenMutation) FieldCleared(name string) bool <span class="cov0" title="0">{
        _, ok := m.clearedFields[name]
        return ok
}</span>

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *TokenMutation) ClearField(name string) error <span class="cov0" title="0">{
        return fmt.Errorf("unknown Token nullable field %s", name)
}</span>

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *TokenMutation) ResetField(name string) error <span class="cov0" title="0">{
        switch name </span>{
        case token.FieldToken:<span class="cov0" title="0">
                m.ResetToken()
                return nil</span>
        case token.FieldType:<span class="cov0" title="0">
                m.ResetType()
                return nil</span>
        case token.FieldExpiresAt:<span class="cov0" title="0">
                m.ResetExpiresAt()
                return nil</span>
        case token.FieldRevoked:<span class="cov0" title="0">
                m.ResetRevoked()
                return nil</span>
        case token.FieldCreatedAt:<span class="cov0" title="0">
                m.ResetCreatedAt()
                return nil</span>
        case token.FieldUpdatedAt:<span class="cov0" title="0">
                m.ResetUpdatedAt()
                return nil</span>
        }
        <span class="cov0" title="0">return fmt.Errorf("unknown Token field %s", name)</span>
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *TokenMutation) AddedEdges() []string <span class="cov0" title="0">{
        edges := make([]string, 0, 1)
        if m.user != nil </span><span class="cov0" title="0">{
                edges = append(edges, token.EdgeUser)
        }</span>
        <span class="cov0" title="0">return edges</span>
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *TokenMutation) AddedIDs(name string) []ent.Value <span class="cov0" title="0">{
        switch name </span>{
        case token.EdgeUser:<span class="cov0" title="0">
                if id := m.user; id != nil </span><span class="cov0" title="0">{
                        return []ent.Value{*id}
                }</span>
        }
        <span class="cov0" title="0">return nil</span>
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *TokenMutation) RemovedEdges() []string <span class="cov0" title="0">{
        edges := make([]string, 0, 1)
        return edges
}</span>

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *TokenMutation) RemovedIDs(name string) []ent.Value <span class="cov0" title="0">{
        return nil
}</span>

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *TokenMutation) ClearedEdges() []string <span class="cov0" title="0">{
        edges := make([]string, 0, 1)
        if m.cleareduser </span><span class="cov0" title="0">{
                edges = append(edges, token.EdgeUser)
        }</span>
        <span class="cov0" title="0">return edges</span>
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *TokenMutation) EdgeCleared(name string) bool <span class="cov0" title="0">{
        switch name </span>{
        case token.EdgeUser:<span class="cov0" title="0">
                return m.cleareduser</span>
        }
        <span class="cov0" title="0">return false</span>
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *TokenMutation) ClearEdge(name string) error <span class="cov0" title="0">{
        switch name </span>{
        case token.EdgeUser:<span class="cov0" title="0">
                m.ClearUser()
                return nil</span>
        }
        <span class="cov0" title="0">return fmt.Errorf("unknown Token unique edge %s", name)</span>
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *TokenMutation) ResetEdge(name string) error <span class="cov0" title="0">{
        switch name </span>{
        case token.EdgeUser:<span class="cov0" title="0">
                m.ResetUser()
                return nil</span>
        }
        <span class="cov0" title="0">return fmt.Errorf("unknown Token edge %s", name)</span>
}

// UserMutation represents an operation that mutates the User nodes in the graph.
type UserMutation struct {
        config
        op            Op
        typ           string
        id            *string
        username      *string
        email         *string
        password      *string
        created_at    *time.Time
        updated_at    *time.Time
        clearedFields map[string]struct{}
        roles         map[string]struct{}
        removedroles  map[string]struct{}
        clearedroles  bool
        tokens        map[string]struct{}
        removedtokens map[string]struct{}
        clearedtokens bool
        done          bool
        oldValue      func(context.Context) (*User, error)
        predicates    []predicate.User
}

var _ ent.Mutation = (*UserMutation)(nil)

// userOption allows management of the mutation configuration using functional options.
type userOption func(*UserMutation)

// newUserMutation creates new mutation for the User entity.
func newUserMutation(c config, op Op, opts ...userOption) *UserMutation <span class="cov8" title="60">{
        m := &amp;UserMutation{
                config:        c,
                op:            op,
                typ:           TypeUser,
                clearedFields: make(map[string]struct{}),
        }
        for _, opt := range opts </span><span class="cov5" title="13">{
                opt(m)
        }</span>
        <span class="cov8" title="60">return m</span>
}

// withUserID sets the ID field of the mutation.
func withUserID(id string) userOption <span class="cov5" title="10">{
        return func(m *UserMutation) </span><span class="cov5" title="10">{
                var (
                        err   error
                        once  sync.Once
                        value *User
                )
                m.oldValue = func(ctx context.Context) (*User, error) </span><span class="cov0" title="0">{
                        once.Do(func() </span><span class="cov0" title="0">{
                                if m.done </span><span class="cov0" title="0">{
                                        err = errors.New("querying old values post mutation is not allowed")
                                }</span> else<span class="cov0" title="0"> {
                                        value, err = m.Client().User.Get(ctx, id)
                                }</span>
                        })
                        <span class="cov0" title="0">return value, err</span>
                }
                <span class="cov5" title="10">m.id = &amp;id</span>
        }
}

// withUser sets the old User of the mutation.
func withUser(node *User) userOption <span class="cov2" title="3">{
        return func(m *UserMutation) </span><span class="cov2" title="3">{
                m.oldValue = func(context.Context) (*User, error) </span><span class="cov0" title="0">{
                        return node, nil
                }</span>
                <span class="cov2" title="3">m.id = &amp;node.ID</span>
        }
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m UserMutation) Client() *Client <span class="cov0" title="0">{
        client := &amp;Client{config: m.config}
        client.init()
        return client
}</span>

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m UserMutation) Tx() (*Tx, error) <span class="cov0" title="0">{
        if _, ok := m.driver.(*txDriver); !ok </span><span class="cov0" title="0">{
                return nil, errors.New("ent: mutation is not running in a transaction")
        }</span>
        <span class="cov0" title="0">tx := &amp;Tx{config: m.config}
        tx.init()
        return tx, nil</span>
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of User entities.
func (m *UserMutation) SetID(id string) <span class="cov7" title="44">{
        m.id = &amp;id
}</span>

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *UserMutation) ID() (id string, exists bool) <span class="cov9" title="101">{
        if m.id == nil </span><span class="cov7" title="38">{
                return
        }</span>
        <span class="cov8" title="63">return *m.id, true</span>
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *UserMutation) IDs(ctx context.Context) ([]string, error) <span class="cov0" title="0">{
        switch </span>{
        case m.op.Is(OpUpdateOne | OpDeleteOne):<span class="cov0" title="0">
                id, exists := m.ID()
                if exists </span><span class="cov0" title="0">{
                        return []string{id}, nil
                }</span>
                <span class="cov0" title="0">fallthrough</span>
        case m.op.Is(OpUpdate | OpDelete):<span class="cov0" title="0">
                return m.Client().User.Query().Where(m.predicates...).IDs(ctx)</span>
        default:<span class="cov0" title="0">
                return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)</span>
        }
}

// SetUsername sets the "username" field.
func (m *UserMutation) SetUsername(s string) <span class="cov7" title="45">{
        m.username = &amp;s
}</span>

// Username returns the value of the "username" field in the mutation.
func (m *UserMutation) Username() (r string, exists bool) <span class="cov9" title="101">{
        v := m.username
        if v == nil </span><span class="cov5" title="12">{
                return
        }</span>
        <span class="cov8" title="89">return *v, true</span>
}

// OldUsername returns the old "username" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldUsername(ctx context.Context) (v string, err error) <span class="cov0" title="0">{
        if !m.op.Is(OpUpdateOne) </span><span class="cov0" title="0">{
                return v, errors.New("OldUsername is only allowed on UpdateOne operations")
        }</span>
        <span class="cov0" title="0">if m.id == nil || m.oldValue == nil </span><span class="cov0" title="0">{
                return v, errors.New("OldUsername requires an ID field in the mutation")
        }</span>
        <span class="cov0" title="0">oldValue, err := m.oldValue(ctx)
        if err != nil </span><span class="cov0" title="0">{
                return v, fmt.Errorf("querying old value for OldUsername: %w", err)
        }</span>
        <span class="cov0" title="0">return oldValue.Username, nil</span>
}

// ResetUsername resets all changes to the "username" field.
func (m *UserMutation) ResetUsername() <span class="cov0" title="0">{
        m.username = nil
}</span>

// SetEmail sets the "email" field.
func (m *UserMutation) SetEmail(s string) <span class="cov7" title="45">{
        m.email = &amp;s
}</span>

// Email returns the value of the "email" field in the mutation.
func (m *UserMutation) Email() (r string, exists bool) <span class="cov9" title="101">{
        v := m.email
        if v == nil </span><span class="cov5" title="12">{
                return
        }</span>
        <span class="cov8" title="89">return *v, true</span>
}

// OldEmail returns the old "email" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldEmail(ctx context.Context) (v string, err error) <span class="cov0" title="0">{
        if !m.op.Is(OpUpdateOne) </span><span class="cov0" title="0">{
                return v, errors.New("OldEmail is only allowed on UpdateOne operations")
        }</span>
        <span class="cov0" title="0">if m.id == nil || m.oldValue == nil </span><span class="cov0" title="0">{
                return v, errors.New("OldEmail requires an ID field in the mutation")
        }</span>
        <span class="cov0" title="0">oldValue, err := m.oldValue(ctx)
        if err != nil </span><span class="cov0" title="0">{
                return v, fmt.Errorf("querying old value for OldEmail: %w", err)
        }</span>
        <span class="cov0" title="0">return oldValue.Email, nil</span>
}

// ResetEmail resets all changes to the "email" field.
func (m *UserMutation) ResetEmail() <span class="cov0" title="0">{
        m.email = nil
}</span>

// SetPassword sets the "password" field.
func (m *UserMutation) SetPassword(s string) <span class="cov9" title="94">{
        m.password = &amp;s
}</span>

// Password returns the value of the "password" field in the mutation.
func (m *UserMutation) Password() (r string, exists bool) <span class="cov10" title="161">{
        v := m.password
        if v == nil </span><span class="cov6" title="23">{
                return
        }</span>
        <span class="cov9" title="138">return *v, true</span>
}

// OldPassword returns the old "password" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldPassword(ctx context.Context) (v string, err error) <span class="cov0" title="0">{
        if !m.op.Is(OpUpdateOne) </span><span class="cov0" title="0">{
                return v, errors.New("OldPassword is only allowed on UpdateOne operations")
        }</span>
        <span class="cov0" title="0">if m.id == nil || m.oldValue == nil </span><span class="cov0" title="0">{
                return v, errors.New("OldPassword requires an ID field in the mutation")
        }</span>
        <span class="cov0" title="0">oldValue, err := m.oldValue(ctx)
        if err != nil </span><span class="cov0" title="0">{
                return v, fmt.Errorf("querying old value for OldPassword: %w", err)
        }</span>
        <span class="cov0" title="0">return oldValue.Password, nil</span>
}

// ResetPassword resets all changes to the "password" field.
func (m *UserMutation) ResetPassword() <span class="cov0" title="0">{
        m.password = nil
}</span>

// SetCreatedAt sets the "created_at" field.
func (m *UserMutation) SetCreatedAt(t time.Time) <span class="cov7" title="44">{
        m.created_at = &amp;t
}</span>

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *UserMutation) CreatedAt() (r time.Time, exists bool) <span class="cov9" title="145">{
        v := m.created_at
        if v == nil </span><span class="cov8" title="57">{
                return
        }</span>
        <span class="cov8" title="88">return *v, true</span>
}

// OldCreatedAt returns the old "created_at" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) <span class="cov0" title="0">{
        if !m.op.Is(OpUpdateOne) </span><span class="cov0" title="0">{
                return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
        }</span>
        <span class="cov0" title="0">if m.id == nil || m.oldValue == nil </span><span class="cov0" title="0">{
                return v, errors.New("OldCreatedAt requires an ID field in the mutation")
        }</span>
        <span class="cov0" title="0">oldValue, err := m.oldValue(ctx)
        if err != nil </span><span class="cov0" title="0">{
                return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
        }</span>
        <span class="cov0" title="0">return oldValue.CreatedAt, nil</span>
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *UserMutation) ResetCreatedAt() <span class="cov0" title="0">{
        m.created_at = nil
}</span>

// SetUpdatedAt sets the "updated_at" field.
func (m *UserMutation) SetUpdatedAt(t time.Time) <span class="cov8" title="57">{
        m.updated_at = &amp;t
}</span>

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *UserMutation) UpdatedAt() (r time.Time, exists bool) <span class="cov9" title="158">{
        v := m.updated_at
        if v == nil </span><span class="cov8" title="55">{
                return
        }</span>
        <span class="cov9" title="103">return *v, true</span>
}

// OldUpdatedAt returns the old "updated_at" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) <span class="cov0" title="0">{
        if !m.op.Is(OpUpdateOne) </span><span class="cov0" title="0">{
                return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
        }</span>
        <span class="cov0" title="0">if m.id == nil || m.oldValue == nil </span><span class="cov0" title="0">{
                return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
        }</span>
        <span class="cov0" title="0">oldValue, err := m.oldValue(ctx)
        if err != nil </span><span class="cov0" title="0">{
                return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
        }</span>
        <span class="cov0" title="0">return oldValue.UpdatedAt, nil</span>
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *UserMutation) ResetUpdatedAt() <span class="cov0" title="0">{
        m.updated_at = nil
}</span>

// AddRoleIDs adds the "roles" edge to the Role entity by ids.
func (m *UserMutation) AddRoleIDs(ids ...string) <span class="cov4" title="8">{
        if m.roles == nil </span><span class="cov4" title="8">{
                m.roles = make(map[string]struct{})
        }</span>
        <span class="cov4" title="8">for i := range ids </span><span class="cov4" title="8">{
                m.roles[ids[i]] = struct{}{}
        }</span>
}

// ClearRoles clears the "roles" edge to the Role entity.
func (m *UserMutation) ClearRoles() <span class="cov0" title="0">{
        m.clearedroles = true
}</span>

// RolesCleared reports if the "roles" edge to the Role entity was cleared.
func (m *UserMutation) RolesCleared() bool <span class="cov5" title="15">{
        return m.clearedroles
}</span>

// RemoveRoleIDs removes the "roles" edge to the Role entity by IDs.
func (m *UserMutation) RemoveRoleIDs(ids ...string) <span class="cov2" title="2">{
        if m.removedroles == nil </span><span class="cov2" title="2">{
                m.removedroles = make(map[string]struct{})
        }</span>
        <span class="cov2" title="2">for i := range ids </span><span class="cov2" title="2">{
                delete(m.roles, ids[i])
                m.removedroles[ids[i]] = struct{}{}
        }</span>
}

// RemovedRoles returns the removed IDs of the "roles" edge to the Role entity.
func (m *UserMutation) RemovedRolesIDs() (ids []string) <span class="cov5" title="13">{
        for id := range m.removedroles </span><span class="cov2" title="2">{
                ids = append(ids, id)
        }</span>
        <span class="cov5" title="13">return</span>
}

// RolesIDs returns the "roles" edge IDs in the mutation.
func (m *UserMutation) RolesIDs() (ids []string) <span class="cov8" title="57">{
        for id := range m.roles </span><span class="cov4" title="8">{
                ids = append(ids, id)
        }</span>
        <span class="cov8" title="57">return</span>
}

// ResetRoles resets all changes to the "roles" edge.
func (m *UserMutation) ResetRoles() <span class="cov0" title="0">{
        m.roles = nil
        m.clearedroles = false
        m.removedroles = nil
}</span>

// AddTokenIDs adds the "tokens" edge to the Token entity by ids.
func (m *UserMutation) AddTokenIDs(ids ...string) <span class="cov0" title="0">{
        if m.tokens == nil </span><span class="cov0" title="0">{
                m.tokens = make(map[string]struct{})
        }</span>
        <span class="cov0" title="0">for i := range ids </span><span class="cov0" title="0">{
                m.tokens[ids[i]] = struct{}{}
        }</span>
}

// ClearTokens clears the "tokens" edge to the Token entity.
func (m *UserMutation) ClearTokens() <span class="cov0" title="0">{
        m.clearedtokens = true
}</span>

// TokensCleared reports if the "tokens" edge to the Token entity was cleared.
func (m *UserMutation) TokensCleared() bool <span class="cov5" title="13">{
        return m.clearedtokens
}</span>

// RemoveTokenIDs removes the "tokens" edge to the Token entity by IDs.
func (m *UserMutation) RemoveTokenIDs(ids ...string) <span class="cov0" title="0">{
        if m.removedtokens == nil </span><span class="cov0" title="0">{
                m.removedtokens = make(map[string]struct{})
        }</span>
        <span class="cov0" title="0">for i := range ids </span><span class="cov0" title="0">{
                delete(m.tokens, ids[i])
                m.removedtokens[ids[i]] = struct{}{}
        }</span>
}

// RemovedTokens returns the removed IDs of the "tokens" edge to the Token entity.
func (m *UserMutation) RemovedTokensIDs() (ids []string) <span class="cov5" title="13">{
        for id := range m.removedtokens </span><span class="cov0" title="0">{
                ids = append(ids, id)
        }</span>
        <span class="cov5" title="13">return</span>
}

// TokensIDs returns the "tokens" edge IDs in the mutation.
func (m *UserMutation) TokensIDs() (ids []string) <span class="cov8" title="57">{
        for id := range m.tokens </span><span class="cov0" title="0">{
                ids = append(ids, id)
        }</span>
        <span class="cov8" title="57">return</span>
}

// ResetTokens resets all changes to the "tokens" edge.
func (m *UserMutation) ResetTokens() <span class="cov0" title="0">{
        m.tokens = nil
        m.clearedtokens = false
        m.removedtokens = nil
}</span>

// Where appends a list predicates to the UserMutation builder.
func (m *UserMutation) Where(ps ...predicate.User) <span class="cov2" title="2">{
        m.predicates = append(m.predicates, ps...)
}</span>

// WhereP appends storage-level predicates to the UserMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *UserMutation) WhereP(ps ...func(*sql.Selector)) <span class="cov0" title="0">{
        p := make([]predicate.User, len(ps))
        for i := range ps </span><span class="cov0" title="0">{
                p[i] = ps[i]
        }</span>
        <span class="cov0" title="0">m.Where(p...)</span>
}

// Op returns the operation name.
func (m *UserMutation) Op() Op <span class="cov0" title="0">{
        return m.op
}</span>

// SetOp allows setting the mutation operation.
func (m *UserMutation) SetOp(op Op) <span class="cov0" title="0">{
        m.op = op
}</span>

// Type returns the node type of this mutation (User).
func (m *UserMutation) Type() string <span class="cov0" title="0">{
        return m.typ
}</span>

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *UserMutation) Fields() []string <span class="cov0" title="0">{
        fields := make([]string, 0, 5)
        if m.username != nil </span><span class="cov0" title="0">{
                fields = append(fields, user.FieldUsername)
        }</span>
        <span class="cov0" title="0">if m.email != nil </span><span class="cov0" title="0">{
                fields = append(fields, user.FieldEmail)
        }</span>
        <span class="cov0" title="0">if m.password != nil </span><span class="cov0" title="0">{
                fields = append(fields, user.FieldPassword)
        }</span>
        <span class="cov0" title="0">if m.created_at != nil </span><span class="cov0" title="0">{
                fields = append(fields, user.FieldCreatedAt)
        }</span>
        <span class="cov0" title="0">if m.updated_at != nil </span><span class="cov0" title="0">{
                fields = append(fields, user.FieldUpdatedAt)
        }</span>
        <span class="cov0" title="0">return fields</span>
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *UserMutation) Field(name string) (ent.Value, bool) <span class="cov8" title="60">{
        switch name </span>{
        case user.FieldUsername:<span class="cov0" title="0">
                return m.Username()</span>
        case user.FieldEmail:<span class="cov0" title="0">
                return m.Email()</span>
        case user.FieldPassword:<span class="cov8" title="60">
                return m.Password()</span>
        case user.FieldCreatedAt:<span class="cov0" title="0">
                return m.CreatedAt()</span>
        case user.FieldUpdatedAt:<span class="cov0" title="0">
                return m.UpdatedAt()</span>
        }
        <span class="cov0" title="0">return nil, false</span>
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *UserMutation) OldField(ctx context.Context, name string) (ent.Value, error) <span class="cov0" title="0">{
        switch name </span>{
        case user.FieldUsername:<span class="cov0" title="0">
                return m.OldUsername(ctx)</span>
        case user.FieldEmail:<span class="cov0" title="0">
                return m.OldEmail(ctx)</span>
        case user.FieldPassword:<span class="cov0" title="0">
                return m.OldPassword(ctx)</span>
        case user.FieldCreatedAt:<span class="cov0" title="0">
                return m.OldCreatedAt(ctx)</span>
        case user.FieldUpdatedAt:<span class="cov0" title="0">
                return m.OldUpdatedAt(ctx)</span>
        }
        <span class="cov0" title="0">return nil, fmt.Errorf("unknown User field %s", name)</span>
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UserMutation) SetField(name string, value ent.Value) error <span class="cov7" title="47">{
        switch name </span>{
        case user.FieldUsername:<span class="cov0" title="0">
                v, ok := value.(string)
                if !ok </span><span class="cov0" title="0">{
                        return fmt.Errorf("unexpected type %T for field %s", value, name)
                }</span>
                <span class="cov0" title="0">m.SetUsername(v)
                return nil</span>
        case user.FieldEmail:<span class="cov0" title="0">
                v, ok := value.(string)
                if !ok </span><span class="cov0" title="0">{
                        return fmt.Errorf("unexpected type %T for field %s", value, name)
                }</span>
                <span class="cov0" title="0">m.SetEmail(v)
                return nil</span>
        case user.FieldPassword:<span class="cov7" title="47">
                v, ok := value.(string)
                if !ok </span><span class="cov0" title="0">{
                        return fmt.Errorf("unexpected type %T for field %s", value, name)
                }</span>
                <span class="cov7" title="47">m.SetPassword(v)
                return nil</span>
        case user.FieldCreatedAt:<span class="cov0" title="0">
                v, ok := value.(time.Time)
                if !ok </span><span class="cov0" title="0">{
                        return fmt.Errorf("unexpected type %T for field %s", value, name)
                }</span>
                <span class="cov0" title="0">m.SetCreatedAt(v)
                return nil</span>
        case user.FieldUpdatedAt:<span class="cov0" title="0">
                v, ok := value.(time.Time)
                if !ok </span><span class="cov0" title="0">{
                        return fmt.Errorf("unexpected type %T for field %s", value, name)
                }</span>
                <span class="cov0" title="0">m.SetUpdatedAt(v)
                return nil</span>
        }
        <span class="cov0" title="0">return fmt.Errorf("unknown User field %s", name)</span>
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *UserMutation) AddedFields() []string <span class="cov0" title="0">{
        return nil
}</span>

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *UserMutation) AddedField(name string) (ent.Value, bool) <span class="cov0" title="0">{
        return nil, false
}</span>

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UserMutation) AddField(name string, value ent.Value) error <span class="cov0" title="0">{
        switch name </span>{
        }
        <span class="cov0" title="0">return fmt.Errorf("unknown User numeric field %s", name)</span>
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *UserMutation) ClearedFields() []string <span class="cov0" title="0">{
        return nil
}</span>

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *UserMutation) FieldCleared(name string) bool <span class="cov0" title="0">{
        _, ok := m.clearedFields[name]
        return ok
}</span>

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *UserMutation) ClearField(name string) error <span class="cov0" title="0">{
        return fmt.Errorf("unknown User nullable field %s", name)
}</span>

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *UserMutation) ResetField(name string) error <span class="cov0" title="0">{
        switch name </span>{
        case user.FieldUsername:<span class="cov0" title="0">
                m.ResetUsername()
                return nil</span>
        case user.FieldEmail:<span class="cov0" title="0">
                m.ResetEmail()
                return nil</span>
        case user.FieldPassword:<span class="cov0" title="0">
                m.ResetPassword()
                return nil</span>
        case user.FieldCreatedAt:<span class="cov0" title="0">
                m.ResetCreatedAt()
                return nil</span>
        case user.FieldUpdatedAt:<span class="cov0" title="0">
                m.ResetUpdatedAt()
                return nil</span>
        }
        <span class="cov0" title="0">return fmt.Errorf("unknown User field %s", name)</span>
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *UserMutation) AddedEdges() []string <span class="cov0" title="0">{
        edges := make([]string, 0, 2)
        if m.roles != nil </span><span class="cov0" title="0">{
                edges = append(edges, user.EdgeRoles)
        }</span>
        <span class="cov0" title="0">if m.tokens != nil </span><span class="cov0" title="0">{
                edges = append(edges, user.EdgeTokens)
        }</span>
        <span class="cov0" title="0">return edges</span>
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *UserMutation) AddedIDs(name string) []ent.Value <span class="cov0" title="0">{
        switch name </span>{
        case user.EdgeRoles:<span class="cov0" title="0">
                ids := make([]ent.Value, 0, len(m.roles))
                for id := range m.roles </span><span class="cov0" title="0">{
                        ids = append(ids, id)
                }</span>
                <span class="cov0" title="0">return ids</span>
        case user.EdgeTokens:<span class="cov0" title="0">
                ids := make([]ent.Value, 0, len(m.tokens))
                for id := range m.tokens </span><span class="cov0" title="0">{
                        ids = append(ids, id)
                }</span>
                <span class="cov0" title="0">return ids</span>
        }
        <span class="cov0" title="0">return nil</span>
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *UserMutation) RemovedEdges() []string <span class="cov0" title="0">{
        edges := make([]string, 0, 2)
        if m.removedroles != nil </span><span class="cov0" title="0">{
                edges = append(edges, user.EdgeRoles)
        }</span>
        <span class="cov0" title="0">if m.removedtokens != nil </span><span class="cov0" title="0">{
                edges = append(edges, user.EdgeTokens)
        }</span>
        <span class="cov0" title="0">return edges</span>
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *UserMutation) RemovedIDs(name string) []ent.Value <span class="cov0" title="0">{
        switch name </span>{
        case user.EdgeRoles:<span class="cov0" title="0">
                ids := make([]ent.Value, 0, len(m.removedroles))
                for id := range m.removedroles </span><span class="cov0" title="0">{
                        ids = append(ids, id)
                }</span>
                <span class="cov0" title="0">return ids</span>
        case user.EdgeTokens:<span class="cov0" title="0">
                ids := make([]ent.Value, 0, len(m.removedtokens))
                for id := range m.removedtokens </span><span class="cov0" title="0">{
                        ids = append(ids, id)
                }</span>
                <span class="cov0" title="0">return ids</span>
        }
        <span class="cov0" title="0">return nil</span>
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *UserMutation) ClearedEdges() []string <span class="cov0" title="0">{
        edges := make([]string, 0, 2)
        if m.clearedroles </span><span class="cov0" title="0">{
                edges = append(edges, user.EdgeRoles)
        }</span>
        <span class="cov0" title="0">if m.clearedtokens </span><span class="cov0" title="0">{
                edges = append(edges, user.EdgeTokens)
        }</span>
        <span class="cov0" title="0">return edges</span>
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *UserMutation) EdgeCleared(name string) bool <span class="cov0" title="0">{
        switch name </span>{
        case user.EdgeRoles:<span class="cov0" title="0">
                return m.clearedroles</span>
        case user.EdgeTokens:<span class="cov0" title="0">
                return m.clearedtokens</span>
        }
        <span class="cov0" title="0">return false</span>
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *UserMutation) ClearEdge(name string) error <span class="cov0" title="0">{
        switch name </span>{
        }
        <span class="cov0" title="0">return fmt.Errorf("unknown User unique edge %s", name)</span>
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *UserMutation) ResetEdge(name string) error <span class="cov0" title="0">{
        switch name </span>{
        case user.EdgeRoles:<span class="cov0" title="0">
                m.ResetRoles()
                return nil</span>
        case user.EdgeTokens:<span class="cov0" title="0">
                m.ResetTokens()
                return nil</span>
        }
        <span class="cov0" title="0">return fmt.Errorf("unknown User edge %s", name)</span>
}
</pre>
		
		<pre class="file" id="file8" style="display: none">// Code generated by ent, DO NOT EDIT.

package ent

import (
        "auth/ent/role"
        "encoding/json"
        "fmt"
        "strings"
        "time"

        "entgo.io/ent"
        "entgo.io/ent/dialect/sql"
)

// Role is the model entity for the Role schema.
type Role struct {
        config `json:"-"`
        // ID of the ent.
        ID string `json:"id,omitempty"`
        // Name holds the value of the "name" field.
        Name string `json:"name,omitempty"`
        // Permissions holds the value of the "permissions" field.
        Permissions []string `json:"permissions,omitempty"`
        // CreatedAt holds the value of the "created_at" field.
        CreatedAt time.Time `json:"created_at,omitempty"`
        // UpdatedAt holds the value of the "updated_at" field.
        UpdatedAt time.Time `json:"updated_at,omitempty"`
        // Edges holds the relations/edges for other nodes in the graph.
        // The values are being populated by the RoleQuery when eager-loading is set.
        Edges        RoleEdges `json:"edges"`
        selectValues sql.SelectValues
}

// RoleEdges holds the relations/edges for other nodes in the graph.
type RoleEdges struct {
        // Users holds the value of the users edge.
        Users []*User `json:"users,omitempty"`
        // loadedTypes holds the information for reporting if a
        // type was loaded (or requested) in eager-loading or not.
        loadedTypes [1]bool
}

// UsersOrErr returns the Users value or an error if the edge
// was not loaded in eager-loading.
func (e RoleEdges) UsersOrErr() ([]*User, error) <span class="cov0" title="0">{
        if e.loadedTypes[0] </span><span class="cov0" title="0">{
                return e.Users, nil
        }</span>
        <span class="cov0" title="0">return nil, &amp;NotLoadedError{edge: "users"}</span>
}

// scanValues returns the types for scanning values from sql.Rows.
func (*Role) scanValues(columns []string) ([]any, error) <span class="cov6" title="21">{
        values := make([]any, len(columns))
        for i := range columns </span><span class="cov10" title="105">{
                switch columns[i] </span>{
                case role.FieldPermissions:<span class="cov6" title="21">
                        values[i] = new([]byte)</span>
                case role.FieldID, role.FieldName:<span class="cov8" title="42">
                        values[i] = new(sql.NullString)</span>
                case role.FieldCreatedAt, role.FieldUpdatedAt:<span class="cov8" title="42">
                        values[i] = new(sql.NullTime)</span>
                default:<span class="cov0" title="0">
                        values[i] = new(sql.UnknownType)</span>
                }
        }
        <span class="cov6" title="21">return values, nil</span>
}

// assignValues assigns the values that were returned from sql.Rows (after scanning)
// to the Role fields.
func (r *Role) assignValues(columns []string, values []any) error <span class="cov6" title="21">{
        if m, n := len(values), len(columns); m &lt; n </span><span class="cov0" title="0">{
                return fmt.Errorf("mismatch number of scan values: %d != %d", m, n)
        }</span>
        <span class="cov6" title="21">for i := range columns </span><span class="cov10" title="105">{
                switch columns[i] </span>{
                case role.FieldID:<span class="cov6" title="21">
                        if value, ok := values[i].(*sql.NullString); !ok </span><span class="cov0" title="0">{
                                return fmt.Errorf("unexpected type %T for field id", values[i])
                        }</span> else<span class="cov6" title="21"> if value.Valid </span><span class="cov6" title="21">{
                                r.ID = value.String
                        }</span>
                case role.FieldName:<span class="cov6" title="21">
                        if value, ok := values[i].(*sql.NullString); !ok </span><span class="cov0" title="0">{
                                return fmt.Errorf("unexpected type %T for field name", values[i])
                        }</span> else<span class="cov6" title="21"> if value.Valid </span><span class="cov6" title="21">{
                                r.Name = value.String
                        }</span>
                case role.FieldPermissions:<span class="cov6" title="21">
                        if value, ok := values[i].(*[]byte); !ok </span><span class="cov0" title="0">{
                                return fmt.Errorf("unexpected type %T for field permissions", values[i])
                        }</span> else<span class="cov6" title="21"> if value != nil &amp;&amp; len(*value) &gt; 0 </span><span class="cov6" title="21">{
                                if err := json.Unmarshal(*value, &amp;r.Permissions); err != nil </span><span class="cov0" title="0">{
                                        return fmt.Errorf("unmarshal field permissions: %w", err)
                                }</span>
                        }
                case role.FieldCreatedAt:<span class="cov6" title="21">
                        if value, ok := values[i].(*sql.NullTime); !ok </span><span class="cov0" title="0">{
                                return fmt.Errorf("unexpected type %T for field created_at", values[i])
                        }</span> else<span class="cov6" title="21"> if value.Valid </span><span class="cov6" title="21">{
                                r.CreatedAt = value.Time
                        }</span>
                case role.FieldUpdatedAt:<span class="cov6" title="21">
                        if value, ok := values[i].(*sql.NullTime); !ok </span><span class="cov0" title="0">{
                                return fmt.Errorf("unexpected type %T for field updated_at", values[i])
                        }</span> else<span class="cov6" title="21"> if value.Valid </span><span class="cov6" title="21">{
                                r.UpdatedAt = value.Time
                        }</span>
                default:<span class="cov0" title="0">
                        r.selectValues.Set(columns[i], values[i])</span>
                }
        }
        <span class="cov6" title="21">return nil</span>
}

// Value returns the ent.Value that was dynamically selected and assigned to the Role.
// This includes values selected through modifiers, order, etc.
func (r *Role) Value(name string) (ent.Value, error) <span class="cov0" title="0">{
        return r.selectValues.Get(name)
}</span>

// QueryUsers queries the "users" edge of the Role entity.
func (r *Role) QueryUsers() *UserQuery <span class="cov1" title="1">{
        return NewRoleClient(r.config).QueryUsers(r)
}</span>

// Update returns a builder for updating this Role.
// Note that you need to call Role.Unwrap() before calling this method if this Role
// was returned from a transaction, and the transaction was committed or rolled back.
func (r *Role) Update() *RoleUpdateOne <span class="cov0" title="0">{
        return NewRoleClient(r.config).UpdateOne(r)
}</span>

// Unwrap unwraps the Role entity that was returned from a transaction after it was closed,
// so that all future queries will be executed through the driver which created the transaction.
func (r *Role) Unwrap() *Role <span class="cov0" title="0">{
        _tx, ok := r.config.driver.(*txDriver)
        if !ok </span><span class="cov0" title="0">{
                panic("ent: Role is not a transactional entity")</span>
        }
        <span class="cov0" title="0">r.config.driver = _tx.drv
        return r</span>
}

// String implements the fmt.Stringer.
func (r *Role) String() string <span class="cov0" title="0">{
        var builder strings.Builder
        builder.WriteString("Role(")
        builder.WriteString(fmt.Sprintf("id=%v, ", r.ID))
        builder.WriteString("name=")
        builder.WriteString(r.Name)
        builder.WriteString(", ")
        builder.WriteString("permissions=")
        builder.WriteString(fmt.Sprintf("%v", r.Permissions))
        builder.WriteString(", ")
        builder.WriteString("created_at=")
        builder.WriteString(r.CreatedAt.Format(time.ANSIC))
        builder.WriteString(", ")
        builder.WriteString("updated_at=")
        builder.WriteString(r.UpdatedAt.Format(time.ANSIC))
        builder.WriteByte(')')
        return builder.String()
}</span>

// Roles is a parsable slice of Role.
type Roles []*Role
</pre>
		
		<pre class="file" id="file9" style="display: none">// Code generated by ent, DO NOT EDIT.

package role

import (
        "time"

        "entgo.io/ent/dialect/sql"
        "entgo.io/ent/dialect/sql/sqlgraph"
)

const (
        // Label holds the string label denoting the role type in the database.
        Label = "role"
        // FieldID holds the string denoting the id field in the database.
        FieldID = "id"
        // FieldName holds the string denoting the name field in the database.
        FieldName = "name"
        // FieldPermissions holds the string denoting the permissions field in the database.
        FieldPermissions = "permissions"
        // FieldCreatedAt holds the string denoting the created_at field in the database.
        FieldCreatedAt = "created_at"
        // FieldUpdatedAt holds the string denoting the updated_at field in the database.
        FieldUpdatedAt = "updated_at"
        // EdgeUsers holds the string denoting the users edge name in mutations.
        EdgeUsers = "users"
        // Table holds the table name of the role in the database.
        Table = "roles"
        // UsersTable is the table that holds the users relation/edge. The primary key declared below.
        UsersTable = "user_roles"
        // UsersInverseTable is the table name for the User entity.
        // It exists in this package in order to avoid circular dependency with the "user" package.
        UsersInverseTable = "users"
)

// Columns holds all SQL columns for role fields.
var Columns = []string{
        FieldID,
        FieldName,
        FieldPermissions,
        FieldCreatedAt,
        FieldUpdatedAt,
}

var (
        // UsersPrimaryKey and UsersColumn2 are the table columns denoting the
        // primary key for the users relation (M2M).
        UsersPrimaryKey = []string{"user_id", "role_id"}
)

// ValidColumn reports if the column name is valid (part of the table columns).
func ValidColumn(column string) bool <span class="cov0" title="0">{
        for i := range Columns </span><span class="cov0" title="0">{
                if column == Columns[i] </span><span class="cov0" title="0">{
                        return true
                }</span>
        }
        <span class="cov0" title="0">return false</span>
}

var (
        // DefaultCreatedAt holds the default value on creation for the "created_at" field.
        DefaultCreatedAt func() time.Time
        // DefaultUpdatedAt holds the default value on creation for the "updated_at" field.
        DefaultUpdatedAt func() time.Time
        // UpdateDefaultUpdatedAt holds the default value on update for the "updated_at" field.
        UpdateDefaultUpdatedAt func() time.Time
        // DefaultID holds the default value on creation for the "id" field.
        DefaultID func() string
)

// OrderOption defines the ordering options for the Role queries.
type OrderOption func(*sql.Selector)

// ByID orders the results by the id field.
func ByID(opts ...sql.OrderTermOption) OrderOption <span class="cov0" title="0">{
        return sql.OrderByField(FieldID, opts...).ToFunc()
}</span>

// ByName orders the results by the name field.
func ByName(opts ...sql.OrderTermOption) OrderOption <span class="cov0" title="0">{
        return sql.OrderByField(FieldName, opts...).ToFunc()
}</span>

// ByCreatedAt orders the results by the created_at field.
func ByCreatedAt(opts ...sql.OrderTermOption) OrderOption <span class="cov0" title="0">{
        return sql.OrderByField(FieldCreatedAt, opts...).ToFunc()
}</span>

// ByUpdatedAt orders the results by the updated_at field.
func ByUpdatedAt(opts ...sql.OrderTermOption) OrderOption <span class="cov0" title="0">{
        return sql.OrderByField(FieldUpdatedAt, opts...).ToFunc()
}</span>

// ByUsersCount orders the results by users count.
func ByUsersCount(opts ...sql.OrderTermOption) OrderOption <span class="cov0" title="0">{
        return func(s *sql.Selector) </span><span class="cov0" title="0">{
                sqlgraph.OrderByNeighborsCount(s, newUsersStep(), opts...)
        }</span>
}

// ByUsers orders the results by users terms.
func ByUsers(term sql.OrderTerm, terms ...sql.OrderTerm) OrderOption <span class="cov0" title="0">{
        return func(s *sql.Selector) </span><span class="cov0" title="0">{
                sqlgraph.OrderByNeighborTerms(s, newUsersStep(), append([]sql.OrderTerm{term}, terms...)...)
        }</span>
}
func newUsersStep() *sqlgraph.Step <span class="cov10" title="3">{
        return sqlgraph.NewStep(
                sqlgraph.From(Table, FieldID),
                sqlgraph.To(UsersInverseTable, FieldID),
                sqlgraph.Edge(sqlgraph.M2M, true, UsersTable, UsersPrimaryKey...),
        )
}</span>
</pre>
		
		<pre class="file" id="file10" style="display: none">// Code generated by ent, DO NOT EDIT.

package role

import (
        "auth/ent/predicate"
        "time"

        "entgo.io/ent/dialect/sql"
        "entgo.io/ent/dialect/sql/sqlgraph"
)

// ID filters vertices based on their ID field.
func ID(id string) predicate.Role <span class="cov10" title="8">{
        return predicate.Role(sql.FieldEQ(FieldID, id))
}</span>

// IDEQ applies the EQ predicate on the ID field.
func IDEQ(id string) predicate.Role <span class="cov0" title="0">{
        return predicate.Role(sql.FieldEQ(FieldID, id))
}</span>

// IDNEQ applies the NEQ predicate on the ID field.
func IDNEQ(id string) predicate.Role <span class="cov0" title="0">{
        return predicate.Role(sql.FieldNEQ(FieldID, id))
}</span>

// IDIn applies the In predicate on the ID field.
func IDIn(ids ...string) predicate.Role <span class="cov0" title="0">{
        return predicate.Role(sql.FieldIn(FieldID, ids...))
}</span>

// IDNotIn applies the NotIn predicate on the ID field.
func IDNotIn(ids ...string) predicate.Role <span class="cov0" title="0">{
        return predicate.Role(sql.FieldNotIn(FieldID, ids...))
}</span>

// IDGT applies the GT predicate on the ID field.
func IDGT(id string) predicate.Role <span class="cov0" title="0">{
        return predicate.Role(sql.FieldGT(FieldID, id))
}</span>

// IDGTE applies the GTE predicate on the ID field.
func IDGTE(id string) predicate.Role <span class="cov0" title="0">{
        return predicate.Role(sql.FieldGTE(FieldID, id))
}</span>

// IDLT applies the LT predicate on the ID field.
func IDLT(id string) predicate.Role <span class="cov0" title="0">{
        return predicate.Role(sql.FieldLT(FieldID, id))
}</span>

// IDLTE applies the LTE predicate on the ID field.
func IDLTE(id string) predicate.Role <span class="cov0" title="0">{
        return predicate.Role(sql.FieldLTE(FieldID, id))
}</span>

// IDEqualFold applies the EqualFold predicate on the ID field.
func IDEqualFold(id string) predicate.Role <span class="cov0" title="0">{
        return predicate.Role(sql.FieldEqualFold(FieldID, id))
}</span>

// IDContainsFold applies the ContainsFold predicate on the ID field.
func IDContainsFold(id string) predicate.Role <span class="cov0" title="0">{
        return predicate.Role(sql.FieldContainsFold(FieldID, id))
}</span>

// Name applies equality check predicate on the "name" field. It's identical to NameEQ.
func Name(v string) predicate.Role <span class="cov1" title="1">{
        return predicate.Role(sql.FieldEQ(FieldName, v))
}</span>

// CreatedAt applies equality check predicate on the "created_at" field. It's identical to CreatedAtEQ.
func CreatedAt(v time.Time) predicate.Role <span class="cov0" title="0">{
        return predicate.Role(sql.FieldEQ(FieldCreatedAt, v))
}</span>

// UpdatedAt applies equality check predicate on the "updated_at" field. It's identical to UpdatedAtEQ.
func UpdatedAt(v time.Time) predicate.Role <span class="cov0" title="0">{
        return predicate.Role(sql.FieldEQ(FieldUpdatedAt, v))
}</span>

// NameEQ applies the EQ predicate on the "name" field.
func NameEQ(v string) predicate.Role <span class="cov0" title="0">{
        return predicate.Role(sql.FieldEQ(FieldName, v))
}</span>

// NameNEQ applies the NEQ predicate on the "name" field.
func NameNEQ(v string) predicate.Role <span class="cov0" title="0">{
        return predicate.Role(sql.FieldNEQ(FieldName, v))
}</span>

// NameIn applies the In predicate on the "name" field.
func NameIn(vs ...string) predicate.Role <span class="cov0" title="0">{
        return predicate.Role(sql.FieldIn(FieldName, vs...))
}</span>

// NameNotIn applies the NotIn predicate on the "name" field.
func NameNotIn(vs ...string) predicate.Role <span class="cov0" title="0">{
        return predicate.Role(sql.FieldNotIn(FieldName, vs...))
}</span>

// NameGT applies the GT predicate on the "name" field.
func NameGT(v string) predicate.Role <span class="cov0" title="0">{
        return predicate.Role(sql.FieldGT(FieldName, v))
}</span>

// NameGTE applies the GTE predicate on the "name" field.
func NameGTE(v string) predicate.Role <span class="cov0" title="0">{
        return predicate.Role(sql.FieldGTE(FieldName, v))
}</span>

// NameLT applies the LT predicate on the "name" field.
func NameLT(v string) predicate.Role <span class="cov0" title="0">{
        return predicate.Role(sql.FieldLT(FieldName, v))
}</span>

// NameLTE applies the LTE predicate on the "name" field.
func NameLTE(v string) predicate.Role <span class="cov0" title="0">{
        return predicate.Role(sql.FieldLTE(FieldName, v))
}</span>

// NameContains applies the Contains predicate on the "name" field.
func NameContains(v string) predicate.Role <span class="cov0" title="0">{
        return predicate.Role(sql.FieldContains(FieldName, v))
}</span>

// NameHasPrefix applies the HasPrefix predicate on the "name" field.
func NameHasPrefix(v string) predicate.Role <span class="cov1" title="1">{
        return predicate.Role(sql.FieldHasPrefix(FieldName, v))
}</span>

// NameHasSuffix applies the HasSuffix predicate on the "name" field.
func NameHasSuffix(v string) predicate.Role <span class="cov0" title="0">{
        return predicate.Role(sql.FieldHasSuffix(FieldName, v))
}</span>

// NameEqualFold applies the EqualFold predicate on the "name" field.
func NameEqualFold(v string) predicate.Role <span class="cov0" title="0">{
        return predicate.Role(sql.FieldEqualFold(FieldName, v))
}</span>

// NameContainsFold applies the ContainsFold predicate on the "name" field.
func NameContainsFold(v string) predicate.Role <span class="cov0" title="0">{
        return predicate.Role(sql.FieldContainsFold(FieldName, v))
}</span>

// CreatedAtEQ applies the EQ predicate on the "created_at" field.
func CreatedAtEQ(v time.Time) predicate.Role <span class="cov0" title="0">{
        return predicate.Role(sql.FieldEQ(FieldCreatedAt, v))
}</span>

// CreatedAtNEQ applies the NEQ predicate on the "created_at" field.
func CreatedAtNEQ(v time.Time) predicate.Role <span class="cov0" title="0">{
        return predicate.Role(sql.FieldNEQ(FieldCreatedAt, v))
}</span>

// CreatedAtIn applies the In predicate on the "created_at" field.
func CreatedAtIn(vs ...time.Time) predicate.Role <span class="cov0" title="0">{
        return predicate.Role(sql.FieldIn(FieldCreatedAt, vs...))
}</span>

// CreatedAtNotIn applies the NotIn predicate on the "created_at" field.
func CreatedAtNotIn(vs ...time.Time) predicate.Role <span class="cov0" title="0">{
        return predicate.Role(sql.FieldNotIn(FieldCreatedAt, vs...))
}</span>

// CreatedAtGT applies the GT predicate on the "created_at" field.
func CreatedAtGT(v time.Time) predicate.Role <span class="cov0" title="0">{
        return predicate.Role(sql.FieldGT(FieldCreatedAt, v))
}</span>

// CreatedAtGTE applies the GTE predicate on the "created_at" field.
func CreatedAtGTE(v time.Time) predicate.Role <span class="cov0" title="0">{
        return predicate.Role(sql.FieldGTE(FieldCreatedAt, v))
}</span>

// CreatedAtLT applies the LT predicate on the "created_at" field.
func CreatedAtLT(v time.Time) predicate.Role <span class="cov0" title="0">{
        return predicate.Role(sql.FieldLT(FieldCreatedAt, v))
}</span>

// CreatedAtLTE applies the LTE predicate on the "created_at" field.
func CreatedAtLTE(v time.Time) predicate.Role <span class="cov0" title="0">{
        return predicate.Role(sql.FieldLTE(FieldCreatedAt, v))
}</span>

// UpdatedAtEQ applies the EQ predicate on the "updated_at" field.
func UpdatedAtEQ(v time.Time) predicate.Role <span class="cov0" title="0">{
        return predicate.Role(sql.FieldEQ(FieldUpdatedAt, v))
}</span>

// UpdatedAtNEQ applies the NEQ predicate on the "updated_at" field.
func UpdatedAtNEQ(v time.Time) predicate.Role <span class="cov0" title="0">{
        return predicate.Role(sql.FieldNEQ(FieldUpdatedAt, v))
}</span>

// UpdatedAtIn applies the In predicate on the "updated_at" field.
func UpdatedAtIn(vs ...time.Time) predicate.Role <span class="cov0" title="0">{
        return predicate.Role(sql.FieldIn(FieldUpdatedAt, vs...))
}</span>

// UpdatedAtNotIn applies the NotIn predicate on the "updated_at" field.
func UpdatedAtNotIn(vs ...time.Time) predicate.Role <span class="cov0" title="0">{
        return predicate.Role(sql.FieldNotIn(FieldUpdatedAt, vs...))
}</span>

// UpdatedAtGT applies the GT predicate on the "updated_at" field.
func UpdatedAtGT(v time.Time) predicate.Role <span class="cov0" title="0">{
        return predicate.Role(sql.FieldGT(FieldUpdatedAt, v))
}</span>

// UpdatedAtGTE applies the GTE predicate on the "updated_at" field.
func UpdatedAtGTE(v time.Time) predicate.Role <span class="cov0" title="0">{
        return predicate.Role(sql.FieldGTE(FieldUpdatedAt, v))
}</span>

// UpdatedAtLT applies the LT predicate on the "updated_at" field.
func UpdatedAtLT(v time.Time) predicate.Role <span class="cov0" title="0">{
        return predicate.Role(sql.FieldLT(FieldUpdatedAt, v))
}</span>

// UpdatedAtLTE applies the LTE predicate on the "updated_at" field.
func UpdatedAtLTE(v time.Time) predicate.Role <span class="cov0" title="0">{
        return predicate.Role(sql.FieldLTE(FieldUpdatedAt, v))
}</span>

// HasUsers applies the HasEdge predicate on the "users" edge.
func HasUsers() predicate.Role <span class="cov0" title="0">{
        return predicate.Role(func(s *sql.Selector) </span><span class="cov0" title="0">{
                step := sqlgraph.NewStep(
                        sqlgraph.From(Table, FieldID),
                        sqlgraph.Edge(sqlgraph.M2M, true, UsersTable, UsersPrimaryKey...),
                )
                sqlgraph.HasNeighbors(s, step)
        }</span>)
}

// HasUsersWith applies the HasEdge predicate on the "users" edge with a given conditions (other predicates).
func HasUsersWith(preds ...predicate.User) predicate.Role <span class="cov5" title="3">{
        return predicate.Role(func(s *sql.Selector) </span><span class="cov5" title="3">{
                step := newUsersStep()
                sqlgraph.HasNeighborsWith(s, step, func(s *sql.Selector) </span><span class="cov5" title="3">{
                        for _, p := range preds </span><span class="cov5" title="3">{
                                p(s)
                        }</span>
                })
        })
}

// And groups predicates with the AND operator between them.
func And(predicates ...predicate.Role) predicate.Role <span class="cov0" title="0">{
        return predicate.Role(sql.AndPredicates(predicates...))
}</span>

// Or groups predicates with the OR operator between them.
func Or(predicates ...predicate.Role) predicate.Role <span class="cov0" title="0">{
        return predicate.Role(sql.OrPredicates(predicates...))
}</span>

// Not applies the not operator on the given predicate.
func Not(p predicate.Role) predicate.Role <span class="cov0" title="0">{
        return predicate.Role(sql.NotPredicates(p))
}</span>
</pre>
		
		<pre class="file" id="file11" style="display: none">// Code generated by ent, DO NOT EDIT.

package ent

import (
        "auth/ent/role"
        "auth/ent/user"
        "context"
        "errors"
        "fmt"
        "time"

        "entgo.io/ent/dialect/sql/sqlgraph"
        "entgo.io/ent/schema/field"
)

// RoleCreate is the builder for creating a Role entity.
type RoleCreate struct {
        config
        mutation *RoleMutation
        hooks    []Hook
}

// SetName sets the "name" field.
func (rc *RoleCreate) SetName(s string) *RoleCreate <span class="cov10" title="34">{
        rc.mutation.SetName(s)
        return rc
}</span>

// SetPermissions sets the "permissions" field.
func (rc *RoleCreate) SetPermissions(s []string) *RoleCreate <span class="cov10" title="34">{
        rc.mutation.SetPermissions(s)
        return rc
}</span>

// SetCreatedAt sets the "created_at" field.
func (rc *RoleCreate) SetCreatedAt(t time.Time) *RoleCreate <span class="cov0" title="0">{
        rc.mutation.SetCreatedAt(t)
        return rc
}</span>

// SetNillableCreatedAt sets the "created_at" field if the given value is not nil.
func (rc *RoleCreate) SetNillableCreatedAt(t *time.Time) *RoleCreate <span class="cov0" title="0">{
        if t != nil </span><span class="cov0" title="0">{
                rc.SetCreatedAt(*t)
        }</span>
        <span class="cov0" title="0">return rc</span>
}

// SetUpdatedAt sets the "updated_at" field.
func (rc *RoleCreate) SetUpdatedAt(t time.Time) *RoleCreate <span class="cov0" title="0">{
        rc.mutation.SetUpdatedAt(t)
        return rc
}</span>

// SetNillableUpdatedAt sets the "updated_at" field if the given value is not nil.
func (rc *RoleCreate) SetNillableUpdatedAt(t *time.Time) *RoleCreate <span class="cov0" title="0">{
        if t != nil </span><span class="cov0" title="0">{
                rc.SetUpdatedAt(*t)
        }</span>
        <span class="cov0" title="0">return rc</span>
}

// SetID sets the "id" field.
func (rc *RoleCreate) SetID(s string) *RoleCreate <span class="cov0" title="0">{
        rc.mutation.SetID(s)
        return rc
}</span>

// SetNillableID sets the "id" field if the given value is not nil.
func (rc *RoleCreate) SetNillableID(s *string) *RoleCreate <span class="cov0" title="0">{
        if s != nil </span><span class="cov0" title="0">{
                rc.SetID(*s)
        }</span>
        <span class="cov0" title="0">return rc</span>
}

// AddUserIDs adds the "users" edge to the User entity by IDs.
func (rc *RoleCreate) AddUserIDs(ids ...string) *RoleCreate <span class="cov1" title="1">{
        rc.mutation.AddUserIDs(ids...)
        return rc
}</span>

// AddUsers adds the "users" edges to the User entity.
func (rc *RoleCreate) AddUsers(u ...*User) *RoleCreate <span class="cov1" title="1">{
        ids := make([]string, len(u))
        for i := range u </span><span class="cov1" title="1">{
                ids[i] = u[i].ID
        }</span>
        <span class="cov1" title="1">return rc.AddUserIDs(ids...)</span>
}

// Mutation returns the RoleMutation object of the builder.
func (rc *RoleCreate) Mutation() *RoleMutation <span class="cov0" title="0">{
        return rc.mutation
}</span>

// Save creates the Role in the database.
func (rc *RoleCreate) Save(ctx context.Context) (*Role, error) <span class="cov10" title="34">{
        rc.defaults()
        return withHooks(ctx, rc.sqlSave, rc.mutation, rc.hooks)
}</span>

// SaveX calls Save and panics if Save returns an error.
func (rc *RoleCreate) SaveX(ctx context.Context) *Role <span class="cov0" title="0">{
        v, err := rc.Save(ctx)
        if err != nil </span><span class="cov0" title="0">{
                panic(err)</span>
        }
        <span class="cov0" title="0">return v</span>
}

// Exec executes the query.
func (rc *RoleCreate) Exec(ctx context.Context) error <span class="cov0" title="0">{
        _, err := rc.Save(ctx)
        return err
}</span>

// ExecX is like Exec, but panics if an error occurs.
func (rc *RoleCreate) ExecX(ctx context.Context) <span class="cov0" title="0">{
        if err := rc.Exec(ctx); err != nil </span><span class="cov0" title="0">{
                panic(err)</span>
        }
}

// defaults sets the default values of the builder before save.
func (rc *RoleCreate) defaults() <span class="cov10" title="34">{
        if _, ok := rc.mutation.CreatedAt(); !ok </span><span class="cov10" title="34">{
                v := role.DefaultCreatedAt()
                rc.mutation.SetCreatedAt(v)
        }</span>
        <span class="cov10" title="34">if _, ok := rc.mutation.UpdatedAt(); !ok </span><span class="cov10" title="34">{
                v := role.DefaultUpdatedAt()
                rc.mutation.SetUpdatedAt(v)
        }</span>
        <span class="cov10" title="34">if _, ok := rc.mutation.ID(); !ok </span><span class="cov10" title="34">{
                v := role.DefaultID()
                rc.mutation.SetID(v)
        }</span>
}

// check runs all checks and user-defined validators on the builder.
func (rc *RoleCreate) check() error <span class="cov10" title="34">{
        if _, ok := rc.mutation.Name(); !ok </span><span class="cov0" title="0">{
                return &amp;ValidationError{Name: "name", err: errors.New(`ent: missing required field "Role.name"`)}
        }</span>
        <span class="cov10" title="34">if _, ok := rc.mutation.Permissions(); !ok </span><span class="cov0" title="0">{
                return &amp;ValidationError{Name: "permissions", err: errors.New(`ent: missing required field "Role.permissions"`)}
        }</span>
        <span class="cov10" title="34">if _, ok := rc.mutation.CreatedAt(); !ok </span><span class="cov0" title="0">{
                return &amp;ValidationError{Name: "created_at", err: errors.New(`ent: missing required field "Role.created_at"`)}
        }</span>
        <span class="cov10" title="34">if _, ok := rc.mutation.UpdatedAt(); !ok </span><span class="cov0" title="0">{
                return &amp;ValidationError{Name: "updated_at", err: errors.New(`ent: missing required field "Role.updated_at"`)}
        }</span>
        <span class="cov10" title="34">return nil</span>
}

func (rc *RoleCreate) sqlSave(ctx context.Context) (*Role, error) <span class="cov10" title="34">{
        if err := rc.check(); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov10" title="34">_node, _spec := rc.createSpec()
        if err := sqlgraph.CreateNode(ctx, rc.driver, _spec); err != nil </span><span class="cov1" title="1">{
                if sqlgraph.IsConstraintError(err) </span><span class="cov1" title="1">{
                        err = &amp;ConstraintError{msg: err.Error(), wrap: err}
                }</span>
                <span class="cov1" title="1">return nil, err</span>
        }
        <span class="cov9" title="33">if _spec.ID.Value != nil </span><span class="cov9" title="33">{
                if id, ok := _spec.ID.Value.(string); ok </span><span class="cov9" title="33">{
                        _node.ID = id
                }</span> else<span class="cov0" title="0"> {
                        return nil, fmt.Errorf("unexpected Role.ID type: %T", _spec.ID.Value)
                }</span>
        }
        <span class="cov9" title="33">rc.mutation.id = &amp;_node.ID
        rc.mutation.done = true
        return _node, nil</span>
}

func (rc *RoleCreate) createSpec() (*Role, *sqlgraph.CreateSpec) <span class="cov10" title="34">{
        var (
                _node = &amp;Role{config: rc.config}
                _spec = sqlgraph.NewCreateSpec(role.Table, sqlgraph.NewFieldSpec(role.FieldID, field.TypeString))
        )
        if id, ok := rc.mutation.ID(); ok </span><span class="cov10" title="34">{
                _node.ID = id
                _spec.ID.Value = id
        }</span>
        <span class="cov10" title="34">if value, ok := rc.mutation.Name(); ok </span><span class="cov10" title="34">{
                _spec.SetField(role.FieldName, field.TypeString, value)
                _node.Name = value
        }</span>
        <span class="cov10" title="34">if value, ok := rc.mutation.Permissions(); ok </span><span class="cov10" title="34">{
                _spec.SetField(role.FieldPermissions, field.TypeJSON, value)
                _node.Permissions = value
        }</span>
        <span class="cov10" title="34">if value, ok := rc.mutation.CreatedAt(); ok </span><span class="cov10" title="34">{
                _spec.SetField(role.FieldCreatedAt, field.TypeTime, value)
                _node.CreatedAt = value
        }</span>
        <span class="cov10" title="34">if value, ok := rc.mutation.UpdatedAt(); ok </span><span class="cov10" title="34">{
                _spec.SetField(role.FieldUpdatedAt, field.TypeTime, value)
                _node.UpdatedAt = value
        }</span>
        <span class="cov10" title="34">if nodes := rc.mutation.UsersIDs(); len(nodes) &gt; 0 </span><span class="cov1" title="1">{
                edge := &amp;sqlgraph.EdgeSpec{
                        Rel:     sqlgraph.M2M,
                        Inverse: true,
                        Table:   role.UsersTable,
                        Columns: role.UsersPrimaryKey,
                        Bidi:    false,
                        Target: &amp;sqlgraph.EdgeTarget{
                                IDSpec: sqlgraph.NewFieldSpec(user.FieldID, field.TypeString),
                        },
                }
                for _, k := range nodes </span><span class="cov1" title="1">{
                        edge.Target.Nodes = append(edge.Target.Nodes, k)
                }</span>
                <span class="cov1" title="1">_spec.Edges = append(_spec.Edges, edge)</span>
        }
        <span class="cov10" title="34">return _node, _spec</span>
}

// RoleCreateBulk is the builder for creating many Role entities in bulk.
type RoleCreateBulk struct {
        config
        err      error
        builders []*RoleCreate
}

// Save creates the Role entities in the database.
func (rcb *RoleCreateBulk) Save(ctx context.Context) ([]*Role, error) <span class="cov0" title="0">{
        if rcb.err != nil </span><span class="cov0" title="0">{
                return nil, rcb.err
        }</span>
        <span class="cov0" title="0">specs := make([]*sqlgraph.CreateSpec, len(rcb.builders))
        nodes := make([]*Role, len(rcb.builders))
        mutators := make([]Mutator, len(rcb.builders))
        for i := range rcb.builders </span><span class="cov0" title="0">{
                func(i int, root context.Context) </span><span class="cov0" title="0">{
                        builder := rcb.builders[i]
                        builder.defaults()
                        var mut Mutator = MutateFunc(func(ctx context.Context, m Mutation) (Value, error) </span><span class="cov0" title="0">{
                                mutation, ok := m.(*RoleMutation)
                                if !ok </span><span class="cov0" title="0">{
                                        return nil, fmt.Errorf("unexpected mutation type %T", m)
                                }</span>
                                <span class="cov0" title="0">if err := builder.check(); err != nil </span><span class="cov0" title="0">{
                                        return nil, err
                                }</span>
                                <span class="cov0" title="0">builder.mutation = mutation
                                var err error
                                nodes[i], specs[i] = builder.createSpec()
                                if i &lt; len(mutators)-1 </span><span class="cov0" title="0">{
                                        _, err = mutators[i+1].Mutate(root, rcb.builders[i+1].mutation)
                                }</span> else<span class="cov0" title="0"> {
                                        spec := &amp;sqlgraph.BatchCreateSpec{Nodes: specs}
                                        // Invoke the actual operation on the latest mutation in the chain.
                                        if err = sqlgraph.BatchCreate(ctx, rcb.driver, spec); err != nil </span><span class="cov0" title="0">{
                                                if sqlgraph.IsConstraintError(err) </span><span class="cov0" title="0">{
                                                        err = &amp;ConstraintError{msg: err.Error(), wrap: err}
                                                }</span>
                                        }
                                }
                                <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                                        return nil, err
                                }</span>
                                <span class="cov0" title="0">mutation.id = &amp;nodes[i].ID
                                mutation.done = true
                                return nodes[i], nil</span>
                        })
                        <span class="cov0" title="0">for i := len(builder.hooks) - 1; i &gt;= 0; i-- </span><span class="cov0" title="0">{
                                mut = builder.hooks[i](mut)
                        }</span>
                        <span class="cov0" title="0">mutators[i] = mut</span>
                }(i, ctx)
        }
        <span class="cov0" title="0">if len(mutators) &gt; 0 </span><span class="cov0" title="0">{
                if _, err := mutators[0].Mutate(ctx, rcb.builders[0].mutation); err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
        }
        <span class="cov0" title="0">return nodes, nil</span>
}

// SaveX is like Save, but panics if an error occurs.
func (rcb *RoleCreateBulk) SaveX(ctx context.Context) []*Role <span class="cov0" title="0">{
        v, err := rcb.Save(ctx)
        if err != nil </span><span class="cov0" title="0">{
                panic(err)</span>
        }
        <span class="cov0" title="0">return v</span>
}

// Exec executes the query.
func (rcb *RoleCreateBulk) Exec(ctx context.Context) error <span class="cov0" title="0">{
        _, err := rcb.Save(ctx)
        return err
}</span>

// ExecX is like Exec, but panics if an error occurs.
func (rcb *RoleCreateBulk) ExecX(ctx context.Context) <span class="cov0" title="0">{
        if err := rcb.Exec(ctx); err != nil </span><span class="cov0" title="0">{
                panic(err)</span>
        }
}
</pre>
		
		<pre class="file" id="file12" style="display: none">// Code generated by ent, DO NOT EDIT.

package ent

import (
        "auth/ent/predicate"
        "auth/ent/role"
        "context"

        "entgo.io/ent/dialect/sql"
        "entgo.io/ent/dialect/sql/sqlgraph"
        "entgo.io/ent/schema/field"
)

// RoleDelete is the builder for deleting a Role entity.
type RoleDelete struct {
        config
        hooks    []Hook
        mutation *RoleMutation
}

// Where appends a list predicates to the RoleDelete builder.
func (rd *RoleDelete) Where(ps ...predicate.Role) *RoleDelete <span class="cov1" title="1">{
        rd.mutation.Where(ps...)
        return rd
}</span>

// Exec executes the deletion query and returns how many vertices were deleted.
func (rd *RoleDelete) Exec(ctx context.Context) (int, error) <span class="cov10" title="3">{
        return withHooks(ctx, rd.sqlExec, rd.mutation, rd.hooks)
}</span>

// ExecX is like Exec, but panics if an error occurs.
func (rd *RoleDelete) ExecX(ctx context.Context) int <span class="cov0" title="0">{
        n, err := rd.Exec(ctx)
        if err != nil </span><span class="cov0" title="0">{
                panic(err)</span>
        }
        <span class="cov0" title="0">return n</span>
}

func (rd *RoleDelete) sqlExec(ctx context.Context) (int, error) <span class="cov10" title="3">{
        _spec := sqlgraph.NewDeleteSpec(role.Table, sqlgraph.NewFieldSpec(role.FieldID, field.TypeString))
        if ps := rd.mutation.predicates; len(ps) &gt; 0 </span><span class="cov1" title="1">{
                _spec.Predicate = func(selector *sql.Selector) </span><span class="cov1" title="1">{
                        for i := range ps </span><span class="cov1" title="1">{
                                ps[i](selector)
                        }</span>
                }
        }
        <span class="cov10" title="3">affected, err := sqlgraph.DeleteNodes(ctx, rd.driver, _spec)
        if err != nil &amp;&amp; sqlgraph.IsConstraintError(err) </span><span class="cov0" title="0">{
                err = &amp;ConstraintError{msg: err.Error(), wrap: err}
        }</span>
        <span class="cov10" title="3">rd.mutation.done = true
        return affected, err</span>
}

// RoleDeleteOne is the builder for deleting a single Role entity.
type RoleDeleteOne struct {
        rd *RoleDelete
}

// Where appends a list predicates to the RoleDelete builder.
func (rdo *RoleDeleteOne) Where(ps ...predicate.Role) *RoleDeleteOne <span class="cov0" title="0">{
        rdo.rd.mutation.Where(ps...)
        return rdo
}</span>

// Exec executes the deletion query.
func (rdo *RoleDeleteOne) Exec(ctx context.Context) error <span class="cov1" title="1">{
        n, err := rdo.rd.Exec(ctx)
        switch </span>{
        case err != nil:<span class="cov0" title="0">
                return err</span>
        case n == 0:<span class="cov0" title="0">
                return &amp;NotFoundError{role.Label}</span>
        default:<span class="cov1" title="1">
                return nil</span>
        }
}

// ExecX is like Exec, but panics if an error occurs.
func (rdo *RoleDeleteOne) ExecX(ctx context.Context) <span class="cov0" title="0">{
        if err := rdo.Exec(ctx); err != nil </span><span class="cov0" title="0">{
                panic(err)</span>
        }
}
</pre>
		
		<pre class="file" id="file13" style="display: none">// Code generated by ent, DO NOT EDIT.

package ent

import (
        "auth/ent/predicate"
        "auth/ent/role"
        "auth/ent/user"
        "context"
        "database/sql/driver"
        "fmt"
        "math"

        "entgo.io/ent/dialect/sql"
        "entgo.io/ent/dialect/sql/sqlgraph"
        "entgo.io/ent/schema/field"
)

// RoleQuery is the builder for querying Role entities.
type RoleQuery struct {
        config
        ctx        *QueryContext
        order      []role.OrderOption
        inters     []Interceptor
        predicates []predicate.Role
        withUsers  *UserQuery
        // intermediate query (i.e. traversal path).
        sql  *sql.Selector
        path func(context.Context) (*sql.Selector, error)
}

// Where adds a new predicate for the RoleQuery builder.
func (rq *RoleQuery) Where(ps ...predicate.Role) *RoleQuery <span class="cov9" title="14">{
        rq.predicates = append(rq.predicates, ps...)
        return rq
}</span>

// Limit the number of records to be returned by this query.
func (rq *RoleQuery) Limit(limit int) *RoleQuery <span class="cov7" title="8">{
        rq.ctx.Limit = &amp;limit
        return rq
}</span>

// Offset to start from.
func (rq *RoleQuery) Offset(offset int) *RoleQuery <span class="cov1" title="1">{
        rq.ctx.Offset = &amp;offset
        return rq
}</span>

// Unique configures the query builder to filter duplicate records on query.
// By default, unique is set to true, and can be disabled using this method.
func (rq *RoleQuery) Unique(unique bool) *RoleQuery <span class="cov0" title="0">{
        rq.ctx.Unique = &amp;unique
        return rq
}</span>

// Order specifies how the records should be ordered.
func (rq *RoleQuery) Order(o ...role.OrderOption) *RoleQuery <span class="cov0" title="0">{
        rq.order = append(rq.order, o...)
        return rq
}</span>

// QueryUsers chains the current query on the "users" edge.
func (rq *RoleQuery) QueryUsers() *UserQuery <span class="cov0" title="0">{
        query := (&amp;UserClient{config: rq.config}).Query()
        query.path = func(ctx context.Context) (fromU *sql.Selector, err error) </span><span class="cov0" title="0">{
                if err := rq.prepareQuery(ctx); err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">selector := rq.sqlQuery(ctx)
                if err := selector.Err(); err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">step := sqlgraph.NewStep(
                        sqlgraph.From(role.Table, role.FieldID, selector),
                        sqlgraph.To(user.Table, user.FieldID),
                        sqlgraph.Edge(sqlgraph.M2M, true, role.UsersTable, role.UsersPrimaryKey...),
                )
                fromU = sqlgraph.SetNeighbors(rq.driver.Dialect(), step)
                return fromU, nil</span>
        }
        <span class="cov0" title="0">return query</span>
}

// First returns the first Role entity from the query.
// Returns a *NotFoundError when no Role was found.
func (rq *RoleQuery) First(ctx context.Context) (*Role, error) <span class="cov0" title="0">{
        nodes, err := rq.Limit(1).All(setContextOp(ctx, rq.ctx, "First"))
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">if len(nodes) == 0 </span><span class="cov0" title="0">{
                return nil, &amp;NotFoundError{role.Label}
        }</span>
        <span class="cov0" title="0">return nodes[0], nil</span>
}

// FirstX is like First, but panics if an error occurs.
func (rq *RoleQuery) FirstX(ctx context.Context) *Role <span class="cov0" title="0">{
        node, err := rq.First(ctx)
        if err != nil &amp;&amp; !IsNotFound(err) </span><span class="cov0" title="0">{
                panic(err)</span>
        }
        <span class="cov0" title="0">return node</span>
}

// FirstID returns the first Role ID from the query.
// Returns a *NotFoundError when no Role ID was found.
func (rq *RoleQuery) FirstID(ctx context.Context) (id string, err error) <span class="cov0" title="0">{
        var ids []string
        if ids, err = rq.Limit(1).IDs(setContextOp(ctx, rq.ctx, "FirstID")); err != nil </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov0" title="0">if len(ids) == 0 </span><span class="cov0" title="0">{
                err = &amp;NotFoundError{role.Label}
                return
        }</span>
        <span class="cov0" title="0">return ids[0], nil</span>
}

// FirstIDX is like FirstID, but panics if an error occurs.
func (rq *RoleQuery) FirstIDX(ctx context.Context) string <span class="cov0" title="0">{
        id, err := rq.FirstID(ctx)
        if err != nil &amp;&amp; !IsNotFound(err) </span><span class="cov0" title="0">{
                panic(err)</span>
        }
        <span class="cov0" title="0">return id</span>
}

// Only returns a single Role entity found by the query, ensuring it only returns one.
// Returns a *NotSingularError when more than one Role entity is found.
// Returns a *NotFoundError when no Role entities are found.
func (rq *RoleQuery) Only(ctx context.Context) (*Role, error) <span class="cov7" title="7">{
        nodes, err := rq.Limit(2).All(setContextOp(ctx, rq.ctx, "Only"))
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov7" title="7">switch len(nodes) </span>{
        case 1:<span class="cov6" title="6">
                return nodes[0], nil</span>
        case 0:<span class="cov1" title="1">
                return nil, &amp;NotFoundError{role.Label}</span>
        default:<span class="cov0" title="0">
                return nil, &amp;NotSingularError{role.Label}</span>
        }
}

// OnlyX is like Only, but panics if an error occurs.
func (rq *RoleQuery) OnlyX(ctx context.Context) *Role <span class="cov0" title="0">{
        node, err := rq.Only(ctx)
        if err != nil </span><span class="cov0" title="0">{
                panic(err)</span>
        }
        <span class="cov0" title="0">return node</span>
}

// OnlyID is like Only, but returns the only Role ID in the query.
// Returns a *NotSingularError when more than one Role ID is found.
// Returns a *NotFoundError when no entities are found.
func (rq *RoleQuery) OnlyID(ctx context.Context) (id string, err error) <span class="cov0" title="0">{
        var ids []string
        if ids, err = rq.Limit(2).IDs(setContextOp(ctx, rq.ctx, "OnlyID")); err != nil </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov0" title="0">switch len(ids) </span>{
        case 1:<span class="cov0" title="0">
                id = ids[0]</span>
        case 0:<span class="cov0" title="0">
                err = &amp;NotFoundError{role.Label}</span>
        default:<span class="cov0" title="0">
                err = &amp;NotSingularError{role.Label}</span>
        }
        <span class="cov0" title="0">return</span>
}

// OnlyIDX is like OnlyID, but panics if an error occurs.
func (rq *RoleQuery) OnlyIDX(ctx context.Context) string <span class="cov0" title="0">{
        id, err := rq.OnlyID(ctx)
        if err != nil </span><span class="cov0" title="0">{
                panic(err)</span>
        }
        <span class="cov0" title="0">return id</span>
}

// All executes the query and returns a list of Roles.
func (rq *RoleQuery) All(ctx context.Context) ([]*Role, error) <span class="cov8" title="13">{
        ctx = setContextOp(ctx, rq.ctx, "All")
        if err := rq.prepareQuery(ctx); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="13">qr := querierAll[[]*Role, *RoleQuery]()
        return withInterceptors[[]*Role](ctx, rq, qr, rq.inters)</span>
}

// AllX is like All, but panics if an error occurs.
func (rq *RoleQuery) AllX(ctx context.Context) []*Role <span class="cov0" title="0">{
        nodes, err := rq.All(ctx)
        if err != nil </span><span class="cov0" title="0">{
                panic(err)</span>
        }
        <span class="cov0" title="0">return nodes</span>
}

// IDs executes the query and returns a list of Role IDs.
func (rq *RoleQuery) IDs(ctx context.Context) (ids []string, err error) <span class="cov0" title="0">{
        if rq.ctx.Unique == nil &amp;&amp; rq.path != nil </span><span class="cov0" title="0">{
                rq.Unique(true)
        }</span>
        <span class="cov0" title="0">ctx = setContextOp(ctx, rq.ctx, "IDs")
        if err = rq.Select(role.FieldID).Scan(ctx, &amp;ids); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return ids, nil</span>
}

// IDsX is like IDs, but panics if an error occurs.
func (rq *RoleQuery) IDsX(ctx context.Context) []string <span class="cov0" title="0">{
        ids, err := rq.IDs(ctx)
        if err != nil </span><span class="cov0" title="0">{
                panic(err)</span>
        }
        <span class="cov0" title="0">return ids</span>
}

// Count returns the count of the given query.
func (rq *RoleQuery) Count(ctx context.Context) (int, error) <span class="cov3" title="2">{
        ctx = setContextOp(ctx, rq.ctx, "Count")
        if err := rq.prepareQuery(ctx); err != nil </span><span class="cov0" title="0">{
                return 0, err
        }</span>
        <span class="cov3" title="2">return withInterceptors[int](ctx, rq, querierCount[*RoleQuery](), rq.inters)</span>
}

// CountX is like Count, but panics if an error occurs.
func (rq *RoleQuery) CountX(ctx context.Context) int <span class="cov0" title="0">{
        count, err := rq.Count(ctx)
        if err != nil </span><span class="cov0" title="0">{
                panic(err)</span>
        }
        <span class="cov0" title="0">return count</span>
}

// Exist returns true if the query has elements in the graph.
func (rq *RoleQuery) Exist(ctx context.Context) (bool, error) <span class="cov0" title="0">{
        ctx = setContextOp(ctx, rq.ctx, "Exist")
        switch _, err := rq.FirstID(ctx); </span>{
        case IsNotFound(err):<span class="cov0" title="0">
                return false, nil</span>
        case err != nil:<span class="cov0" title="0">
                return false, fmt.Errorf("ent: check existence: %w", err)</span>
        default:<span class="cov0" title="0">
                return true, nil</span>
        }
}

// ExistX is like Exist, but panics if an error occurs.
func (rq *RoleQuery) ExistX(ctx context.Context) bool <span class="cov0" title="0">{
        exist, err := rq.Exist(ctx)
        if err != nil </span><span class="cov0" title="0">{
                panic(err)</span>
        }
        <span class="cov0" title="0">return exist</span>
}

// Clone returns a duplicate of the RoleQuery builder, including all associated steps. It can be
// used to prepare common query builders and use them differently after the clone is made.
func (rq *RoleQuery) Clone() *RoleQuery <span class="cov0" title="0">{
        if rq == nil </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov0" title="0">return &amp;RoleQuery{
                config:     rq.config,
                ctx:        rq.ctx.Clone(),
                order:      append([]role.OrderOption{}, rq.order...),
                inters:     append([]Interceptor{}, rq.inters...),
                predicates: append([]predicate.Role{}, rq.predicates...),
                withUsers:  rq.withUsers.Clone(),
                // clone intermediate query.
                sql:  rq.sql.Clone(),
                path: rq.path,
        }</span>
}

// WithUsers tells the query-builder to eager-load the nodes that are connected to
// the "users" edge. The optional arguments are used to configure the query builder of the edge.
func (rq *RoleQuery) WithUsers(opts ...func(*UserQuery)) *RoleQuery <span class="cov1" title="1">{
        query := (&amp;UserClient{config: rq.config}).Query()
        for _, opt := range opts </span><span class="cov0" title="0">{
                opt(query)
        }</span>
        <span class="cov1" title="1">rq.withUsers = query
        return rq</span>
}

// GroupBy is used to group vertices by one or more fields/columns.
// It is often used with aggregate functions, like: count, max, mean, min, sum.
//
// Example:
//
//        var v []struct {
//                Name string `json:"name,omitempty"`
//                Count int `json:"count,omitempty"`
//        }
//
//        client.Role.Query().
//                GroupBy(role.FieldName).
//                Aggregate(ent.Count()).
//                Scan(ctx, &amp;v)
func (rq *RoleQuery) GroupBy(field string, fields ...string) *RoleGroupBy <span class="cov0" title="0">{
        rq.ctx.Fields = append([]string{field}, fields...)
        grbuild := &amp;RoleGroupBy{build: rq}
        grbuild.flds = &amp;rq.ctx.Fields
        grbuild.label = role.Label
        grbuild.scan = grbuild.Scan
        return grbuild
}</span>

// Select allows the selection one or more fields/columns for the given query,
// instead of selecting all fields in the entity.
//
// Example:
//
//        var v []struct {
//                Name string `json:"name,omitempty"`
//        }
//
//        client.Role.Query().
//                Select(role.FieldName).
//                Scan(ctx, &amp;v)
func (rq *RoleQuery) Select(fields ...string) *RoleSelect <span class="cov0" title="0">{
        rq.ctx.Fields = append(rq.ctx.Fields, fields...)
        sbuild := &amp;RoleSelect{RoleQuery: rq}
        sbuild.label = role.Label
        sbuild.flds, sbuild.scan = &amp;rq.ctx.Fields, sbuild.Scan
        return sbuild
}</span>

// Aggregate returns a RoleSelect configured with the given aggregations.
func (rq *RoleQuery) Aggregate(fns ...AggregateFunc) *RoleSelect <span class="cov0" title="0">{
        return rq.Select().Aggregate(fns...)
}</span>

func (rq *RoleQuery) prepareQuery(ctx context.Context) error <span class="cov10" title="18">{
        for _, inter := range rq.inters </span><span class="cov0" title="0">{
                if inter == nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("ent: uninitialized interceptor (forgotten import ent/runtime?)")
                }</span>
                <span class="cov0" title="0">if trv, ok := inter.(Traverser); ok </span><span class="cov0" title="0">{
                        if err := trv.Traverse(ctx, rq); err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                }
        }
        <span class="cov10" title="18">for _, f := range rq.ctx.Fields </span><span class="cov0" title="0">{
                if !role.ValidColumn(f) </span><span class="cov0" title="0">{
                        return &amp;ValidationError{Name: f, err: fmt.Errorf("ent: invalid field %q for query", f)}
                }</span>
        }
        <span class="cov10" title="18">if rq.path != nil </span><span class="cov1" title="1">{
                prev, err := rq.path(ctx)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov1" title="1">rq.sql = prev</span>
        }
        <span class="cov10" title="18">return nil</span>
}

func (rq *RoleQuery) sqlAll(ctx context.Context, hooks ...queryHook) ([]*Role, error) <span class="cov9" title="16">{
        var (
                nodes       = []*Role{}
                _spec       = rq.querySpec()
                loadedTypes = [1]bool{
                        rq.withUsers != nil,
                }
        )
        _spec.ScanValues = func(columns []string) ([]any, error) </span><span class="cov9" title="17">{
                return (*Role).scanValues(nil, columns)
        }</span>
        <span class="cov9" title="16">_spec.Assign = func(columns []string, values []any) error </span><span class="cov9" title="17">{
                node := &amp;Role{config: rq.config}
                nodes = append(nodes, node)
                node.Edges.loadedTypes = loadedTypes
                return node.assignValues(columns, values)
        }</span>
        <span class="cov9" title="16">for i := range hooks </span><span class="cov4" title="3">{
                hooks[i](ctx, _spec)
        }</span>
        <span class="cov9" title="16">if err := sqlgraph.QueryNodes(ctx, rq.driver, _spec); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov9" title="16">if len(nodes) == 0 </span><span class="cov4" title="3">{
                return nodes, nil
        }</span>
        <span class="cov8" title="13">if query := rq.withUsers; query != nil </span><span class="cov1" title="1">{
                if err := rq.loadUsers(ctx, query, nodes,
                        func(n *Role) </span><span class="cov1" title="1">{ n.Edges.Users = []*User{} }</span>,
                        func(n *Role, e *User) <span class="cov1" title="1">{ n.Edges.Users = append(n.Edges.Users, e) }</span>); err != nil <span class="cov0" title="0">{
                        return nil, err
                }</span>
        }
        <span class="cov8" title="13">return nodes, nil</span>
}

func (rq *RoleQuery) loadUsers(ctx context.Context, query *UserQuery, nodes []*Role, init func(*Role), assign func(*Role, *User)) error <span class="cov1" title="1">{
        edgeIDs := make([]driver.Value, len(nodes))
        byID := make(map[string]*Role)
        nids := make(map[string]map[*Role]struct{})
        for i, node := range nodes </span><span class="cov1" title="1">{
                edgeIDs[i] = node.ID
                byID[node.ID] = node
                if init != nil </span><span class="cov1" title="1">{
                        init(node)
                }</span>
        }
        <span class="cov1" title="1">query.Where(func(s *sql.Selector) </span><span class="cov1" title="1">{
                joinT := sql.Table(role.UsersTable)
                s.Join(joinT).On(s.C(user.FieldID), joinT.C(role.UsersPrimaryKey[0]))
                s.Where(sql.InValues(joinT.C(role.UsersPrimaryKey[1]), edgeIDs...))
                columns := s.SelectedColumns()
                s.Select(joinT.C(role.UsersPrimaryKey[1]))
                s.AppendSelect(columns...)
                s.SetDistinct(false)
        }</span>)
        <span class="cov1" title="1">if err := query.prepareQuery(ctx); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov1" title="1">qr := QuerierFunc(func(ctx context.Context, q Query) (Value, error) </span><span class="cov1" title="1">{
                return query.sqlAll(ctx, func(_ context.Context, spec *sqlgraph.QuerySpec) </span><span class="cov1" title="1">{
                        assign := spec.Assign
                        values := spec.ScanValues
                        spec.ScanValues = func(columns []string) ([]any, error) </span><span class="cov1" title="1">{
                                values, err := values(columns[1:])
                                if err != nil </span><span class="cov0" title="0">{
                                        return nil, err
                                }</span>
                                <span class="cov1" title="1">return append([]any{new(sql.NullString)}, values...), nil</span>
                        }
                        <span class="cov1" title="1">spec.Assign = func(columns []string, values []any) error </span><span class="cov1" title="1">{
                                outValue := values[0].(*sql.NullString).String
                                inValue := values[1].(*sql.NullString).String
                                if nids[inValue] == nil </span><span class="cov1" title="1">{
                                        nids[inValue] = map[*Role]struct{}{byID[outValue]: {}}
                                        return assign(columns[1:], values[1:])
                                }</span>
                                <span class="cov0" title="0">nids[inValue][byID[outValue]] = struct{}{}
                                return nil</span>
                        }
                })
        })
        <span class="cov1" title="1">neighbors, err := withInterceptors[[]*User](ctx, query, qr, query.inters)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov1" title="1">for _, n := range neighbors </span><span class="cov1" title="1">{
                nodes, ok := nids[n.ID]
                if !ok </span><span class="cov0" title="0">{
                        return fmt.Errorf(`unexpected "users" node returned %v`, n.ID)
                }</span>
                <span class="cov1" title="1">for kn := range nodes </span><span class="cov1" title="1">{
                        assign(kn, n)
                }</span>
        }
        <span class="cov1" title="1">return nil</span>
}

func (rq *RoleQuery) sqlCount(ctx context.Context) (int, error) <span class="cov3" title="2">{
        _spec := rq.querySpec()
        _spec.Node.Columns = rq.ctx.Fields
        if len(rq.ctx.Fields) &gt; 0 </span><span class="cov0" title="0">{
                _spec.Unique = rq.ctx.Unique != nil &amp;&amp; *rq.ctx.Unique
        }</span>
        <span class="cov3" title="2">return sqlgraph.CountNodes(ctx, rq.driver, _spec)</span>
}

func (rq *RoleQuery) querySpec() *sqlgraph.QuerySpec <span class="cov10" title="18">{
        _spec := sqlgraph.NewQuerySpec(role.Table, role.Columns, sqlgraph.NewFieldSpec(role.FieldID, field.TypeString))
        _spec.From = rq.sql
        if unique := rq.ctx.Unique; unique != nil </span><span class="cov0" title="0">{
                _spec.Unique = *unique
        }</span> else<span class="cov10" title="18"> if rq.path != nil </span><span class="cov1" title="1">{
                _spec.Unique = true
        }</span>
        <span class="cov10" title="18">if fields := rq.ctx.Fields; len(fields) &gt; 0 </span><span class="cov0" title="0">{
                _spec.Node.Columns = make([]string, 0, len(fields))
                _spec.Node.Columns = append(_spec.Node.Columns, role.FieldID)
                for i := range fields </span><span class="cov0" title="0">{
                        if fields[i] != role.FieldID </span><span class="cov0" title="0">{
                                _spec.Node.Columns = append(_spec.Node.Columns, fields[i])
                        }</span>
                }
        }
        <span class="cov10" title="18">if ps := rq.predicates; len(ps) &gt; 0 </span><span class="cov9" title="14">{
                _spec.Predicate = func(selector *sql.Selector) </span><span class="cov9" title="14">{
                        for i := range ps </span><span class="cov9" title="14">{
                                ps[i](selector)
                        }</span>
                }
        }
        <span class="cov10" title="18">if limit := rq.ctx.Limit; limit != nil </span><span class="cov7" title="8">{
                _spec.Limit = *limit
        }</span>
        <span class="cov10" title="18">if offset := rq.ctx.Offset; offset != nil </span><span class="cov1" title="1">{
                _spec.Offset = *offset
        }</span>
        <span class="cov10" title="18">if ps := rq.order; len(ps) &gt; 0 </span><span class="cov0" title="0">{
                _spec.Order = func(selector *sql.Selector) </span><span class="cov0" title="0">{
                        for i := range ps </span><span class="cov0" title="0">{
                                ps[i](selector)
                        }</span>
                }
        }
        <span class="cov10" title="18">return _spec</span>
}

func (rq *RoleQuery) sqlQuery(ctx context.Context) *sql.Selector <span class="cov0" title="0">{
        builder := sql.Dialect(rq.driver.Dialect())
        t1 := builder.Table(role.Table)
        columns := rq.ctx.Fields
        if len(columns) == 0 </span><span class="cov0" title="0">{
                columns = role.Columns
        }</span>
        <span class="cov0" title="0">selector := builder.Select(t1.Columns(columns...)...).From(t1)
        if rq.sql != nil </span><span class="cov0" title="0">{
                selector = rq.sql
                selector.Select(selector.Columns(columns...)...)
        }</span>
        <span class="cov0" title="0">if rq.ctx.Unique != nil &amp;&amp; *rq.ctx.Unique </span><span class="cov0" title="0">{
                selector.Distinct()
        }</span>
        <span class="cov0" title="0">for _, p := range rq.predicates </span><span class="cov0" title="0">{
                p(selector)
        }</span>
        <span class="cov0" title="0">for _, p := range rq.order </span><span class="cov0" title="0">{
                p(selector)
        }</span>
        <span class="cov0" title="0">if offset := rq.ctx.Offset; offset != nil </span><span class="cov0" title="0">{
                // limit is mandatory for offset clause. We start
                // with default value, and override it below if needed.
                selector.Offset(*offset).Limit(math.MaxInt32)
        }</span>
        <span class="cov0" title="0">if limit := rq.ctx.Limit; limit != nil </span><span class="cov0" title="0">{
                selector.Limit(*limit)
        }</span>
        <span class="cov0" title="0">return selector</span>
}

// RoleGroupBy is the group-by builder for Role entities.
type RoleGroupBy struct {
        selector
        build *RoleQuery
}

// Aggregate adds the given aggregation functions to the group-by query.
func (rgb *RoleGroupBy) Aggregate(fns ...AggregateFunc) *RoleGroupBy <span class="cov0" title="0">{
        rgb.fns = append(rgb.fns, fns...)
        return rgb
}</span>

// Scan applies the selector query and scans the result into the given value.
func (rgb *RoleGroupBy) Scan(ctx context.Context, v any) error <span class="cov0" title="0">{
        ctx = setContextOp(ctx, rgb.build.ctx, "GroupBy")
        if err := rgb.build.prepareQuery(ctx); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">return scanWithInterceptors[*RoleQuery, *RoleGroupBy](ctx, rgb.build, rgb, rgb.build.inters, v)</span>
}

func (rgb *RoleGroupBy) sqlScan(ctx context.Context, root *RoleQuery, v any) error <span class="cov0" title="0">{
        selector := root.sqlQuery(ctx).Select()
        aggregation := make([]string, 0, len(rgb.fns))
        for _, fn := range rgb.fns </span><span class="cov0" title="0">{
                aggregation = append(aggregation, fn(selector))
        }</span>
        <span class="cov0" title="0">if len(selector.SelectedColumns()) == 0 </span><span class="cov0" title="0">{
                columns := make([]string, 0, len(*rgb.flds)+len(rgb.fns))
                for _, f := range *rgb.flds </span><span class="cov0" title="0">{
                        columns = append(columns, selector.C(f))
                }</span>
                <span class="cov0" title="0">columns = append(columns, aggregation...)
                selector.Select(columns...)</span>
        }
        <span class="cov0" title="0">selector.GroupBy(selector.Columns(*rgb.flds...)...)
        if err := selector.Err(); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">rows := &amp;sql.Rows{}
        query, args := selector.Query()
        if err := rgb.build.driver.Query(ctx, query, args, rows); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">defer rows.Close()
        return sql.ScanSlice(rows, v)</span>
}

// RoleSelect is the builder for selecting fields of Role entities.
type RoleSelect struct {
        *RoleQuery
        selector
}

// Aggregate adds the given aggregation functions to the selector query.
func (rs *RoleSelect) Aggregate(fns ...AggregateFunc) *RoleSelect <span class="cov0" title="0">{
        rs.fns = append(rs.fns, fns...)
        return rs
}</span>

// Scan applies the selector query and scans the result into the given value.
func (rs *RoleSelect) Scan(ctx context.Context, v any) error <span class="cov0" title="0">{
        ctx = setContextOp(ctx, rs.ctx, "Select")
        if err := rs.prepareQuery(ctx); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">return scanWithInterceptors[*RoleQuery, *RoleSelect](ctx, rs.RoleQuery, rs, rs.inters, v)</span>
}

func (rs *RoleSelect) sqlScan(ctx context.Context, root *RoleQuery, v any) error <span class="cov0" title="0">{
        selector := root.sqlQuery(ctx)
        aggregation := make([]string, 0, len(rs.fns))
        for _, fn := range rs.fns </span><span class="cov0" title="0">{
                aggregation = append(aggregation, fn(selector))
        }</span>
        <span class="cov0" title="0">switch n := len(*rs.selector.flds); </span>{
        case n == 0 &amp;&amp; len(aggregation) &gt; 0:<span class="cov0" title="0">
                selector.Select(aggregation...)</span>
        case n != 0 &amp;&amp; len(aggregation) &gt; 0:<span class="cov0" title="0">
                selector.AppendSelect(aggregation...)</span>
        }
        <span class="cov0" title="0">rows := &amp;sql.Rows{}
        query, args := selector.Query()
        if err := rs.driver.Query(ctx, query, args, rows); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">defer rows.Close()
        return sql.ScanSlice(rows, v)</span>
}
</pre>
		
		<pre class="file" id="file14" style="display: none">// Code generated by ent, DO NOT EDIT.

package ent

import (
        "auth/ent/predicate"
        "auth/ent/role"
        "auth/ent/user"
        "context"
        "errors"
        "fmt"
        "time"

        "entgo.io/ent/dialect/sql"
        "entgo.io/ent/dialect/sql/sqlgraph"
        "entgo.io/ent/dialect/sql/sqljson"
        "entgo.io/ent/schema/field"
)

// RoleUpdate is the builder for updating Role entities.
type RoleUpdate struct {
        config
        hooks    []Hook
        mutation *RoleMutation
}

// Where appends a list predicates to the RoleUpdate builder.
func (ru *RoleUpdate) Where(ps ...predicate.Role) *RoleUpdate <span class="cov0" title="0">{
        ru.mutation.Where(ps...)
        return ru
}</span>

// SetName sets the "name" field.
func (ru *RoleUpdate) SetName(s string) *RoleUpdate <span class="cov0" title="0">{
        ru.mutation.SetName(s)
        return ru
}</span>

// SetNillableName sets the "name" field if the given value is not nil.
func (ru *RoleUpdate) SetNillableName(s *string) *RoleUpdate <span class="cov0" title="0">{
        if s != nil </span><span class="cov0" title="0">{
                ru.SetName(*s)
        }</span>
        <span class="cov0" title="0">return ru</span>
}

// SetPermissions sets the "permissions" field.
func (ru *RoleUpdate) SetPermissions(s []string) *RoleUpdate <span class="cov0" title="0">{
        ru.mutation.SetPermissions(s)
        return ru
}</span>

// AppendPermissions appends s to the "permissions" field.
func (ru *RoleUpdate) AppendPermissions(s []string) *RoleUpdate <span class="cov0" title="0">{
        ru.mutation.AppendPermissions(s)
        return ru
}</span>

// SetCreatedAt sets the "created_at" field.
func (ru *RoleUpdate) SetCreatedAt(t time.Time) *RoleUpdate <span class="cov0" title="0">{
        ru.mutation.SetCreatedAt(t)
        return ru
}</span>

// SetNillableCreatedAt sets the "created_at" field if the given value is not nil.
func (ru *RoleUpdate) SetNillableCreatedAt(t *time.Time) *RoleUpdate <span class="cov0" title="0">{
        if t != nil </span><span class="cov0" title="0">{
                ru.SetCreatedAt(*t)
        }</span>
        <span class="cov0" title="0">return ru</span>
}

// SetUpdatedAt sets the "updated_at" field.
func (ru *RoleUpdate) SetUpdatedAt(t time.Time) *RoleUpdate <span class="cov0" title="0">{
        ru.mutation.SetUpdatedAt(t)
        return ru
}</span>

// AddUserIDs adds the "users" edge to the User entity by IDs.
func (ru *RoleUpdate) AddUserIDs(ids ...string) *RoleUpdate <span class="cov0" title="0">{
        ru.mutation.AddUserIDs(ids...)
        return ru
}</span>

// AddUsers adds the "users" edges to the User entity.
func (ru *RoleUpdate) AddUsers(u ...*User) *RoleUpdate <span class="cov0" title="0">{
        ids := make([]string, len(u))
        for i := range u </span><span class="cov0" title="0">{
                ids[i] = u[i].ID
        }</span>
        <span class="cov0" title="0">return ru.AddUserIDs(ids...)</span>
}

// Mutation returns the RoleMutation object of the builder.
func (ru *RoleUpdate) Mutation() *RoleMutation <span class="cov0" title="0">{
        return ru.mutation
}</span>

// ClearUsers clears all "users" edges to the User entity.
func (ru *RoleUpdate) ClearUsers() *RoleUpdate <span class="cov0" title="0">{
        ru.mutation.ClearUsers()
        return ru
}</span>

// RemoveUserIDs removes the "users" edge to User entities by IDs.
func (ru *RoleUpdate) RemoveUserIDs(ids ...string) *RoleUpdate <span class="cov0" title="0">{
        ru.mutation.RemoveUserIDs(ids...)
        return ru
}</span>

// RemoveUsers removes "users" edges to User entities.
func (ru *RoleUpdate) RemoveUsers(u ...*User) *RoleUpdate <span class="cov0" title="0">{
        ids := make([]string, len(u))
        for i := range u </span><span class="cov0" title="0">{
                ids[i] = u[i].ID
        }</span>
        <span class="cov0" title="0">return ru.RemoveUserIDs(ids...)</span>
}

// Save executes the query and returns the number of nodes affected by the update operation.
func (ru *RoleUpdate) Save(ctx context.Context) (int, error) <span class="cov0" title="0">{
        ru.defaults()
        return withHooks(ctx, ru.sqlSave, ru.mutation, ru.hooks)
}</span>

// SaveX is like Save, but panics if an error occurs.
func (ru *RoleUpdate) SaveX(ctx context.Context) int <span class="cov0" title="0">{
        affected, err := ru.Save(ctx)
        if err != nil </span><span class="cov0" title="0">{
                panic(err)</span>
        }
        <span class="cov0" title="0">return affected</span>
}

// Exec executes the query.
func (ru *RoleUpdate) Exec(ctx context.Context) error <span class="cov0" title="0">{
        _, err := ru.Save(ctx)
        return err
}</span>

// ExecX is like Exec, but panics if an error occurs.
func (ru *RoleUpdate) ExecX(ctx context.Context) <span class="cov0" title="0">{
        if err := ru.Exec(ctx); err != nil </span><span class="cov0" title="0">{
                panic(err)</span>
        }
}

// defaults sets the default values of the builder before save.
func (ru *RoleUpdate) defaults() <span class="cov0" title="0">{
        if _, ok := ru.mutation.UpdatedAt(); !ok </span><span class="cov0" title="0">{
                v := role.UpdateDefaultUpdatedAt()
                ru.mutation.SetUpdatedAt(v)
        }</span>
}

func (ru *RoleUpdate) sqlSave(ctx context.Context) (n int, err error) <span class="cov0" title="0">{
        _spec := sqlgraph.NewUpdateSpec(role.Table, role.Columns, sqlgraph.NewFieldSpec(role.FieldID, field.TypeString))
        if ps := ru.mutation.predicates; len(ps) &gt; 0 </span><span class="cov0" title="0">{
                _spec.Predicate = func(selector *sql.Selector) </span><span class="cov0" title="0">{
                        for i := range ps </span><span class="cov0" title="0">{
                                ps[i](selector)
                        }</span>
                }
        }
        <span class="cov0" title="0">if value, ok := ru.mutation.Name(); ok </span><span class="cov0" title="0">{
                _spec.SetField(role.FieldName, field.TypeString, value)
        }</span>
        <span class="cov0" title="0">if value, ok := ru.mutation.Permissions(); ok </span><span class="cov0" title="0">{
                _spec.SetField(role.FieldPermissions, field.TypeJSON, value)
        }</span>
        <span class="cov0" title="0">if value, ok := ru.mutation.AppendedPermissions(); ok </span><span class="cov0" title="0">{
                _spec.AddModifier(func(u *sql.UpdateBuilder) </span><span class="cov0" title="0">{
                        sqljson.Append(u, role.FieldPermissions, value)
                }</span>)
        }
        <span class="cov0" title="0">if value, ok := ru.mutation.CreatedAt(); ok </span><span class="cov0" title="0">{
                _spec.SetField(role.FieldCreatedAt, field.TypeTime, value)
        }</span>
        <span class="cov0" title="0">if value, ok := ru.mutation.UpdatedAt(); ok </span><span class="cov0" title="0">{
                _spec.SetField(role.FieldUpdatedAt, field.TypeTime, value)
        }</span>
        <span class="cov0" title="0">if ru.mutation.UsersCleared() </span><span class="cov0" title="0">{
                edge := &amp;sqlgraph.EdgeSpec{
                        Rel:     sqlgraph.M2M,
                        Inverse: true,
                        Table:   role.UsersTable,
                        Columns: role.UsersPrimaryKey,
                        Bidi:    false,
                        Target: &amp;sqlgraph.EdgeTarget{
                                IDSpec: sqlgraph.NewFieldSpec(user.FieldID, field.TypeString),
                        },
                }
                _spec.Edges.Clear = append(_spec.Edges.Clear, edge)
        }</span>
        <span class="cov0" title="0">if nodes := ru.mutation.RemovedUsersIDs(); len(nodes) &gt; 0 &amp;&amp; !ru.mutation.UsersCleared() </span><span class="cov0" title="0">{
                edge := &amp;sqlgraph.EdgeSpec{
                        Rel:     sqlgraph.M2M,
                        Inverse: true,
                        Table:   role.UsersTable,
                        Columns: role.UsersPrimaryKey,
                        Bidi:    false,
                        Target: &amp;sqlgraph.EdgeTarget{
                                IDSpec: sqlgraph.NewFieldSpec(user.FieldID, field.TypeString),
                        },
                }
                for _, k := range nodes </span><span class="cov0" title="0">{
                        edge.Target.Nodes = append(edge.Target.Nodes, k)
                }</span>
                <span class="cov0" title="0">_spec.Edges.Clear = append(_spec.Edges.Clear, edge)</span>
        }
        <span class="cov0" title="0">if nodes := ru.mutation.UsersIDs(); len(nodes) &gt; 0 </span><span class="cov0" title="0">{
                edge := &amp;sqlgraph.EdgeSpec{
                        Rel:     sqlgraph.M2M,
                        Inverse: true,
                        Table:   role.UsersTable,
                        Columns: role.UsersPrimaryKey,
                        Bidi:    false,
                        Target: &amp;sqlgraph.EdgeTarget{
                                IDSpec: sqlgraph.NewFieldSpec(user.FieldID, field.TypeString),
                        },
                }
                for _, k := range nodes </span><span class="cov0" title="0">{
                        edge.Target.Nodes = append(edge.Target.Nodes, k)
                }</span>
                <span class="cov0" title="0">_spec.Edges.Add = append(_spec.Edges.Add, edge)</span>
        }
        <span class="cov0" title="0">if n, err = sqlgraph.UpdateNodes(ctx, ru.driver, _spec); err != nil </span><span class="cov0" title="0">{
                if _, ok := err.(*sqlgraph.NotFoundError); ok </span><span class="cov0" title="0">{
                        err = &amp;NotFoundError{role.Label}
                }</span> else<span class="cov0" title="0"> if sqlgraph.IsConstraintError(err) </span><span class="cov0" title="0">{
                        err = &amp;ConstraintError{msg: err.Error(), wrap: err}
                }</span>
                <span class="cov0" title="0">return 0, err</span>
        }
        <span class="cov0" title="0">ru.mutation.done = true
        return n, nil</span>
}

// RoleUpdateOne is the builder for updating a single Role entity.
type RoleUpdateOne struct {
        config
        fields   []string
        hooks    []Hook
        mutation *RoleMutation
}

// SetName sets the "name" field.
func (ruo *RoleUpdateOne) SetName(s string) *RoleUpdateOne <span class="cov1" title="1">{
        ruo.mutation.SetName(s)
        return ruo
}</span>

// SetNillableName sets the "name" field if the given value is not nil.
func (ruo *RoleUpdateOne) SetNillableName(s *string) *RoleUpdateOne <span class="cov0" title="0">{
        if s != nil </span><span class="cov0" title="0">{
                ruo.SetName(*s)
        }</span>
        <span class="cov0" title="0">return ruo</span>
}

// SetPermissions sets the "permissions" field.
func (ruo *RoleUpdateOne) SetPermissions(s []string) *RoleUpdateOne <span class="cov5" title="2">{
        ruo.mutation.SetPermissions(s)
        return ruo
}</span>

// AppendPermissions appends s to the "permissions" field.
func (ruo *RoleUpdateOne) AppendPermissions(s []string) *RoleUpdateOne <span class="cov1" title="1">{
        ruo.mutation.AppendPermissions(s)
        return ruo
}</span>

// SetCreatedAt sets the "created_at" field.
func (ruo *RoleUpdateOne) SetCreatedAt(t time.Time) *RoleUpdateOne <span class="cov0" title="0">{
        ruo.mutation.SetCreatedAt(t)
        return ruo
}</span>

// SetNillableCreatedAt sets the "created_at" field if the given value is not nil.
func (ruo *RoleUpdateOne) SetNillableCreatedAt(t *time.Time) *RoleUpdateOne <span class="cov0" title="0">{
        if t != nil </span><span class="cov0" title="0">{
                ruo.SetCreatedAt(*t)
        }</span>
        <span class="cov0" title="0">return ruo</span>
}

// SetUpdatedAt sets the "updated_at" field.
func (ruo *RoleUpdateOne) SetUpdatedAt(t time.Time) *RoleUpdateOne <span class="cov1" title="1">{
        ruo.mutation.SetUpdatedAt(t)
        return ruo
}</span>

// AddUserIDs adds the "users" edge to the User entity by IDs.
func (ruo *RoleUpdateOne) AddUserIDs(ids ...string) *RoleUpdateOne <span class="cov1" title="1">{
        ruo.mutation.AddUserIDs(ids...)
        return ruo
}</span>

// AddUsers adds the "users" edges to the User entity.
func (ruo *RoleUpdateOne) AddUsers(u ...*User) *RoleUpdateOne <span class="cov0" title="0">{
        ids := make([]string, len(u))
        for i := range u </span><span class="cov0" title="0">{
                ids[i] = u[i].ID
        }</span>
        <span class="cov0" title="0">return ruo.AddUserIDs(ids...)</span>
}

// Mutation returns the RoleMutation object of the builder.
func (ruo *RoleUpdateOne) Mutation() *RoleMutation <span class="cov0" title="0">{
        return ruo.mutation
}</span>

// ClearUsers clears all "users" edges to the User entity.
func (ruo *RoleUpdateOne) ClearUsers() *RoleUpdateOne <span class="cov0" title="0">{
        ruo.mutation.ClearUsers()
        return ruo
}</span>

// RemoveUserIDs removes the "users" edge to User entities by IDs.
func (ruo *RoleUpdateOne) RemoveUserIDs(ids ...string) *RoleUpdateOne <span class="cov0" title="0">{
        ruo.mutation.RemoveUserIDs(ids...)
        return ruo
}</span>

// RemoveUsers removes "users" edges to User entities.
func (ruo *RoleUpdateOne) RemoveUsers(u ...*User) *RoleUpdateOne <span class="cov0" title="0">{
        ids := make([]string, len(u))
        for i := range u </span><span class="cov0" title="0">{
                ids[i] = u[i].ID
        }</span>
        <span class="cov0" title="0">return ruo.RemoveUserIDs(ids...)</span>
}

// Where appends a list predicates to the RoleUpdate builder.
func (ruo *RoleUpdateOne) Where(ps ...predicate.Role) *RoleUpdateOne <span class="cov0" title="0">{
        ruo.mutation.Where(ps...)
        return ruo
}</span>

// Select allows selecting one or more fields (columns) of the returned entity.
// The default is selecting all fields defined in the entity schema.
func (ruo *RoleUpdateOne) Select(field string, fields ...string) *RoleUpdateOne <span class="cov0" title="0">{
        ruo.fields = append([]string{field}, fields...)
        return ruo
}</span>

// Save executes the query and returns the updated Role entity.
func (ruo *RoleUpdateOne) Save(ctx context.Context) (*Role, error) <span class="cov10" title="4">{
        ruo.defaults()
        return withHooks(ctx, ruo.sqlSave, ruo.mutation, ruo.hooks)
}</span>

// SaveX is like Save, but panics if an error occurs.
func (ruo *RoleUpdateOne) SaveX(ctx context.Context) *Role <span class="cov0" title="0">{
        node, err := ruo.Save(ctx)
        if err != nil </span><span class="cov0" title="0">{
                panic(err)</span>
        }
        <span class="cov0" title="0">return node</span>
}

// Exec executes the query on the entity.
func (ruo *RoleUpdateOne) Exec(ctx context.Context) error <span class="cov8" title="3">{
        _, err := ruo.Save(ctx)
        return err
}</span>

// ExecX is like Exec, but panics if an error occurs.
func (ruo *RoleUpdateOne) ExecX(ctx context.Context) <span class="cov0" title="0">{
        if err := ruo.Exec(ctx); err != nil </span><span class="cov0" title="0">{
                panic(err)</span>
        }
}

// defaults sets the default values of the builder before save.
func (ruo *RoleUpdateOne) defaults() <span class="cov10" title="4">{
        if _, ok := ruo.mutation.UpdatedAt(); !ok </span><span class="cov8" title="3">{
                v := role.UpdateDefaultUpdatedAt()
                ruo.mutation.SetUpdatedAt(v)
        }</span>
}

func (ruo *RoleUpdateOne) sqlSave(ctx context.Context) (_node *Role, err error) <span class="cov10" title="4">{
        _spec := sqlgraph.NewUpdateSpec(role.Table, role.Columns, sqlgraph.NewFieldSpec(role.FieldID, field.TypeString))
        id, ok := ruo.mutation.ID()
        if !ok </span><span class="cov0" title="0">{
                return nil, &amp;ValidationError{Name: "id", err: errors.New(`ent: missing "Role.id" for update`)}
        }</span>
        <span class="cov10" title="4">_spec.Node.ID.Value = id
        if fields := ruo.fields; len(fields) &gt; 0 </span><span class="cov0" title="0">{
                _spec.Node.Columns = make([]string, 0, len(fields))
                _spec.Node.Columns = append(_spec.Node.Columns, role.FieldID)
                for _, f := range fields </span><span class="cov0" title="0">{
                        if !role.ValidColumn(f) </span><span class="cov0" title="0">{
                                return nil, &amp;ValidationError{Name: f, err: fmt.Errorf("ent: invalid field %q for query", f)}
                        }</span>
                        <span class="cov0" title="0">if f != role.FieldID </span><span class="cov0" title="0">{
                                _spec.Node.Columns = append(_spec.Node.Columns, f)
                        }</span>
                }
        }
        <span class="cov10" title="4">if ps := ruo.mutation.predicates; len(ps) &gt; 0 </span><span class="cov0" title="0">{
                _spec.Predicate = func(selector *sql.Selector) </span><span class="cov0" title="0">{
                        for i := range ps </span><span class="cov0" title="0">{
                                ps[i](selector)
                        }</span>
                }
        }
        <span class="cov10" title="4">if value, ok := ruo.mutation.Name(); ok </span><span class="cov1" title="1">{
                _spec.SetField(role.FieldName, field.TypeString, value)
        }</span>
        <span class="cov10" title="4">if value, ok := ruo.mutation.Permissions(); ok </span><span class="cov5" title="2">{
                _spec.SetField(role.FieldPermissions, field.TypeJSON, value)
        }</span>
        <span class="cov10" title="4">if value, ok := ruo.mutation.AppendedPermissions(); ok </span><span class="cov1" title="1">{
                _spec.AddModifier(func(u *sql.UpdateBuilder) </span><span class="cov1" title="1">{
                        sqljson.Append(u, role.FieldPermissions, value)
                }</span>)
        }
        <span class="cov10" title="4">if value, ok := ruo.mutation.CreatedAt(); ok </span><span class="cov0" title="0">{
                _spec.SetField(role.FieldCreatedAt, field.TypeTime, value)
        }</span>
        <span class="cov10" title="4">if value, ok := ruo.mutation.UpdatedAt(); ok </span><span class="cov10" title="4">{
                _spec.SetField(role.FieldUpdatedAt, field.TypeTime, value)
        }</span>
        <span class="cov10" title="4">if ruo.mutation.UsersCleared() </span><span class="cov0" title="0">{
                edge := &amp;sqlgraph.EdgeSpec{
                        Rel:     sqlgraph.M2M,
                        Inverse: true,
                        Table:   role.UsersTable,
                        Columns: role.UsersPrimaryKey,
                        Bidi:    false,
                        Target: &amp;sqlgraph.EdgeTarget{
                                IDSpec: sqlgraph.NewFieldSpec(user.FieldID, field.TypeString),
                        },
                }
                _spec.Edges.Clear = append(_spec.Edges.Clear, edge)
        }</span>
        <span class="cov10" title="4">if nodes := ruo.mutation.RemovedUsersIDs(); len(nodes) &gt; 0 &amp;&amp; !ruo.mutation.UsersCleared() </span><span class="cov0" title="0">{
                edge := &amp;sqlgraph.EdgeSpec{
                        Rel:     sqlgraph.M2M,
                        Inverse: true,
                        Table:   role.UsersTable,
                        Columns: role.UsersPrimaryKey,
                        Bidi:    false,
                        Target: &amp;sqlgraph.EdgeTarget{
                                IDSpec: sqlgraph.NewFieldSpec(user.FieldID, field.TypeString),
                        },
                }
                for _, k := range nodes </span><span class="cov0" title="0">{
                        edge.Target.Nodes = append(edge.Target.Nodes, k)
                }</span>
                <span class="cov0" title="0">_spec.Edges.Clear = append(_spec.Edges.Clear, edge)</span>
        }
        <span class="cov10" title="4">if nodes := ruo.mutation.UsersIDs(); len(nodes) &gt; 0 </span><span class="cov1" title="1">{
                edge := &amp;sqlgraph.EdgeSpec{
                        Rel:     sqlgraph.M2M,
                        Inverse: true,
                        Table:   role.UsersTable,
                        Columns: role.UsersPrimaryKey,
                        Bidi:    false,
                        Target: &amp;sqlgraph.EdgeTarget{
                                IDSpec: sqlgraph.NewFieldSpec(user.FieldID, field.TypeString),
                        },
                }
                for _, k := range nodes </span><span class="cov1" title="1">{
                        edge.Target.Nodes = append(edge.Target.Nodes, k)
                }</span>
                <span class="cov1" title="1">_spec.Edges.Add = append(_spec.Edges.Add, edge)</span>
        }
        <span class="cov10" title="4">_node = &amp;Role{config: ruo.config}
        _spec.Assign = _node.assignValues
        _spec.ScanValues = _node.scanValues
        if err = sqlgraph.UpdateNode(ctx, ruo.driver, _spec); err != nil </span><span class="cov0" title="0">{
                if _, ok := err.(*sqlgraph.NotFoundError); ok </span><span class="cov0" title="0">{
                        err = &amp;NotFoundError{role.Label}
                }</span> else<span class="cov0" title="0"> if sqlgraph.IsConstraintError(err) </span><span class="cov0" title="0">{
                        err = &amp;ConstraintError{msg: err.Error(), wrap: err}
                }</span>
                <span class="cov0" title="0">return nil, err</span>
        }
        <span class="cov10" title="4">ruo.mutation.done = true
        return _node, nil</span>
}
</pre>
		
		<pre class="file" id="file15" style="display: none">// Code generated by ent, DO NOT EDIT.

package runtime

import (
        "auth/ent/role"
        "auth/ent/schema"
        "auth/ent/token"
        "auth/ent/user"
        "time"
)

// The init function reads all schema descriptors with runtime code
// (default values, validators, hooks and policies) and stitches it
// to their package variables.
func init() <span class="cov8" title="1">{
        roleFields := schema.Role{}.Fields()
        _ = roleFields
        // roleDescCreatedAt is the schema descriptor for created_at field.
        roleDescCreatedAt := roleFields[3].Descriptor()
        // role.DefaultCreatedAt holds the default value on creation for the created_at field.
        role.DefaultCreatedAt = roleDescCreatedAt.Default.(func() time.Time)
        // roleDescUpdatedAt is the schema descriptor for updated_at field.
        roleDescUpdatedAt := roleFields[4].Descriptor()
        // role.DefaultUpdatedAt holds the default value on creation for the updated_at field.
        role.DefaultUpdatedAt = roleDescUpdatedAt.Default.(func() time.Time)
        // role.UpdateDefaultUpdatedAt holds the default value on update for the updated_at field.
        role.UpdateDefaultUpdatedAt = roleDescUpdatedAt.UpdateDefault.(func() time.Time)
        // roleDescID is the schema descriptor for id field.
        roleDescID := roleFields[0].Descriptor()
        // role.DefaultID holds the default value on creation for the id field.
        role.DefaultID = roleDescID.Default.(func() string)
        tokenFields := schema.Token{}.Fields()
        _ = tokenFields
        // tokenDescRevoked is the schema descriptor for revoked field.
        tokenDescRevoked := tokenFields[4].Descriptor()
        // token.DefaultRevoked holds the default value on creation for the revoked field.
        token.DefaultRevoked = tokenDescRevoked.Default.(bool)
        // tokenDescCreatedAt is the schema descriptor for created_at field.
        tokenDescCreatedAt := tokenFields[5].Descriptor()
        // token.DefaultCreatedAt holds the default value on creation for the created_at field.
        token.DefaultCreatedAt = tokenDescCreatedAt.Default.(func() time.Time)
        // tokenDescUpdatedAt is the schema descriptor for updated_at field.
        tokenDescUpdatedAt := tokenFields[6].Descriptor()
        // token.DefaultUpdatedAt holds the default value on creation for the updated_at field.
        token.DefaultUpdatedAt = tokenDescUpdatedAt.Default.(func() time.Time)
        // token.UpdateDefaultUpdatedAt holds the default value on update for the updated_at field.
        token.UpdateDefaultUpdatedAt = tokenDescUpdatedAt.UpdateDefault.(func() time.Time)
        // tokenDescID is the schema descriptor for id field.
        tokenDescID := tokenFields[0].Descriptor()
        // token.DefaultID holds the default value on creation for the id field.
        token.DefaultID = tokenDescID.Default.(func() string)
        userHooks := schema.User{}.Hooks()
        user.Hooks[0] = userHooks[0]
        userFields := schema.User{}.Fields()
        _ = userFields
        // userDescCreatedAt is the schema descriptor for created_at field.
        userDescCreatedAt := userFields[4].Descriptor()
        // user.DefaultCreatedAt holds the default value on creation for the created_at field.
        user.DefaultCreatedAt = userDescCreatedAt.Default.(func() time.Time)
        // userDescUpdatedAt is the schema descriptor for updated_at field.
        userDescUpdatedAt := userFields[5].Descriptor()
        // user.DefaultUpdatedAt holds the default value on creation for the updated_at field.
        user.DefaultUpdatedAt = userDescUpdatedAt.Default.(func() time.Time)
        // user.UpdateDefaultUpdatedAt holds the default value on update for the updated_at field.
        user.UpdateDefaultUpdatedAt = userDescUpdatedAt.UpdateDefault.(func() time.Time)
        // userDescID is the schema descriptor for id field.
        userDescID := userFields[0].Descriptor()
        // user.DefaultID holds the default value on creation for the id field.
        user.DefaultID = userDescID.Default.(func() string)
}</span>

const (
        Version = "v0.13.1"                                         // Version of ent codegen.
        Sum     = "h1:uD8QwN1h6SNphdCCzmkMN3feSUzNnVvV/WIkHKMbzOE=" // Sum of ent codegen.
)
</pre>
		
		<pre class="file" id="file16" style="display: none">package schema

import (
        "time"

        "entgo.io/ent"
        "entgo.io/ent/schema/edge"
        "entgo.io/ent/schema/field"
        "github.com/google/uuid"
)

// Role holds the schema definition for the Role entity.
type Role struct {
        ent.Schema
}

// Fields of the Role.
func (Role) Fields() []ent.Field <span class="cov1" title="1">{
        return []ent.Field{
                field.String("id").
                        DefaultFunc(func() string </span><span class="cov10" title="34">{
                                return uuid.New().String()
                        }</span>),
                field.String("name").Unique(),
                field.Strings("permissions"),
                field.Time("created_at").
                        Default(time.Now),
                field.Time("updated_at").
                        Default(time.Now).
                        UpdateDefault(time.Now),
        }
}

// Edges of the Role.
func (Role) Edges() []ent.Edge <span class="cov0" title="0">{
        return []ent.Edge{
                edge.From("users", User.Type).
                        Ref("roles"),
        }
}</span>
</pre>
		
		<pre class="file" id="file17" style="display: none">package schema

import (
        "time"

        "entgo.io/ent"
        "entgo.io/ent/schema/edge"
        "entgo.io/ent/schema/field"
        "github.com/google/uuid"
)

// Token holds the schema definition for the Token entity.
type Token struct {
        ent.Schema
}

// Fields of the Token.
func (Token) Fields() []ent.Field <span class="cov1" title="1">{
        return []ent.Field{
                field.String("id").
                        DefaultFunc(func() string </span><span class="cov10" title="13">{
                                return uuid.New().String()
                        }</span>),
                field.String("token").Unique(),
                field.Enum("type").
                        Values("access", "refresh"),
                field.Time("expires_at"),
                field.Bool("revoked").
                        Default(false),
                field.Time("created_at").
                        Default(time.Now),
                field.Time("updated_at").
                        Default(time.Now).
                        UpdateDefault(time.Now),
        }
}

// Edges of the Token.
func (Token) Edges() []ent.Edge <span class="cov0" title="0">{
        return []ent.Edge{
                edge.From("user", User.Type).
                        Ref("tokens").
                        Unique().
                        Required(),
        }
}</span>
</pre>
		
		<pre class="file" id="file18" style="display: none">package schema

import (
        "auth/pkg"
        "context"
        "time"

        "entgo.io/ent"
        "entgo.io/ent/schema/edge"
        "entgo.io/ent/schema/field"
        "github.com/google/uuid"
)

// User holds the schema definition for the User entity.
type User struct {
        ent.Schema
}

// Fields of the User.
func (User) Fields() []ent.Field <span class="cov1" title="1">{
        return []ent.Field{
                field.String("id").
                        DefaultFunc(func() string </span><span class="cov8" title="38">{
                                return uuid.New().String()
                        }</span>),
                field.String("username").Unique(),
                field.String("email").Unique(),
                field.String("password"),
                field.Time("created_at").
                        Default(time.Now),
                field.Time("updated_at").
                        Default(time.Now).
                        UpdateDefault(time.Now),
        }
}

// Edges of the User.
func (User) Edges() []ent.Edge <span class="cov0" title="0">{
        return []ent.Edge{
                edge.To("roles", Role.Type),
                edge.To("tokens", Token.Type),
        }
}</span>

// Hooks of the User.
func (User) Hooks() []ent.Hook <span class="cov1" title="1">{
        return []ent.Hook{
                HashPassword(),
        }
}</span>

// HashPassword is a hook that hashes the password before creating or updating a user.
func HashPassword() ent.Hook <span class="cov1" title="1">{
        return func(next ent.Mutator) ent.Mutator </span><span class="cov10" title="60">{
                return ent.MutateFunc(func(ctx context.Context, m ent.Mutation) (ent.Value, error) </span><span class="cov10" title="60">{
                        if password, ok := m.Field("password"); ok </span><span class="cov9" title="47">{
                                hash, err := pkg.NewPasswordHasher(12).HashPassword(password.(string)) // HLc
                                if err != nil </span><span class="cov0" title="0">{
                                        return nil, err
                                }</span>
                                <span class="cov9" title="47">m.SetField("password", string(hash))</span>
                        }
                        <span class="cov10" title="60">return next.Mutate(ctx, m)</span>
                })
        }
}
</pre>
		
		<pre class="file" id="file19" style="display: none">// Code generated by ent, DO NOT EDIT.

package ent

import (
        "auth/ent/token"
        "auth/ent/user"
        "fmt"
        "strings"
        "time"

        "entgo.io/ent"
        "entgo.io/ent/dialect/sql"
)

// Token is the model entity for the Token schema.
type Token struct {
        config `json:"-"`
        // ID of the ent.
        ID string `json:"id,omitempty"`
        // Token holds the value of the "token" field.
        Token string `json:"token,omitempty"`
        // Type holds the value of the "type" field.
        Type token.Type `json:"type,omitempty"`
        // ExpiresAt holds the value of the "expires_at" field.
        ExpiresAt time.Time `json:"expires_at,omitempty"`
        // Revoked holds the value of the "revoked" field.
        Revoked bool `json:"revoked,omitempty"`
        // CreatedAt holds the value of the "created_at" field.
        CreatedAt time.Time `json:"created_at,omitempty"`
        // UpdatedAt holds the value of the "updated_at" field.
        UpdatedAt time.Time `json:"updated_at,omitempty"`
        // Edges holds the relations/edges for other nodes in the graph.
        // The values are being populated by the TokenQuery when eager-loading is set.
        Edges        TokenEdges `json:"edges"`
        user_tokens  *string
        selectValues sql.SelectValues
}

// TokenEdges holds the relations/edges for other nodes in the graph.
type TokenEdges struct {
        // User holds the value of the user edge.
        User *User `json:"user,omitempty"`
        // loadedTypes holds the information for reporting if a
        // type was loaded (or requested) in eager-loading or not.
        loadedTypes [1]bool
}

// UserOrErr returns the User value or an error if the edge
// was not loaded in eager-loading, or loaded but was not found.
func (e TokenEdges) UserOrErr() (*User, error) <span class="cov0" title="0">{
        if e.User != nil </span><span class="cov0" title="0">{
                return e.User, nil
        }</span> else<span class="cov0" title="0"> if e.loadedTypes[0] </span><span class="cov0" title="0">{
                return nil, &amp;NotFoundError{label: user.Label}
        }</span>
        <span class="cov0" title="0">return nil, &amp;NotLoadedError{edge: "user"}</span>
}

// scanValues returns the types for scanning values from sql.Rows.
func (*Token) scanValues(columns []string) ([]any, error) <span class="cov5" title="8">{
        values := make([]any, len(columns))
        for i := range columns </span><span class="cov10" title="56">{
                switch columns[i] </span>{
                case token.FieldRevoked:<span class="cov5" title="8">
                        values[i] = new(sql.NullBool)</span>
                case token.FieldID, token.FieldToken, token.FieldType:<span class="cov8" title="24">
                        values[i] = new(sql.NullString)</span>
                case token.FieldExpiresAt, token.FieldCreatedAt, token.FieldUpdatedAt:<span class="cov8" title="24">
                        values[i] = new(sql.NullTime)</span>
                case token.ForeignKeys[0]:<span class="cov0" title="0"> // user_tokens
                        values[i] = new(sql.NullString)</span>
                default:<span class="cov0" title="0">
                        values[i] = new(sql.UnknownType)</span>
                }
        }
        <span class="cov5" title="8">return values, nil</span>
}

// assignValues assigns the values that were returned from sql.Rows (after scanning)
// to the Token fields.
func (t *Token) assignValues(columns []string, values []any) error <span class="cov5" title="8">{
        if m, n := len(values), len(columns); m &lt; n </span><span class="cov0" title="0">{
                return fmt.Errorf("mismatch number of scan values: %d != %d", m, n)
        }</span>
        <span class="cov5" title="8">for i := range columns </span><span class="cov10" title="56">{
                switch columns[i] </span>{
                case token.FieldID:<span class="cov5" title="8">
                        if value, ok := values[i].(*sql.NullString); !ok </span><span class="cov0" title="0">{
                                return fmt.Errorf("unexpected type %T for field id", values[i])
                        }</span> else<span class="cov5" title="8"> if value.Valid </span><span class="cov5" title="8">{
                                t.ID = value.String
                        }</span>
                case token.FieldToken:<span class="cov5" title="8">
                        if value, ok := values[i].(*sql.NullString); !ok </span><span class="cov0" title="0">{
                                return fmt.Errorf("unexpected type %T for field token", values[i])
                        }</span> else<span class="cov5" title="8"> if value.Valid </span><span class="cov5" title="8">{
                                t.Token = value.String
                        }</span>
                case token.FieldType:<span class="cov5" title="8">
                        if value, ok := values[i].(*sql.NullString); !ok </span><span class="cov0" title="0">{
                                return fmt.Errorf("unexpected type %T for field type", values[i])
                        }</span> else<span class="cov5" title="8"> if value.Valid </span><span class="cov5" title="8">{
                                t.Type = token.Type(value.String)
                        }</span>
                case token.FieldExpiresAt:<span class="cov5" title="8">
                        if value, ok := values[i].(*sql.NullTime); !ok </span><span class="cov0" title="0">{
                                return fmt.Errorf("unexpected type %T for field expires_at", values[i])
                        }</span> else<span class="cov5" title="8"> if value.Valid </span><span class="cov5" title="8">{
                                t.ExpiresAt = value.Time
                        }</span>
                case token.FieldRevoked:<span class="cov5" title="8">
                        if value, ok := values[i].(*sql.NullBool); !ok </span><span class="cov0" title="0">{
                                return fmt.Errorf("unexpected type %T for field revoked", values[i])
                        }</span> else<span class="cov5" title="8"> if value.Valid </span><span class="cov5" title="8">{
                                t.Revoked = value.Bool
                        }</span>
                case token.FieldCreatedAt:<span class="cov5" title="8">
                        if value, ok := values[i].(*sql.NullTime); !ok </span><span class="cov0" title="0">{
                                return fmt.Errorf("unexpected type %T for field created_at", values[i])
                        }</span> else<span class="cov5" title="8"> if value.Valid </span><span class="cov5" title="8">{
                                t.CreatedAt = value.Time
                        }</span>
                case token.FieldUpdatedAt:<span class="cov5" title="8">
                        if value, ok := values[i].(*sql.NullTime); !ok </span><span class="cov0" title="0">{
                                return fmt.Errorf("unexpected type %T for field updated_at", values[i])
                        }</span> else<span class="cov5" title="8"> if value.Valid </span><span class="cov5" title="8">{
                                t.UpdatedAt = value.Time
                        }</span>
                case token.ForeignKeys[0]:<span class="cov0" title="0">
                        if value, ok := values[i].(*sql.NullString); !ok </span><span class="cov0" title="0">{
                                return fmt.Errorf("unexpected type %T for field user_tokens", values[i])
                        }</span> else<span class="cov0" title="0"> if value.Valid </span><span class="cov0" title="0">{
                                t.user_tokens = new(string)
                                *t.user_tokens = value.String
                        }</span>
                default:<span class="cov0" title="0">
                        t.selectValues.Set(columns[i], values[i])</span>
                }
        }
        <span class="cov5" title="8">return nil</span>
}

// Value returns the ent.Value that was dynamically selected and assigned to the Token.
// This includes values selected through modifiers, order, etc.
func (t *Token) Value(name string) (ent.Value, error) <span class="cov0" title="0">{
        return t.selectValues.Get(name)
}</span>

// QueryUser queries the "user" edge of the Token entity.
func (t *Token) QueryUser() *UserQuery <span class="cov1" title="1">{
        return NewTokenClient(t.config).QueryUser(t)
}</span>

// Update returns a builder for updating this Token.
// Note that you need to call Token.Unwrap() before calling this method if this Token
// was returned from a transaction, and the transaction was committed or rolled back.
func (t *Token) Update() *TokenUpdateOne <span class="cov1" title="1">{
        return NewTokenClient(t.config).UpdateOne(t)
}</span>

// Unwrap unwraps the Token entity that was returned from a transaction after it was closed,
// so that all future queries will be executed through the driver which created the transaction.
func (t *Token) Unwrap() *Token <span class="cov0" title="0">{
        _tx, ok := t.config.driver.(*txDriver)
        if !ok </span><span class="cov0" title="0">{
                panic("ent: Token is not a transactional entity")</span>
        }
        <span class="cov0" title="0">t.config.driver = _tx.drv
        return t</span>
}

// String implements the fmt.Stringer.
func (t *Token) String() string <span class="cov0" title="0">{
        var builder strings.Builder
        builder.WriteString("Token(")
        builder.WriteString(fmt.Sprintf("id=%v, ", t.ID))
        builder.WriteString("token=")
        builder.WriteString(t.Token)
        builder.WriteString(", ")
        builder.WriteString("type=")
        builder.WriteString(fmt.Sprintf("%v", t.Type))
        builder.WriteString(", ")
        builder.WriteString("expires_at=")
        builder.WriteString(t.ExpiresAt.Format(time.ANSIC))
        builder.WriteString(", ")
        builder.WriteString("revoked=")
        builder.WriteString(fmt.Sprintf("%v", t.Revoked))
        builder.WriteString(", ")
        builder.WriteString("created_at=")
        builder.WriteString(t.CreatedAt.Format(time.ANSIC))
        builder.WriteString(", ")
        builder.WriteString("updated_at=")
        builder.WriteString(t.UpdatedAt.Format(time.ANSIC))
        builder.WriteByte(')')
        return builder.String()
}</span>

// Tokens is a parsable slice of Token.
type Tokens []*Token
</pre>
		
		<pre class="file" id="file20" style="display: none">// Code generated by ent, DO NOT EDIT.

package token

import (
        "fmt"
        "time"

        "entgo.io/ent/dialect/sql"
        "entgo.io/ent/dialect/sql/sqlgraph"
)

const (
        // Label holds the string label denoting the token type in the database.
        Label = "token"
        // FieldID holds the string denoting the id field in the database.
        FieldID = "id"
        // FieldToken holds the string denoting the token field in the database.
        FieldToken = "token"
        // FieldType holds the string denoting the type field in the database.
        FieldType = "type"
        // FieldExpiresAt holds the string denoting the expires_at field in the database.
        FieldExpiresAt = "expires_at"
        // FieldRevoked holds the string denoting the revoked field in the database.
        FieldRevoked = "revoked"
        // FieldCreatedAt holds the string denoting the created_at field in the database.
        FieldCreatedAt = "created_at"
        // FieldUpdatedAt holds the string denoting the updated_at field in the database.
        FieldUpdatedAt = "updated_at"
        // EdgeUser holds the string denoting the user edge name in mutations.
        EdgeUser = "user"
        // Table holds the table name of the token in the database.
        Table = "tokens"
        // UserTable is the table that holds the user relation/edge.
        UserTable = "tokens"
        // UserInverseTable is the table name for the User entity.
        // It exists in this package in order to avoid circular dependency with the "user" package.
        UserInverseTable = "users"
        // UserColumn is the table column denoting the user relation/edge.
        UserColumn = "user_tokens"
)

// Columns holds all SQL columns for token fields.
var Columns = []string{
        FieldID,
        FieldToken,
        FieldType,
        FieldExpiresAt,
        FieldRevoked,
        FieldCreatedAt,
        FieldUpdatedAt,
}

// ForeignKeys holds the SQL foreign-keys that are owned by the "tokens"
// table and are not defined as standalone fields in the schema.
var ForeignKeys = []string{
        "user_tokens",
}

// ValidColumn reports if the column name is valid (part of the table columns).
func ValidColumn(column string) bool <span class="cov0" title="0">{
        for i := range Columns </span><span class="cov0" title="0">{
                if column == Columns[i] </span><span class="cov0" title="0">{
                        return true
                }</span>
        }
        <span class="cov0" title="0">for i := range ForeignKeys </span><span class="cov0" title="0">{
                if column == ForeignKeys[i] </span><span class="cov0" title="0">{
                        return true
                }</span>
        }
        <span class="cov0" title="0">return false</span>
}

var (
        // DefaultRevoked holds the default value on creation for the "revoked" field.
        DefaultRevoked bool
        // DefaultCreatedAt holds the default value on creation for the "created_at" field.
        DefaultCreatedAt func() time.Time
        // DefaultUpdatedAt holds the default value on creation for the "updated_at" field.
        DefaultUpdatedAt func() time.Time
        // UpdateDefaultUpdatedAt holds the default value on update for the "updated_at" field.
        UpdateDefaultUpdatedAt func() time.Time
        // DefaultID holds the default value on creation for the "id" field.
        DefaultID func() string
)

// Type defines the type for the "type" enum field.
type Type string

// Type values.
const (
        TypeAccess  Type = "access"
        TypeRefresh Type = "refresh"
)

func (_type Type) String() string <span class="cov3" title="2">{
        return string(_type)
}</span>

// TypeValidator is a validator for the "type" field enum values. It is called by the builders before save.
func TypeValidator(_type Type) error <span class="cov10" title="13">{
        switch _type </span>{
        case TypeAccess, TypeRefresh:<span class="cov10" title="13">
                return nil</span>
        default:<span class="cov0" title="0">
                return fmt.Errorf("token: invalid enum value for type field: %q", _type)</span>
        }
}

// OrderOption defines the ordering options for the Token queries.
type OrderOption func(*sql.Selector)

// ByID orders the results by the id field.
func ByID(opts ...sql.OrderTermOption) OrderOption <span class="cov0" title="0">{
        return sql.OrderByField(FieldID, opts...).ToFunc()
}</span>

// ByToken orders the results by the token field.
func ByToken(opts ...sql.OrderTermOption) OrderOption <span class="cov0" title="0">{
        return sql.OrderByField(FieldToken, opts...).ToFunc()
}</span>

// ByType orders the results by the type field.
func ByType(opts ...sql.OrderTermOption) OrderOption <span class="cov0" title="0">{
        return sql.OrderByField(FieldType, opts...).ToFunc()
}</span>

// ByExpiresAt orders the results by the expires_at field.
func ByExpiresAt(opts ...sql.OrderTermOption) OrderOption <span class="cov0" title="0">{
        return sql.OrderByField(FieldExpiresAt, opts...).ToFunc()
}</span>

// ByRevoked orders the results by the revoked field.
func ByRevoked(opts ...sql.OrderTermOption) OrderOption <span class="cov0" title="0">{
        return sql.OrderByField(FieldRevoked, opts...).ToFunc()
}</span>

// ByCreatedAt orders the results by the created_at field.
func ByCreatedAt(opts ...sql.OrderTermOption) OrderOption <span class="cov0" title="0">{
        return sql.OrderByField(FieldCreatedAt, opts...).ToFunc()
}</span>

// ByUpdatedAt orders the results by the updated_at field.
func ByUpdatedAt(opts ...sql.OrderTermOption) OrderOption <span class="cov0" title="0">{
        return sql.OrderByField(FieldUpdatedAt, opts...).ToFunc()
}</span>

// ByUserField orders the results by user field.
func ByUserField(field string, opts ...sql.OrderTermOption) OrderOption <span class="cov0" title="0">{
        return func(s *sql.Selector) </span><span class="cov0" title="0">{
                sqlgraph.OrderByNeighborTerms(s, newUserStep(), sql.OrderByField(field, opts...))
        }</span>
}
func newUserStep() *sqlgraph.Step <span class="cov4" title="3">{
        return sqlgraph.NewStep(
                sqlgraph.From(Table, FieldID),
                sqlgraph.To(UserInverseTable, FieldID),
                sqlgraph.Edge(sqlgraph.M2O, true, UserTable, UserColumn),
        )
}</span>
</pre>
		
		<pre class="file" id="file21" style="display: none">// Code generated by ent, DO NOT EDIT.

package token

import (
        "auth/ent/predicate"
        "time"

        "entgo.io/ent/dialect/sql"
        "entgo.io/ent/dialect/sql/sqlgraph"
)

// ID filters vertices based on their ID field.
func ID(id string) predicate.Token <span class="cov7" title="4">{
        return predicate.Token(sql.FieldEQ(FieldID, id))
}</span>

// IDEQ applies the EQ predicate on the ID field.
func IDEQ(id string) predicate.Token <span class="cov0" title="0">{
        return predicate.Token(sql.FieldEQ(FieldID, id))
}</span>

// IDNEQ applies the NEQ predicate on the ID field.
func IDNEQ(id string) predicate.Token <span class="cov0" title="0">{
        return predicate.Token(sql.FieldNEQ(FieldID, id))
}</span>

// IDIn applies the In predicate on the ID field.
func IDIn(ids ...string) predicate.Token <span class="cov0" title="0">{
        return predicate.Token(sql.FieldIn(FieldID, ids...))
}</span>

// IDNotIn applies the NotIn predicate on the ID field.
func IDNotIn(ids ...string) predicate.Token <span class="cov0" title="0">{
        return predicate.Token(sql.FieldNotIn(FieldID, ids...))
}</span>

// IDGT applies the GT predicate on the ID field.
func IDGT(id string) predicate.Token <span class="cov0" title="0">{
        return predicate.Token(sql.FieldGT(FieldID, id))
}</span>

// IDGTE applies the GTE predicate on the ID field.
func IDGTE(id string) predicate.Token <span class="cov0" title="0">{
        return predicate.Token(sql.FieldGTE(FieldID, id))
}</span>

// IDLT applies the LT predicate on the ID field.
func IDLT(id string) predicate.Token <span class="cov0" title="0">{
        return predicate.Token(sql.FieldLT(FieldID, id))
}</span>

// IDLTE applies the LTE predicate on the ID field.
func IDLTE(id string) predicate.Token <span class="cov0" title="0">{
        return predicate.Token(sql.FieldLTE(FieldID, id))
}</span>

// IDEqualFold applies the EqualFold predicate on the ID field.
func IDEqualFold(id string) predicate.Token <span class="cov0" title="0">{
        return predicate.Token(sql.FieldEqualFold(FieldID, id))
}</span>

// IDContainsFold applies the ContainsFold predicate on the ID field.
func IDContainsFold(id string) predicate.Token <span class="cov0" title="0">{
        return predicate.Token(sql.FieldContainsFold(FieldID, id))
}</span>

// Token applies equality check predicate on the "token" field. It's identical to TokenEQ.
func Token(v string) predicate.Token <span class="cov10" title="6">{
        return predicate.Token(sql.FieldEQ(FieldToken, v))
}</span>

// ExpiresAt applies equality check predicate on the "expires_at" field. It's identical to ExpiresAtEQ.
func ExpiresAt(v time.Time) predicate.Token <span class="cov0" title="0">{
        return predicate.Token(sql.FieldEQ(FieldExpiresAt, v))
}</span>

// Revoked applies equality check predicate on the "revoked" field. It's identical to RevokedEQ.
func Revoked(v bool) predicate.Token <span class="cov7" title="4">{
        return predicate.Token(sql.FieldEQ(FieldRevoked, v))
}</span>

// CreatedAt applies equality check predicate on the "created_at" field. It's identical to CreatedAtEQ.
func CreatedAt(v time.Time) predicate.Token <span class="cov0" title="0">{
        return predicate.Token(sql.FieldEQ(FieldCreatedAt, v))
}</span>

// UpdatedAt applies equality check predicate on the "updated_at" field. It's identical to UpdatedAtEQ.
func UpdatedAt(v time.Time) predicate.Token <span class="cov0" title="0">{
        return predicate.Token(sql.FieldEQ(FieldUpdatedAt, v))
}</span>

// TokenEQ applies the EQ predicate on the "token" field.
func TokenEQ(v string) predicate.Token <span class="cov0" title="0">{
        return predicate.Token(sql.FieldEQ(FieldToken, v))
}</span>

// TokenNEQ applies the NEQ predicate on the "token" field.
func TokenNEQ(v string) predicate.Token <span class="cov0" title="0">{
        return predicate.Token(sql.FieldNEQ(FieldToken, v))
}</span>

// TokenIn applies the In predicate on the "token" field.
func TokenIn(vs ...string) predicate.Token <span class="cov0" title="0">{
        return predicate.Token(sql.FieldIn(FieldToken, vs...))
}</span>

// TokenNotIn applies the NotIn predicate on the "token" field.
func TokenNotIn(vs ...string) predicate.Token <span class="cov0" title="0">{
        return predicate.Token(sql.FieldNotIn(FieldToken, vs...))
}</span>

// TokenGT applies the GT predicate on the "token" field.
func TokenGT(v string) predicate.Token <span class="cov0" title="0">{
        return predicate.Token(sql.FieldGT(FieldToken, v))
}</span>

// TokenGTE applies the GTE predicate on the "token" field.
func TokenGTE(v string) predicate.Token <span class="cov0" title="0">{
        return predicate.Token(sql.FieldGTE(FieldToken, v))
}</span>

// TokenLT applies the LT predicate on the "token" field.
func TokenLT(v string) predicate.Token <span class="cov0" title="0">{
        return predicate.Token(sql.FieldLT(FieldToken, v))
}</span>

// TokenLTE applies the LTE predicate on the "token" field.
func TokenLTE(v string) predicate.Token <span class="cov0" title="0">{
        return predicate.Token(sql.FieldLTE(FieldToken, v))
}</span>

// TokenContains applies the Contains predicate on the "token" field.
func TokenContains(v string) predicate.Token <span class="cov0" title="0">{
        return predicate.Token(sql.FieldContains(FieldToken, v))
}</span>

// TokenHasPrefix applies the HasPrefix predicate on the "token" field.
func TokenHasPrefix(v string) predicate.Token <span class="cov0" title="0">{
        return predicate.Token(sql.FieldHasPrefix(FieldToken, v))
}</span>

// TokenHasSuffix applies the HasSuffix predicate on the "token" field.
func TokenHasSuffix(v string) predicate.Token <span class="cov0" title="0">{
        return predicate.Token(sql.FieldHasSuffix(FieldToken, v))
}</span>

// TokenEqualFold applies the EqualFold predicate on the "token" field.
func TokenEqualFold(v string) predicate.Token <span class="cov0" title="0">{
        return predicate.Token(sql.FieldEqualFold(FieldToken, v))
}</span>

// TokenContainsFold applies the ContainsFold predicate on the "token" field.
func TokenContainsFold(v string) predicate.Token <span class="cov0" title="0">{
        return predicate.Token(sql.FieldContainsFold(FieldToken, v))
}</span>

// TypeEQ applies the EQ predicate on the "type" field.
func TypeEQ(v Type) predicate.Token <span class="cov0" title="0">{
        return predicate.Token(sql.FieldEQ(FieldType, v))
}</span>

// TypeNEQ applies the NEQ predicate on the "type" field.
func TypeNEQ(v Type) predicate.Token <span class="cov0" title="0">{
        return predicate.Token(sql.FieldNEQ(FieldType, v))
}</span>

// TypeIn applies the In predicate on the "type" field.
func TypeIn(vs ...Type) predicate.Token <span class="cov0" title="0">{
        return predicate.Token(sql.FieldIn(FieldType, vs...))
}</span>

// TypeNotIn applies the NotIn predicate on the "type" field.
func TypeNotIn(vs ...Type) predicate.Token <span class="cov0" title="0">{
        return predicate.Token(sql.FieldNotIn(FieldType, vs...))
}</span>

// ExpiresAtEQ applies the EQ predicate on the "expires_at" field.
func ExpiresAtEQ(v time.Time) predicate.Token <span class="cov0" title="0">{
        return predicate.Token(sql.FieldEQ(FieldExpiresAt, v))
}</span>

// ExpiresAtNEQ applies the NEQ predicate on the "expires_at" field.
func ExpiresAtNEQ(v time.Time) predicate.Token <span class="cov0" title="0">{
        return predicate.Token(sql.FieldNEQ(FieldExpiresAt, v))
}</span>

// ExpiresAtIn applies the In predicate on the "expires_at" field.
func ExpiresAtIn(vs ...time.Time) predicate.Token <span class="cov0" title="0">{
        return predicate.Token(sql.FieldIn(FieldExpiresAt, vs...))
}</span>

// ExpiresAtNotIn applies the NotIn predicate on the "expires_at" field.
func ExpiresAtNotIn(vs ...time.Time) predicate.Token <span class="cov0" title="0">{
        return predicate.Token(sql.FieldNotIn(FieldExpiresAt, vs...))
}</span>

// ExpiresAtGT applies the GT predicate on the "expires_at" field.
func ExpiresAtGT(v time.Time) predicate.Token <span class="cov4" title="2">{
        return predicate.Token(sql.FieldGT(FieldExpiresAt, v))
}</span>

// ExpiresAtGTE applies the GTE predicate on the "expires_at" field.
func ExpiresAtGTE(v time.Time) predicate.Token <span class="cov0" title="0">{
        return predicate.Token(sql.FieldGTE(FieldExpiresAt, v))
}</span>

// ExpiresAtLT applies the LT predicate on the "expires_at" field.
func ExpiresAtLT(v time.Time) predicate.Token <span class="cov1" title="1">{
        return predicate.Token(sql.FieldLT(FieldExpiresAt, v))
}</span>

// ExpiresAtLTE applies the LTE predicate on the "expires_at" field.
func ExpiresAtLTE(v time.Time) predicate.Token <span class="cov0" title="0">{
        return predicate.Token(sql.FieldLTE(FieldExpiresAt, v))
}</span>

// RevokedEQ applies the EQ predicate on the "revoked" field.
func RevokedEQ(v bool) predicate.Token <span class="cov6" title="3">{
        return predicate.Token(sql.FieldEQ(FieldRevoked, v))
}</span>

// RevokedNEQ applies the NEQ predicate on the "revoked" field.
func RevokedNEQ(v bool) predicate.Token <span class="cov0" title="0">{
        return predicate.Token(sql.FieldNEQ(FieldRevoked, v))
}</span>

// CreatedAtEQ applies the EQ predicate on the "created_at" field.
func CreatedAtEQ(v time.Time) predicate.Token <span class="cov0" title="0">{
        return predicate.Token(sql.FieldEQ(FieldCreatedAt, v))
}</span>

// CreatedAtNEQ applies the NEQ predicate on the "created_at" field.
func CreatedAtNEQ(v time.Time) predicate.Token <span class="cov0" title="0">{
        return predicate.Token(sql.FieldNEQ(FieldCreatedAt, v))
}</span>

// CreatedAtIn applies the In predicate on the "created_at" field.
func CreatedAtIn(vs ...time.Time) predicate.Token <span class="cov0" title="0">{
        return predicate.Token(sql.FieldIn(FieldCreatedAt, vs...))
}</span>

// CreatedAtNotIn applies the NotIn predicate on the "created_at" field.
func CreatedAtNotIn(vs ...time.Time) predicate.Token <span class="cov0" title="0">{
        return predicate.Token(sql.FieldNotIn(FieldCreatedAt, vs...))
}</span>

// CreatedAtGT applies the GT predicate on the "created_at" field.
func CreatedAtGT(v time.Time) predicate.Token <span class="cov0" title="0">{
        return predicate.Token(sql.FieldGT(FieldCreatedAt, v))
}</span>

// CreatedAtGTE applies the GTE predicate on the "created_at" field.
func CreatedAtGTE(v time.Time) predicate.Token <span class="cov0" title="0">{
        return predicate.Token(sql.FieldGTE(FieldCreatedAt, v))
}</span>

// CreatedAtLT applies the LT predicate on the "created_at" field.
func CreatedAtLT(v time.Time) predicate.Token <span class="cov0" title="0">{
        return predicate.Token(sql.FieldLT(FieldCreatedAt, v))
}</span>

// CreatedAtLTE applies the LTE predicate on the "created_at" field.
func CreatedAtLTE(v time.Time) predicate.Token <span class="cov0" title="0">{
        return predicate.Token(sql.FieldLTE(FieldCreatedAt, v))
}</span>

// UpdatedAtEQ applies the EQ predicate on the "updated_at" field.
func UpdatedAtEQ(v time.Time) predicate.Token <span class="cov0" title="0">{
        return predicate.Token(sql.FieldEQ(FieldUpdatedAt, v))
}</span>

// UpdatedAtNEQ applies the NEQ predicate on the "updated_at" field.
func UpdatedAtNEQ(v time.Time) predicate.Token <span class="cov0" title="0">{
        return predicate.Token(sql.FieldNEQ(FieldUpdatedAt, v))
}</span>

// UpdatedAtIn applies the In predicate on the "updated_at" field.
func UpdatedAtIn(vs ...time.Time) predicate.Token <span class="cov0" title="0">{
        return predicate.Token(sql.FieldIn(FieldUpdatedAt, vs...))
}</span>

// UpdatedAtNotIn applies the NotIn predicate on the "updated_at" field.
func UpdatedAtNotIn(vs ...time.Time) predicate.Token <span class="cov0" title="0">{
        return predicate.Token(sql.FieldNotIn(FieldUpdatedAt, vs...))
}</span>

// UpdatedAtGT applies the GT predicate on the "updated_at" field.
func UpdatedAtGT(v time.Time) predicate.Token <span class="cov0" title="0">{
        return predicate.Token(sql.FieldGT(FieldUpdatedAt, v))
}</span>

// UpdatedAtGTE applies the GTE predicate on the "updated_at" field.
func UpdatedAtGTE(v time.Time) predicate.Token <span class="cov0" title="0">{
        return predicate.Token(sql.FieldGTE(FieldUpdatedAt, v))
}</span>

// UpdatedAtLT applies the LT predicate on the "updated_at" field.
func UpdatedAtLT(v time.Time) predicate.Token <span class="cov0" title="0">{
        return predicate.Token(sql.FieldLT(FieldUpdatedAt, v))
}</span>

// UpdatedAtLTE applies the LTE predicate on the "updated_at" field.
func UpdatedAtLTE(v time.Time) predicate.Token <span class="cov0" title="0">{
        return predicate.Token(sql.FieldLTE(FieldUpdatedAt, v))
}</span>

// HasUser applies the HasEdge predicate on the "user" edge.
func HasUser() predicate.Token <span class="cov0" title="0">{
        return predicate.Token(func(s *sql.Selector) </span><span class="cov0" title="0">{
                step := sqlgraph.NewStep(
                        sqlgraph.From(Table, FieldID),
                        sqlgraph.Edge(sqlgraph.M2O, true, UserTable, UserColumn),
                )
                sqlgraph.HasNeighbors(s, step)
        }</span>)
}

// HasUserWith applies the HasEdge predicate on the "user" edge with a given conditions (other predicates).
func HasUserWith(preds ...predicate.User) predicate.Token <span class="cov6" title="3">{
        return predicate.Token(func(s *sql.Selector) </span><span class="cov6" title="3">{
                step := newUserStep()
                sqlgraph.HasNeighborsWith(s, step, func(s *sql.Selector) </span><span class="cov6" title="3">{
                        for _, p := range preds </span><span class="cov6" title="3">{
                                p(s)
                        }</span>
                })
        })
}

// And groups predicates with the AND operator between them.
func And(predicates ...predicate.Token) predicate.Token <span class="cov0" title="0">{
        return predicate.Token(sql.AndPredicates(predicates...))
}</span>

// Or groups predicates with the OR operator between them.
func Or(predicates ...predicate.Token) predicate.Token <span class="cov1" title="1">{
        return predicate.Token(sql.OrPredicates(predicates...))
}</span>

// Not applies the not operator on the given predicate.
func Not(p predicate.Token) predicate.Token <span class="cov0" title="0">{
        return predicate.Token(sql.NotPredicates(p))
}</span>
</pre>
		
		<pre class="file" id="file22" style="display: none">// Code generated by ent, DO NOT EDIT.

package ent

import (
        "auth/ent/token"
        "auth/ent/user"
        "context"
        "errors"
        "fmt"
        "time"

        "entgo.io/ent/dialect/sql/sqlgraph"
        "entgo.io/ent/schema/field"
)

// TokenCreate is the builder for creating a Token entity.
type TokenCreate struct {
        config
        mutation *TokenMutation
        hooks    []Hook
}

// SetToken sets the "token" field.
func (tc *TokenCreate) SetToken(s string) *TokenCreate <span class="cov10" title="13">{
        tc.mutation.SetToken(s)
        return tc
}</span>

// SetType sets the "type" field.
func (tc *TokenCreate) SetType(t token.Type) *TokenCreate <span class="cov10" title="13">{
        tc.mutation.SetType(t)
        return tc
}</span>

// SetExpiresAt sets the "expires_at" field.
func (tc *TokenCreate) SetExpiresAt(t time.Time) *TokenCreate <span class="cov10" title="13">{
        tc.mutation.SetExpiresAt(t)
        return tc
}</span>

// SetRevoked sets the "revoked" field.
func (tc *TokenCreate) SetRevoked(b bool) *TokenCreate <span class="cov0" title="0">{
        tc.mutation.SetRevoked(b)
        return tc
}</span>

// SetNillableRevoked sets the "revoked" field if the given value is not nil.
func (tc *TokenCreate) SetNillableRevoked(b *bool) *TokenCreate <span class="cov0" title="0">{
        if b != nil </span><span class="cov0" title="0">{
                tc.SetRevoked(*b)
        }</span>
        <span class="cov0" title="0">return tc</span>
}

// SetCreatedAt sets the "created_at" field.
func (tc *TokenCreate) SetCreatedAt(t time.Time) *TokenCreate <span class="cov0" title="0">{
        tc.mutation.SetCreatedAt(t)
        return tc
}</span>

// SetNillableCreatedAt sets the "created_at" field if the given value is not nil.
func (tc *TokenCreate) SetNillableCreatedAt(t *time.Time) *TokenCreate <span class="cov0" title="0">{
        if t != nil </span><span class="cov0" title="0">{
                tc.SetCreatedAt(*t)
        }</span>
        <span class="cov0" title="0">return tc</span>
}

// SetUpdatedAt sets the "updated_at" field.
func (tc *TokenCreate) SetUpdatedAt(t time.Time) *TokenCreate <span class="cov0" title="0">{
        tc.mutation.SetUpdatedAt(t)
        return tc
}</span>

// SetNillableUpdatedAt sets the "updated_at" field if the given value is not nil.
func (tc *TokenCreate) SetNillableUpdatedAt(t *time.Time) *TokenCreate <span class="cov0" title="0">{
        if t != nil </span><span class="cov0" title="0">{
                tc.SetUpdatedAt(*t)
        }</span>
        <span class="cov0" title="0">return tc</span>
}

// SetID sets the "id" field.
func (tc *TokenCreate) SetID(s string) *TokenCreate <span class="cov0" title="0">{
        tc.mutation.SetID(s)
        return tc
}</span>

// SetNillableID sets the "id" field if the given value is not nil.
func (tc *TokenCreate) SetNillableID(s *string) *TokenCreate <span class="cov0" title="0">{
        if s != nil </span><span class="cov0" title="0">{
                tc.SetID(*s)
        }</span>
        <span class="cov0" title="0">return tc</span>
}

// SetUserID sets the "user" edge to the User entity by ID.
func (tc *TokenCreate) SetUserID(id string) *TokenCreate <span class="cov10" title="13">{
        tc.mutation.SetUserID(id)
        return tc
}</span>

// SetUser sets the "user" edge to the User entity.
func (tc *TokenCreate) SetUser(u *User) *TokenCreate <span class="cov5" title="4">{
        return tc.SetUserID(u.ID)
}</span>

// Mutation returns the TokenMutation object of the builder.
func (tc *TokenCreate) Mutation() *TokenMutation <span class="cov0" title="0">{
        return tc.mutation
}</span>

// Save creates the Token in the database.
func (tc *TokenCreate) Save(ctx context.Context) (*Token, error) <span class="cov10" title="13">{
        tc.defaults()
        return withHooks(ctx, tc.sqlSave, tc.mutation, tc.hooks)
}</span>

// SaveX calls Save and panics if Save returns an error.
func (tc *TokenCreate) SaveX(ctx context.Context) *Token <span class="cov0" title="0">{
        v, err := tc.Save(ctx)
        if err != nil </span><span class="cov0" title="0">{
                panic(err)</span>
        }
        <span class="cov0" title="0">return v</span>
}

// Exec executes the query.
func (tc *TokenCreate) Exec(ctx context.Context) error <span class="cov0" title="0">{
        _, err := tc.Save(ctx)
        return err
}</span>

// ExecX is like Exec, but panics if an error occurs.
func (tc *TokenCreate) ExecX(ctx context.Context) <span class="cov0" title="0">{
        if err := tc.Exec(ctx); err != nil </span><span class="cov0" title="0">{
                panic(err)</span>
        }
}

// defaults sets the default values of the builder before save.
func (tc *TokenCreate) defaults() <span class="cov10" title="13">{
        if _, ok := tc.mutation.Revoked(); !ok </span><span class="cov10" title="13">{
                v := token.DefaultRevoked
                tc.mutation.SetRevoked(v)
        }</span>
        <span class="cov10" title="13">if _, ok := tc.mutation.CreatedAt(); !ok </span><span class="cov10" title="13">{
                v := token.DefaultCreatedAt()
                tc.mutation.SetCreatedAt(v)
        }</span>
        <span class="cov10" title="13">if _, ok := tc.mutation.UpdatedAt(); !ok </span><span class="cov10" title="13">{
                v := token.DefaultUpdatedAt()
                tc.mutation.SetUpdatedAt(v)
        }</span>
        <span class="cov10" title="13">if _, ok := tc.mutation.ID(); !ok </span><span class="cov10" title="13">{
                v := token.DefaultID()
                tc.mutation.SetID(v)
        }</span>
}

// check runs all checks and user-defined validators on the builder.
func (tc *TokenCreate) check() error <span class="cov10" title="13">{
        if _, ok := tc.mutation.Token(); !ok </span><span class="cov0" title="0">{
                return &amp;ValidationError{Name: "token", err: errors.New(`ent: missing required field "Token.token"`)}
        }</span>
        <span class="cov10" title="13">if _, ok := tc.mutation.GetType(); !ok </span><span class="cov0" title="0">{
                return &amp;ValidationError{Name: "type", err: errors.New(`ent: missing required field "Token.type"`)}
        }</span>
        <span class="cov10" title="13">if v, ok := tc.mutation.GetType(); ok </span><span class="cov10" title="13">{
                if err := token.TypeValidator(v); err != nil </span><span class="cov0" title="0">{
                        return &amp;ValidationError{Name: "type", err: fmt.Errorf(`ent: validator failed for field "Token.type": %w`, err)}
                }</span>
        }
        <span class="cov10" title="13">if _, ok := tc.mutation.ExpiresAt(); !ok </span><span class="cov0" title="0">{
                return &amp;ValidationError{Name: "expires_at", err: errors.New(`ent: missing required field "Token.expires_at"`)}
        }</span>
        <span class="cov10" title="13">if _, ok := tc.mutation.Revoked(); !ok </span><span class="cov0" title="0">{
                return &amp;ValidationError{Name: "revoked", err: errors.New(`ent: missing required field "Token.revoked"`)}
        }</span>
        <span class="cov10" title="13">if _, ok := tc.mutation.CreatedAt(); !ok </span><span class="cov0" title="0">{
                return &amp;ValidationError{Name: "created_at", err: errors.New(`ent: missing required field "Token.created_at"`)}
        }</span>
        <span class="cov10" title="13">if _, ok := tc.mutation.UpdatedAt(); !ok </span><span class="cov0" title="0">{
                return &amp;ValidationError{Name: "updated_at", err: errors.New(`ent: missing required field "Token.updated_at"`)}
        }</span>
        <span class="cov10" title="13">if _, ok := tc.mutation.UserID(); !ok </span><span class="cov0" title="0">{
                return &amp;ValidationError{Name: "user", err: errors.New(`ent: missing required edge "Token.user"`)}
        }</span>
        <span class="cov10" title="13">return nil</span>
}

func (tc *TokenCreate) sqlSave(ctx context.Context) (*Token, error) <span class="cov10" title="13">{
        if err := tc.check(); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov10" title="13">_node, _spec := tc.createSpec()
        if err := sqlgraph.CreateNode(ctx, tc.driver, _spec); err != nil </span><span class="cov1" title="1">{
                if sqlgraph.IsConstraintError(err) </span><span class="cov1" title="1">{
                        err = &amp;ConstraintError{msg: err.Error(), wrap: err}
                }</span>
                <span class="cov1" title="1">return nil, err</span>
        }
        <span class="cov9" title="12">if _spec.ID.Value != nil </span><span class="cov9" title="12">{
                if id, ok := _spec.ID.Value.(string); ok </span><span class="cov9" title="12">{
                        _node.ID = id
                }</span> else<span class="cov0" title="0"> {
                        return nil, fmt.Errorf("unexpected Token.ID type: %T", _spec.ID.Value)
                }</span>
        }
        <span class="cov9" title="12">tc.mutation.id = &amp;_node.ID
        tc.mutation.done = true
        return _node, nil</span>
}

func (tc *TokenCreate) createSpec() (*Token, *sqlgraph.CreateSpec) <span class="cov10" title="13">{
        var (
                _node = &amp;Token{config: tc.config}
                _spec = sqlgraph.NewCreateSpec(token.Table, sqlgraph.NewFieldSpec(token.FieldID, field.TypeString))
        )
        if id, ok := tc.mutation.ID(); ok </span><span class="cov10" title="13">{
                _node.ID = id
                _spec.ID.Value = id
        }</span>
        <span class="cov10" title="13">if value, ok := tc.mutation.Token(); ok </span><span class="cov10" title="13">{
                _spec.SetField(token.FieldToken, field.TypeString, value)
                _node.Token = value
        }</span>
        <span class="cov10" title="13">if value, ok := tc.mutation.GetType(); ok </span><span class="cov10" title="13">{
                _spec.SetField(token.FieldType, field.TypeEnum, value)
                _node.Type = value
        }</span>
        <span class="cov10" title="13">if value, ok := tc.mutation.ExpiresAt(); ok </span><span class="cov10" title="13">{
                _spec.SetField(token.FieldExpiresAt, field.TypeTime, value)
                _node.ExpiresAt = value
        }</span>
        <span class="cov10" title="13">if value, ok := tc.mutation.Revoked(); ok </span><span class="cov10" title="13">{
                _spec.SetField(token.FieldRevoked, field.TypeBool, value)
                _node.Revoked = value
        }</span>
        <span class="cov10" title="13">if value, ok := tc.mutation.CreatedAt(); ok </span><span class="cov10" title="13">{
                _spec.SetField(token.FieldCreatedAt, field.TypeTime, value)
                _node.CreatedAt = value
        }</span>
        <span class="cov10" title="13">if value, ok := tc.mutation.UpdatedAt(); ok </span><span class="cov10" title="13">{
                _spec.SetField(token.FieldUpdatedAt, field.TypeTime, value)
                _node.UpdatedAt = value
        }</span>
        <span class="cov10" title="13">if nodes := tc.mutation.UserIDs(); len(nodes) &gt; 0 </span><span class="cov10" title="13">{
                edge := &amp;sqlgraph.EdgeSpec{
                        Rel:     sqlgraph.M2O,
                        Inverse: true,
                        Table:   token.UserTable,
                        Columns: []string{token.UserColumn},
                        Bidi:    false,
                        Target: &amp;sqlgraph.EdgeTarget{
                                IDSpec: sqlgraph.NewFieldSpec(user.FieldID, field.TypeString),
                        },
                }
                for _, k := range nodes </span><span class="cov10" title="13">{
                        edge.Target.Nodes = append(edge.Target.Nodes, k)
                }</span>
                <span class="cov10" title="13">_node.user_tokens = &amp;nodes[0]
                _spec.Edges = append(_spec.Edges, edge)</span>
        }
        <span class="cov10" title="13">return _node, _spec</span>
}

// TokenCreateBulk is the builder for creating many Token entities in bulk.
type TokenCreateBulk struct {
        config
        err      error
        builders []*TokenCreate
}

// Save creates the Token entities in the database.
func (tcb *TokenCreateBulk) Save(ctx context.Context) ([]*Token, error) <span class="cov0" title="0">{
        if tcb.err != nil </span><span class="cov0" title="0">{
                return nil, tcb.err
        }</span>
        <span class="cov0" title="0">specs := make([]*sqlgraph.CreateSpec, len(tcb.builders))
        nodes := make([]*Token, len(tcb.builders))
        mutators := make([]Mutator, len(tcb.builders))
        for i := range tcb.builders </span><span class="cov0" title="0">{
                func(i int, root context.Context) </span><span class="cov0" title="0">{
                        builder := tcb.builders[i]
                        builder.defaults()
                        var mut Mutator = MutateFunc(func(ctx context.Context, m Mutation) (Value, error) </span><span class="cov0" title="0">{
                                mutation, ok := m.(*TokenMutation)
                                if !ok </span><span class="cov0" title="0">{
                                        return nil, fmt.Errorf("unexpected mutation type %T", m)
                                }</span>
                                <span class="cov0" title="0">if err := builder.check(); err != nil </span><span class="cov0" title="0">{
                                        return nil, err
                                }</span>
                                <span class="cov0" title="0">builder.mutation = mutation
                                var err error
                                nodes[i], specs[i] = builder.createSpec()
                                if i &lt; len(mutators)-1 </span><span class="cov0" title="0">{
                                        _, err = mutators[i+1].Mutate(root, tcb.builders[i+1].mutation)
                                }</span> else<span class="cov0" title="0"> {
                                        spec := &amp;sqlgraph.BatchCreateSpec{Nodes: specs}
                                        // Invoke the actual operation on the latest mutation in the chain.
                                        if err = sqlgraph.BatchCreate(ctx, tcb.driver, spec); err != nil </span><span class="cov0" title="0">{
                                                if sqlgraph.IsConstraintError(err) </span><span class="cov0" title="0">{
                                                        err = &amp;ConstraintError{msg: err.Error(), wrap: err}
                                                }</span>
                                        }
                                }
                                <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                                        return nil, err
                                }</span>
                                <span class="cov0" title="0">mutation.id = &amp;nodes[i].ID
                                mutation.done = true
                                return nodes[i], nil</span>
                        })
                        <span class="cov0" title="0">for i := len(builder.hooks) - 1; i &gt;= 0; i-- </span><span class="cov0" title="0">{
                                mut = builder.hooks[i](mut)
                        }</span>
                        <span class="cov0" title="0">mutators[i] = mut</span>
                }(i, ctx)
        }
        <span class="cov0" title="0">if len(mutators) &gt; 0 </span><span class="cov0" title="0">{
                if _, err := mutators[0].Mutate(ctx, tcb.builders[0].mutation); err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
        }
        <span class="cov0" title="0">return nodes, nil</span>
}

// SaveX is like Save, but panics if an error occurs.
func (tcb *TokenCreateBulk) SaveX(ctx context.Context) []*Token <span class="cov0" title="0">{
        v, err := tcb.Save(ctx)
        if err != nil </span><span class="cov0" title="0">{
                panic(err)</span>
        }
        <span class="cov0" title="0">return v</span>
}

// Exec executes the query.
func (tcb *TokenCreateBulk) Exec(ctx context.Context) error <span class="cov0" title="0">{
        _, err := tcb.Save(ctx)
        return err
}</span>

// ExecX is like Exec, but panics if an error occurs.
func (tcb *TokenCreateBulk) ExecX(ctx context.Context) <span class="cov0" title="0">{
        if err := tcb.Exec(ctx); err != nil </span><span class="cov0" title="0">{
                panic(err)</span>
        }
}
</pre>
		
		<pre class="file" id="file23" style="display: none">// Code generated by ent, DO NOT EDIT.

package ent

import (
        "auth/ent/predicate"
        "auth/ent/token"
        "context"

        "entgo.io/ent/dialect/sql"
        "entgo.io/ent/dialect/sql/sqlgraph"
        "entgo.io/ent/schema/field"
)

// TokenDelete is the builder for deleting a Token entity.
type TokenDelete struct {
        config
        hooks    []Hook
        mutation *TokenMutation
}

// Where appends a list predicates to the TokenDelete builder.
func (td *TokenDelete) Where(ps ...predicate.Token) *TokenDelete <span class="cov8" title="1">{
        td.mutation.Where(ps...)
        return td
}</span>

// Exec executes the deletion query and returns how many vertices were deleted.
func (td *TokenDelete) Exec(ctx context.Context) (int, error) <span class="cov8" title="1">{
        return withHooks(ctx, td.sqlExec, td.mutation, td.hooks)
}</span>

// ExecX is like Exec, but panics if an error occurs.
func (td *TokenDelete) ExecX(ctx context.Context) int <span class="cov0" title="0">{
        n, err := td.Exec(ctx)
        if err != nil </span><span class="cov0" title="0">{
                panic(err)</span>
        }
        <span class="cov0" title="0">return n</span>
}

func (td *TokenDelete) sqlExec(ctx context.Context) (int, error) <span class="cov8" title="1">{
        _spec := sqlgraph.NewDeleteSpec(token.Table, sqlgraph.NewFieldSpec(token.FieldID, field.TypeString))
        if ps := td.mutation.predicates; len(ps) &gt; 0 </span><span class="cov8" title="1">{
                _spec.Predicate = func(selector *sql.Selector) </span><span class="cov8" title="1">{
                        for i := range ps </span><span class="cov8" title="1">{
                                ps[i](selector)
                        }</span>
                }
        }
        <span class="cov8" title="1">affected, err := sqlgraph.DeleteNodes(ctx, td.driver, _spec)
        if err != nil &amp;&amp; sqlgraph.IsConstraintError(err) </span><span class="cov0" title="0">{
                err = &amp;ConstraintError{msg: err.Error(), wrap: err}
        }</span>
        <span class="cov8" title="1">td.mutation.done = true
        return affected, err</span>
}

// TokenDeleteOne is the builder for deleting a single Token entity.
type TokenDeleteOne struct {
        td *TokenDelete
}

// Where appends a list predicates to the TokenDelete builder.
func (tdo *TokenDeleteOne) Where(ps ...predicate.Token) *TokenDeleteOne <span class="cov0" title="0">{
        tdo.td.mutation.Where(ps...)
        return tdo
}</span>

// Exec executes the deletion query.
func (tdo *TokenDeleteOne) Exec(ctx context.Context) error <span class="cov0" title="0">{
        n, err := tdo.td.Exec(ctx)
        switch </span>{
        case err != nil:<span class="cov0" title="0">
                return err</span>
        case n == 0:<span class="cov0" title="0">
                return &amp;NotFoundError{token.Label}</span>
        default:<span class="cov0" title="0">
                return nil</span>
        }
}

// ExecX is like Exec, but panics if an error occurs.
func (tdo *TokenDeleteOne) ExecX(ctx context.Context) <span class="cov0" title="0">{
        if err := tdo.Exec(ctx); err != nil </span><span class="cov0" title="0">{
                panic(err)</span>
        }
}
</pre>
		
		<pre class="file" id="file24" style="display: none">// Code generated by ent, DO NOT EDIT.

package ent

import (
        "auth/ent/predicate"
        "auth/ent/token"
        "auth/ent/user"
        "context"
        "fmt"
        "math"

        "entgo.io/ent/dialect/sql"
        "entgo.io/ent/dialect/sql/sqlgraph"
        "entgo.io/ent/schema/field"
)

// TokenQuery is the builder for querying Token entities.
type TokenQuery struct {
        config
        ctx        *QueryContext
        order      []token.OrderOption
        inters     []Interceptor
        predicates []predicate.Token
        withUser   *UserQuery
        withFKs    bool
        // intermediate query (i.e. traversal path).
        sql  *sql.Selector
        path func(context.Context) (*sql.Selector, error)
}

// Where adds a new predicate for the TokenQuery builder.
func (tq *TokenQuery) Where(ps ...predicate.Token) *TokenQuery <span class="cov8" title="9">{
        tq.predicates = append(tq.predicates, ps...)
        return tq
}</span>

// Limit the number of records to be returned by this query.
func (tq *TokenQuery) Limit(limit int) *TokenQuery <span class="cov7" title="7">{
        tq.ctx.Limit = &amp;limit
        return tq
}</span>

// Offset to start from.
func (tq *TokenQuery) Offset(offset int) *TokenQuery <span class="cov0" title="0">{
        tq.ctx.Offset = &amp;offset
        return tq
}</span>

// Unique configures the query builder to filter duplicate records on query.
// By default, unique is set to true, and can be disabled using this method.
func (tq *TokenQuery) Unique(unique bool) *TokenQuery <span class="cov0" title="0">{
        tq.ctx.Unique = &amp;unique
        return tq
}</span>

// Order specifies how the records should be ordered.
func (tq *TokenQuery) Order(o ...token.OrderOption) *TokenQuery <span class="cov0" title="0">{
        tq.order = append(tq.order, o...)
        return tq
}</span>

// QueryUser chains the current query on the "user" edge.
func (tq *TokenQuery) QueryUser() *UserQuery <span class="cov0" title="0">{
        query := (&amp;UserClient{config: tq.config}).Query()
        query.path = func(ctx context.Context) (fromU *sql.Selector, err error) </span><span class="cov0" title="0">{
                if err := tq.prepareQuery(ctx); err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">selector := tq.sqlQuery(ctx)
                if err := selector.Err(); err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">step := sqlgraph.NewStep(
                        sqlgraph.From(token.Table, token.FieldID, selector),
                        sqlgraph.To(user.Table, user.FieldID),
                        sqlgraph.Edge(sqlgraph.M2O, true, token.UserTable, token.UserColumn),
                )
                fromU = sqlgraph.SetNeighbors(tq.driver.Dialect(), step)
                return fromU, nil</span>
        }
        <span class="cov0" title="0">return query</span>
}

// First returns the first Token entity from the query.
// Returns a *NotFoundError when no Token was found.
func (tq *TokenQuery) First(ctx context.Context) (*Token, error) <span class="cov0" title="0">{
        nodes, err := tq.Limit(1).All(setContextOp(ctx, tq.ctx, "First"))
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">if len(nodes) == 0 </span><span class="cov0" title="0">{
                return nil, &amp;NotFoundError{token.Label}
        }</span>
        <span class="cov0" title="0">return nodes[0], nil</span>
}

// FirstX is like First, but panics if an error occurs.
func (tq *TokenQuery) FirstX(ctx context.Context) *Token <span class="cov0" title="0">{
        node, err := tq.First(ctx)
        if err != nil &amp;&amp; !IsNotFound(err) </span><span class="cov0" title="0">{
                panic(err)</span>
        }
        <span class="cov0" title="0">return node</span>
}

// FirstID returns the first Token ID from the query.
// Returns a *NotFoundError when no Token ID was found.
func (tq *TokenQuery) FirstID(ctx context.Context) (id string, err error) <span class="cov0" title="0">{
        var ids []string
        if ids, err = tq.Limit(1).IDs(setContextOp(ctx, tq.ctx, "FirstID")); err != nil </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov0" title="0">if len(ids) == 0 </span><span class="cov0" title="0">{
                err = &amp;NotFoundError{token.Label}
                return
        }</span>
        <span class="cov0" title="0">return ids[0], nil</span>
}

// FirstIDX is like FirstID, but panics if an error occurs.
func (tq *TokenQuery) FirstIDX(ctx context.Context) string <span class="cov0" title="0">{
        id, err := tq.FirstID(ctx)
        if err != nil &amp;&amp; !IsNotFound(err) </span><span class="cov0" title="0">{
                panic(err)</span>
        }
        <span class="cov0" title="0">return id</span>
}

// Only returns a single Token entity found by the query, ensuring it only returns one.
// Returns a *NotSingularError when more than one Token entity is found.
// Returns a *NotFoundError when no Token entities are found.
func (tq *TokenQuery) Only(ctx context.Context) (*Token, error) <span class="cov7" title="7">{
        nodes, err := tq.Limit(2).All(setContextOp(ctx, tq.ctx, "Only"))
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov7" title="7">switch len(nodes) </span>{
        case 1:<span class="cov6" title="5">
                return nodes[0], nil</span>
        case 0:<span class="cov3" title="2">
                return nil, &amp;NotFoundError{token.Label}</span>
        default:<span class="cov0" title="0">
                return nil, &amp;NotSingularError{token.Label}</span>
        }
}

// OnlyX is like Only, but panics if an error occurs.
func (tq *TokenQuery) OnlyX(ctx context.Context) *Token <span class="cov0" title="0">{
        node, err := tq.Only(ctx)
        if err != nil </span><span class="cov0" title="0">{
                panic(err)</span>
        }
        <span class="cov0" title="0">return node</span>
}

// OnlyID is like Only, but returns the only Token ID in the query.
// Returns a *NotSingularError when more than one Token ID is found.
// Returns a *NotFoundError when no entities are found.
func (tq *TokenQuery) OnlyID(ctx context.Context) (id string, err error) <span class="cov0" title="0">{
        var ids []string
        if ids, err = tq.Limit(2).IDs(setContextOp(ctx, tq.ctx, "OnlyID")); err != nil </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov0" title="0">switch len(ids) </span>{
        case 1:<span class="cov0" title="0">
                id = ids[0]</span>
        case 0:<span class="cov0" title="0">
                err = &amp;NotFoundError{token.Label}</span>
        default:<span class="cov0" title="0">
                err = &amp;NotSingularError{token.Label}</span>
        }
        <span class="cov0" title="0">return</span>
}

// OnlyIDX is like OnlyID, but panics if an error occurs.
func (tq *TokenQuery) OnlyIDX(ctx context.Context) string <span class="cov0" title="0">{
        id, err := tq.OnlyID(ctx)
        if err != nil </span><span class="cov0" title="0">{
                panic(err)</span>
        }
        <span class="cov0" title="0">return id</span>
}

// All executes the query and returns a list of Tokens.
func (tq *TokenQuery) All(ctx context.Context) ([]*Token, error) <span class="cov9" title="10">{
        ctx = setContextOp(ctx, tq.ctx, "All")
        if err := tq.prepareQuery(ctx); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov9" title="10">qr := querierAll[[]*Token, *TokenQuery]()
        return withInterceptors[[]*Token](ctx, tq, qr, tq.inters)</span>
}

// AllX is like All, but panics if an error occurs.
func (tq *TokenQuery) AllX(ctx context.Context) []*Token <span class="cov0" title="0">{
        nodes, err := tq.All(ctx)
        if err != nil </span><span class="cov0" title="0">{
                panic(err)</span>
        }
        <span class="cov0" title="0">return nodes</span>
}

// IDs executes the query and returns a list of Token IDs.
func (tq *TokenQuery) IDs(ctx context.Context) (ids []string, err error) <span class="cov0" title="0">{
        if tq.ctx.Unique == nil &amp;&amp; tq.path != nil </span><span class="cov0" title="0">{
                tq.Unique(true)
        }</span>
        <span class="cov0" title="0">ctx = setContextOp(ctx, tq.ctx, "IDs")
        if err = tq.Select(token.FieldID).Scan(ctx, &amp;ids); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return ids, nil</span>
}

// IDsX is like IDs, but panics if an error occurs.
func (tq *TokenQuery) IDsX(ctx context.Context) []string <span class="cov0" title="0">{
        ids, err := tq.IDs(ctx)
        if err != nil </span><span class="cov0" title="0">{
                panic(err)</span>
        }
        <span class="cov0" title="0">return ids</span>
}

// Count returns the count of the given query.
func (tq *TokenQuery) Count(ctx context.Context) (int, error) <span class="cov0" title="0">{
        ctx = setContextOp(ctx, tq.ctx, "Count")
        if err := tq.prepareQuery(ctx); err != nil </span><span class="cov0" title="0">{
                return 0, err
        }</span>
        <span class="cov0" title="0">return withInterceptors[int](ctx, tq, querierCount[*TokenQuery](), tq.inters)</span>
}

// CountX is like Count, but panics if an error occurs.
func (tq *TokenQuery) CountX(ctx context.Context) int <span class="cov0" title="0">{
        count, err := tq.Count(ctx)
        if err != nil </span><span class="cov0" title="0">{
                panic(err)</span>
        }
        <span class="cov0" title="0">return count</span>
}

// Exist returns true if the query has elements in the graph.
func (tq *TokenQuery) Exist(ctx context.Context) (bool, error) <span class="cov0" title="0">{
        ctx = setContextOp(ctx, tq.ctx, "Exist")
        switch _, err := tq.FirstID(ctx); </span>{
        case IsNotFound(err):<span class="cov0" title="0">
                return false, nil</span>
        case err != nil:<span class="cov0" title="0">
                return false, fmt.Errorf("ent: check existence: %w", err)</span>
        default:<span class="cov0" title="0">
                return true, nil</span>
        }
}

// ExistX is like Exist, but panics if an error occurs.
func (tq *TokenQuery) ExistX(ctx context.Context) bool <span class="cov0" title="0">{
        exist, err := tq.Exist(ctx)
        if err != nil </span><span class="cov0" title="0">{
                panic(err)</span>
        }
        <span class="cov0" title="0">return exist</span>
}

// Clone returns a duplicate of the TokenQuery builder, including all associated steps. It can be
// used to prepare common query builders and use them differently after the clone is made.
func (tq *TokenQuery) Clone() *TokenQuery <span class="cov0" title="0">{
        if tq == nil </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov0" title="0">return &amp;TokenQuery{
                config:     tq.config,
                ctx:        tq.ctx.Clone(),
                order:      append([]token.OrderOption{}, tq.order...),
                inters:     append([]Interceptor{}, tq.inters...),
                predicates: append([]predicate.Token{}, tq.predicates...),
                withUser:   tq.withUser.Clone(),
                // clone intermediate query.
                sql:  tq.sql.Clone(),
                path: tq.path,
        }</span>
}

// WithUser tells the query-builder to eager-load the nodes that are connected to
// the "user" edge. The optional arguments are used to configure the query builder of the edge.
func (tq *TokenQuery) WithUser(opts ...func(*UserQuery)) *TokenQuery <span class="cov0" title="0">{
        query := (&amp;UserClient{config: tq.config}).Query()
        for _, opt := range opts </span><span class="cov0" title="0">{
                opt(query)
        }</span>
        <span class="cov0" title="0">tq.withUser = query
        return tq</span>
}

// GroupBy is used to group vertices by one or more fields/columns.
// It is often used with aggregate functions, like: count, max, mean, min, sum.
//
// Example:
//
//        var v []struct {
//                Token string `json:"token,omitempty"`
//                Count int `json:"count,omitempty"`
//        }
//
//        client.Token.Query().
//                GroupBy(token.FieldToken).
//                Aggregate(ent.Count()).
//                Scan(ctx, &amp;v)
func (tq *TokenQuery) GroupBy(field string, fields ...string) *TokenGroupBy <span class="cov0" title="0">{
        tq.ctx.Fields = append([]string{field}, fields...)
        grbuild := &amp;TokenGroupBy{build: tq}
        grbuild.flds = &amp;tq.ctx.Fields
        grbuild.label = token.Label
        grbuild.scan = grbuild.Scan
        return grbuild
}</span>

// Select allows the selection one or more fields/columns for the given query,
// instead of selecting all fields in the entity.
//
// Example:
//
//        var v []struct {
//                Token string `json:"token,omitempty"`
//        }
//
//        client.Token.Query().
//                Select(token.FieldToken).
//                Scan(ctx, &amp;v)
func (tq *TokenQuery) Select(fields ...string) *TokenSelect <span class="cov0" title="0">{
        tq.ctx.Fields = append(tq.ctx.Fields, fields...)
        sbuild := &amp;TokenSelect{TokenQuery: tq}
        sbuild.label = token.Label
        sbuild.flds, sbuild.scan = &amp;tq.ctx.Fields, sbuild.Scan
        return sbuild
}</span>

// Aggregate returns a TokenSelect configured with the given aggregations.
func (tq *TokenQuery) Aggregate(fns ...AggregateFunc) *TokenSelect <span class="cov0" title="0">{
        return tq.Select().Aggregate(fns...)
}</span>

func (tq *TokenQuery) prepareQuery(ctx context.Context) error <span class="cov9" title="10">{
        for _, inter := range tq.inters </span><span class="cov0" title="0">{
                if inter == nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("ent: uninitialized interceptor (forgotten import ent/runtime?)")
                }</span>
                <span class="cov0" title="0">if trv, ok := inter.(Traverser); ok </span><span class="cov0" title="0">{
                        if err := trv.Traverse(ctx, tq); err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                }
        }
        <span class="cov9" title="10">for _, f := range tq.ctx.Fields </span><span class="cov0" title="0">{
                if !token.ValidColumn(f) </span><span class="cov0" title="0">{
                        return &amp;ValidationError{Name: f, err: fmt.Errorf("ent: invalid field %q for query", f)}
                }</span>
        }
        <span class="cov9" title="10">if tq.path != nil </span><span class="cov1" title="1">{
                prev, err := tq.path(ctx)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov1" title="1">tq.sql = prev</span>
        }
        <span class="cov9" title="10">return nil</span>
}

func (tq *TokenQuery) sqlAll(ctx context.Context, hooks ...queryHook) ([]*Token, error) <span class="cov9" title="10">{
        var (
                nodes       = []*Token{}
                withFKs     = tq.withFKs
                _spec       = tq.querySpec()
                loadedTypes = [1]bool{
                        tq.withUser != nil,
                }
        )
        if tq.withUser != nil </span><span class="cov0" title="0">{
                withFKs = true
        }</span>
        <span class="cov9" title="10">if withFKs </span><span class="cov0" title="0">{
                _spec.Node.Columns = append(_spec.Node.Columns, token.ForeignKeys...)
        }</span>
        <span class="cov9" title="10">_spec.ScanValues = func(columns []string) ([]any, error) </span><span class="cov7" title="7">{
                return (*Token).scanValues(nil, columns)
        }</span>
        <span class="cov9" title="10">_spec.Assign = func(columns []string, values []any) error </span><span class="cov7" title="7">{
                node := &amp;Token{config: tq.config}
                nodes = append(nodes, node)
                node.Edges.loadedTypes = loadedTypes
                return node.assignValues(columns, values)
        }</span>
        <span class="cov9" title="10">for i := range hooks </span><span class="cov0" title="0">{
                hooks[i](ctx, _spec)
        }</span>
        <span class="cov9" title="10">if err := sqlgraph.QueryNodes(ctx, tq.driver, _spec); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov9" title="10">if len(nodes) == 0 </span><span class="cov4" title="3">{
                return nodes, nil
        }</span>
        <span class="cov7" title="7">if query := tq.withUser; query != nil </span><span class="cov0" title="0">{
                if err := tq.loadUser(ctx, query, nodes, nil,
                        func(n *Token, e *User) </span><span class="cov0" title="0">{ n.Edges.User = e }</span>); err != nil <span class="cov0" title="0">{
                        return nil, err
                }</span>
        }
        <span class="cov7" title="7">return nodes, nil</span>
}

func (tq *TokenQuery) loadUser(ctx context.Context, query *UserQuery, nodes []*Token, init func(*Token), assign func(*Token, *User)) error <span class="cov0" title="0">{
        ids := make([]string, 0, len(nodes))
        nodeids := make(map[string][]*Token)
        for i := range nodes </span><span class="cov0" title="0">{
                if nodes[i].user_tokens == nil </span><span class="cov0" title="0">{
                        continue</span>
                }
                <span class="cov0" title="0">fk := *nodes[i].user_tokens
                if _, ok := nodeids[fk]; !ok </span><span class="cov0" title="0">{
                        ids = append(ids, fk)
                }</span>
                <span class="cov0" title="0">nodeids[fk] = append(nodeids[fk], nodes[i])</span>
        }
        <span class="cov0" title="0">if len(ids) == 0 </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov0" title="0">query.Where(user.IDIn(ids...))
        neighbors, err := query.All(ctx)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">for _, n := range neighbors </span><span class="cov0" title="0">{
                nodes, ok := nodeids[n.ID]
                if !ok </span><span class="cov0" title="0">{
                        return fmt.Errorf(`unexpected foreign-key "user_tokens" returned %v`, n.ID)
                }</span>
                <span class="cov0" title="0">for i := range nodes </span><span class="cov0" title="0">{
                        assign(nodes[i], n)
                }</span>
        }
        <span class="cov0" title="0">return nil</span>
}

func (tq *TokenQuery) sqlCount(ctx context.Context) (int, error) <span class="cov0" title="0">{
        _spec := tq.querySpec()
        _spec.Node.Columns = tq.ctx.Fields
        if len(tq.ctx.Fields) &gt; 0 </span><span class="cov0" title="0">{
                _spec.Unique = tq.ctx.Unique != nil &amp;&amp; *tq.ctx.Unique
        }</span>
        <span class="cov0" title="0">return sqlgraph.CountNodes(ctx, tq.driver, _spec)</span>
}

func (tq *TokenQuery) querySpec() *sqlgraph.QuerySpec <span class="cov9" title="10">{
        _spec := sqlgraph.NewQuerySpec(token.Table, token.Columns, sqlgraph.NewFieldSpec(token.FieldID, field.TypeString))
        _spec.From = tq.sql
        if unique := tq.ctx.Unique; unique != nil </span><span class="cov0" title="0">{
                _spec.Unique = *unique
        }</span> else<span class="cov9" title="10"> if tq.path != nil </span><span class="cov1" title="1">{
                _spec.Unique = true
        }</span>
        <span class="cov9" title="10">if fields := tq.ctx.Fields; len(fields) &gt; 0 </span><span class="cov0" title="0">{
                _spec.Node.Columns = make([]string, 0, len(fields))
                _spec.Node.Columns = append(_spec.Node.Columns, token.FieldID)
                for i := range fields </span><span class="cov0" title="0">{
                        if fields[i] != token.FieldID </span><span class="cov0" title="0">{
                                _spec.Node.Columns = append(_spec.Node.Columns, fields[i])
                        }</span>
                }
        }
        <span class="cov9" title="10">if ps := tq.predicates; len(ps) &gt; 0 </span><span class="cov8" title="9">{
                _spec.Predicate = func(selector *sql.Selector) </span><span class="cov8" title="9">{
                        for i := range ps </span><span class="cov10" title="13">{
                                ps[i](selector)
                        }</span>
                }
        }
        <span class="cov9" title="10">if limit := tq.ctx.Limit; limit != nil </span><span class="cov7" title="7">{
                _spec.Limit = *limit
        }</span>
        <span class="cov9" title="10">if offset := tq.ctx.Offset; offset != nil </span><span class="cov0" title="0">{
                _spec.Offset = *offset
        }</span>
        <span class="cov9" title="10">if ps := tq.order; len(ps) &gt; 0 </span><span class="cov0" title="0">{
                _spec.Order = func(selector *sql.Selector) </span><span class="cov0" title="0">{
                        for i := range ps </span><span class="cov0" title="0">{
                                ps[i](selector)
                        }</span>
                }
        }
        <span class="cov9" title="10">return _spec</span>
}

func (tq *TokenQuery) sqlQuery(ctx context.Context) *sql.Selector <span class="cov0" title="0">{
        builder := sql.Dialect(tq.driver.Dialect())
        t1 := builder.Table(token.Table)
        columns := tq.ctx.Fields
        if len(columns) == 0 </span><span class="cov0" title="0">{
                columns = token.Columns
        }</span>
        <span class="cov0" title="0">selector := builder.Select(t1.Columns(columns...)...).From(t1)
        if tq.sql != nil </span><span class="cov0" title="0">{
                selector = tq.sql
                selector.Select(selector.Columns(columns...)...)
        }</span>
        <span class="cov0" title="0">if tq.ctx.Unique != nil &amp;&amp; *tq.ctx.Unique </span><span class="cov0" title="0">{
                selector.Distinct()
        }</span>
        <span class="cov0" title="0">for _, p := range tq.predicates </span><span class="cov0" title="0">{
                p(selector)
        }</span>
        <span class="cov0" title="0">for _, p := range tq.order </span><span class="cov0" title="0">{
                p(selector)
        }</span>
        <span class="cov0" title="0">if offset := tq.ctx.Offset; offset != nil </span><span class="cov0" title="0">{
                // limit is mandatory for offset clause. We start
                // with default value, and override it below if needed.
                selector.Offset(*offset).Limit(math.MaxInt32)
        }</span>
        <span class="cov0" title="0">if limit := tq.ctx.Limit; limit != nil </span><span class="cov0" title="0">{
                selector.Limit(*limit)
        }</span>
        <span class="cov0" title="0">return selector</span>
}

// TokenGroupBy is the group-by builder for Token entities.
type TokenGroupBy struct {
        selector
        build *TokenQuery
}

// Aggregate adds the given aggregation functions to the group-by query.
func (tgb *TokenGroupBy) Aggregate(fns ...AggregateFunc) *TokenGroupBy <span class="cov0" title="0">{
        tgb.fns = append(tgb.fns, fns...)
        return tgb
}</span>

// Scan applies the selector query and scans the result into the given value.
func (tgb *TokenGroupBy) Scan(ctx context.Context, v any) error <span class="cov0" title="0">{
        ctx = setContextOp(ctx, tgb.build.ctx, "GroupBy")
        if err := tgb.build.prepareQuery(ctx); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">return scanWithInterceptors[*TokenQuery, *TokenGroupBy](ctx, tgb.build, tgb, tgb.build.inters, v)</span>
}

func (tgb *TokenGroupBy) sqlScan(ctx context.Context, root *TokenQuery, v any) error <span class="cov0" title="0">{
        selector := root.sqlQuery(ctx).Select()
        aggregation := make([]string, 0, len(tgb.fns))
        for _, fn := range tgb.fns </span><span class="cov0" title="0">{
                aggregation = append(aggregation, fn(selector))
        }</span>
        <span class="cov0" title="0">if len(selector.SelectedColumns()) == 0 </span><span class="cov0" title="0">{
                columns := make([]string, 0, len(*tgb.flds)+len(tgb.fns))
                for _, f := range *tgb.flds </span><span class="cov0" title="0">{
                        columns = append(columns, selector.C(f))
                }</span>
                <span class="cov0" title="0">columns = append(columns, aggregation...)
                selector.Select(columns...)</span>
        }
        <span class="cov0" title="0">selector.GroupBy(selector.Columns(*tgb.flds...)...)
        if err := selector.Err(); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">rows := &amp;sql.Rows{}
        query, args := selector.Query()
        if err := tgb.build.driver.Query(ctx, query, args, rows); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">defer rows.Close()
        return sql.ScanSlice(rows, v)</span>
}

// TokenSelect is the builder for selecting fields of Token entities.
type TokenSelect struct {
        *TokenQuery
        selector
}

// Aggregate adds the given aggregation functions to the selector query.
func (ts *TokenSelect) Aggregate(fns ...AggregateFunc) *TokenSelect <span class="cov0" title="0">{
        ts.fns = append(ts.fns, fns...)
        return ts
}</span>

// Scan applies the selector query and scans the result into the given value.
func (ts *TokenSelect) Scan(ctx context.Context, v any) error <span class="cov0" title="0">{
        ctx = setContextOp(ctx, ts.ctx, "Select")
        if err := ts.prepareQuery(ctx); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">return scanWithInterceptors[*TokenQuery, *TokenSelect](ctx, ts.TokenQuery, ts, ts.inters, v)</span>
}

func (ts *TokenSelect) sqlScan(ctx context.Context, root *TokenQuery, v any) error <span class="cov0" title="0">{
        selector := root.sqlQuery(ctx)
        aggregation := make([]string, 0, len(ts.fns))
        for _, fn := range ts.fns </span><span class="cov0" title="0">{
                aggregation = append(aggregation, fn(selector))
        }</span>
        <span class="cov0" title="0">switch n := len(*ts.selector.flds); </span>{
        case n == 0 &amp;&amp; len(aggregation) &gt; 0:<span class="cov0" title="0">
                selector.Select(aggregation...)</span>
        case n != 0 &amp;&amp; len(aggregation) &gt; 0:<span class="cov0" title="0">
                selector.AppendSelect(aggregation...)</span>
        }
        <span class="cov0" title="0">rows := &amp;sql.Rows{}
        query, args := selector.Query()
        if err := ts.driver.Query(ctx, query, args, rows); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">defer rows.Close()
        return sql.ScanSlice(rows, v)</span>
}
</pre>
		
		<pre class="file" id="file25" style="display: none">// Code generated by ent, DO NOT EDIT.

package ent

import (
        "auth/ent/predicate"
        "auth/ent/token"
        "auth/ent/user"
        "context"
        "errors"
        "fmt"
        "time"

        "entgo.io/ent/dialect/sql"
        "entgo.io/ent/dialect/sql/sqlgraph"
        "entgo.io/ent/schema/field"
)

// TokenUpdate is the builder for updating Token entities.
type TokenUpdate struct {
        config
        hooks    []Hook
        mutation *TokenMutation
}

// Where appends a list predicates to the TokenUpdate builder.
func (tu *TokenUpdate) Where(ps ...predicate.Token) *TokenUpdate <span class="cov7" title="4">{
        tu.mutation.Where(ps...)
        return tu
}</span>

// SetToken sets the "token" field.
func (tu *TokenUpdate) SetToken(s string) *TokenUpdate <span class="cov0" title="0">{
        tu.mutation.SetToken(s)
        return tu
}</span>

// SetNillableToken sets the "token" field if the given value is not nil.
func (tu *TokenUpdate) SetNillableToken(s *string) *TokenUpdate <span class="cov0" title="0">{
        if s != nil </span><span class="cov0" title="0">{
                tu.SetToken(*s)
        }</span>
        <span class="cov0" title="0">return tu</span>
}

// SetType sets the "type" field.
func (tu *TokenUpdate) SetType(t token.Type) *TokenUpdate <span class="cov0" title="0">{
        tu.mutation.SetType(t)
        return tu
}</span>

// SetNillableType sets the "type" field if the given value is not nil.
func (tu *TokenUpdate) SetNillableType(t *token.Type) *TokenUpdate <span class="cov0" title="0">{
        if t != nil </span><span class="cov0" title="0">{
                tu.SetType(*t)
        }</span>
        <span class="cov0" title="0">return tu</span>
}

// SetExpiresAt sets the "expires_at" field.
func (tu *TokenUpdate) SetExpiresAt(t time.Time) *TokenUpdate <span class="cov0" title="0">{
        tu.mutation.SetExpiresAt(t)
        return tu
}</span>

// SetNillableExpiresAt sets the "expires_at" field if the given value is not nil.
func (tu *TokenUpdate) SetNillableExpiresAt(t *time.Time) *TokenUpdate <span class="cov0" title="0">{
        if t != nil </span><span class="cov0" title="0">{
                tu.SetExpiresAt(*t)
        }</span>
        <span class="cov0" title="0">return tu</span>
}

// SetRevoked sets the "revoked" field.
func (tu *TokenUpdate) SetRevoked(b bool) *TokenUpdate <span class="cov7" title="4">{
        tu.mutation.SetRevoked(b)
        return tu
}</span>

// SetNillableRevoked sets the "revoked" field if the given value is not nil.
func (tu *TokenUpdate) SetNillableRevoked(b *bool) *TokenUpdate <span class="cov0" title="0">{
        if b != nil </span><span class="cov0" title="0">{
                tu.SetRevoked(*b)
        }</span>
        <span class="cov0" title="0">return tu</span>
}

// SetCreatedAt sets the "created_at" field.
func (tu *TokenUpdate) SetCreatedAt(t time.Time) *TokenUpdate <span class="cov0" title="0">{
        tu.mutation.SetCreatedAt(t)
        return tu
}</span>

// SetNillableCreatedAt sets the "created_at" field if the given value is not nil.
func (tu *TokenUpdate) SetNillableCreatedAt(t *time.Time) *TokenUpdate <span class="cov0" title="0">{
        if t != nil </span><span class="cov0" title="0">{
                tu.SetCreatedAt(*t)
        }</span>
        <span class="cov0" title="0">return tu</span>
}

// SetUpdatedAt sets the "updated_at" field.
func (tu *TokenUpdate) SetUpdatedAt(t time.Time) *TokenUpdate <span class="cov0" title="0">{
        tu.mutation.SetUpdatedAt(t)
        return tu
}</span>

// SetUserID sets the "user" edge to the User entity by ID.
func (tu *TokenUpdate) SetUserID(id string) *TokenUpdate <span class="cov0" title="0">{
        tu.mutation.SetUserID(id)
        return tu
}</span>

// SetUser sets the "user" edge to the User entity.
func (tu *TokenUpdate) SetUser(u *User) *TokenUpdate <span class="cov0" title="0">{
        return tu.SetUserID(u.ID)
}</span>

// Mutation returns the TokenMutation object of the builder.
func (tu *TokenUpdate) Mutation() *TokenMutation <span class="cov0" title="0">{
        return tu.mutation
}</span>

// ClearUser clears the "user" edge to the User entity.
func (tu *TokenUpdate) ClearUser() *TokenUpdate <span class="cov0" title="0">{
        tu.mutation.ClearUser()
        return tu
}</span>

// Save executes the query and returns the number of nodes affected by the update operation.
func (tu *TokenUpdate) Save(ctx context.Context) (int, error) <span class="cov7" title="4">{
        tu.defaults()
        return withHooks(ctx, tu.sqlSave, tu.mutation, tu.hooks)
}</span>

// SaveX is like Save, but panics if an error occurs.
func (tu *TokenUpdate) SaveX(ctx context.Context) int <span class="cov0" title="0">{
        affected, err := tu.Save(ctx)
        if err != nil </span><span class="cov0" title="0">{
                panic(err)</span>
        }
        <span class="cov0" title="0">return affected</span>
}

// Exec executes the query.
func (tu *TokenUpdate) Exec(ctx context.Context) error <span class="cov0" title="0">{
        _, err := tu.Save(ctx)
        return err
}</span>

// ExecX is like Exec, but panics if an error occurs.
func (tu *TokenUpdate) ExecX(ctx context.Context) <span class="cov0" title="0">{
        if err := tu.Exec(ctx); err != nil </span><span class="cov0" title="0">{
                panic(err)</span>
        }
}

// defaults sets the default values of the builder before save.
func (tu *TokenUpdate) defaults() <span class="cov7" title="4">{
        if _, ok := tu.mutation.UpdatedAt(); !ok </span><span class="cov7" title="4">{
                v := token.UpdateDefaultUpdatedAt()
                tu.mutation.SetUpdatedAt(v)
        }</span>
}

// check runs all checks and user-defined validators on the builder.
func (tu *TokenUpdate) check() error <span class="cov7" title="4">{
        if v, ok := tu.mutation.GetType(); ok </span><span class="cov0" title="0">{
                if err := token.TypeValidator(v); err != nil </span><span class="cov0" title="0">{
                        return &amp;ValidationError{Name: "type", err: fmt.Errorf(`ent: validator failed for field "Token.type": %w`, err)}
                }</span>
        }
        <span class="cov7" title="4">if _, ok := tu.mutation.UserID(); tu.mutation.UserCleared() &amp;&amp; !ok </span><span class="cov0" title="0">{
                return errors.New(`ent: clearing a required unique edge "Token.user"`)
        }</span>
        <span class="cov7" title="4">return nil</span>
}

func (tu *TokenUpdate) sqlSave(ctx context.Context) (n int, err error) <span class="cov7" title="4">{
        if err := tu.check(); err != nil </span><span class="cov0" title="0">{
                return n, err
        }</span>
        <span class="cov7" title="4">_spec := sqlgraph.NewUpdateSpec(token.Table, token.Columns, sqlgraph.NewFieldSpec(token.FieldID, field.TypeString))
        if ps := tu.mutation.predicates; len(ps) &gt; 0 </span><span class="cov7" title="4">{
                _spec.Predicate = func(selector *sql.Selector) </span><span class="cov7" title="4">{
                        for i := range ps </span><span class="cov10" title="8">{
                                ps[i](selector)
                        }</span>
                }
        }
        <span class="cov7" title="4">if value, ok := tu.mutation.Token(); ok </span><span class="cov0" title="0">{
                _spec.SetField(token.FieldToken, field.TypeString, value)
        }</span>
        <span class="cov7" title="4">if value, ok := tu.mutation.GetType(); ok </span><span class="cov0" title="0">{
                _spec.SetField(token.FieldType, field.TypeEnum, value)
        }</span>
        <span class="cov7" title="4">if value, ok := tu.mutation.ExpiresAt(); ok </span><span class="cov0" title="0">{
                _spec.SetField(token.FieldExpiresAt, field.TypeTime, value)
        }</span>
        <span class="cov7" title="4">if value, ok := tu.mutation.Revoked(); ok </span><span class="cov7" title="4">{
                _spec.SetField(token.FieldRevoked, field.TypeBool, value)
        }</span>
        <span class="cov7" title="4">if value, ok := tu.mutation.CreatedAt(); ok </span><span class="cov0" title="0">{
                _spec.SetField(token.FieldCreatedAt, field.TypeTime, value)
        }</span>
        <span class="cov7" title="4">if value, ok := tu.mutation.UpdatedAt(); ok </span><span class="cov7" title="4">{
                _spec.SetField(token.FieldUpdatedAt, field.TypeTime, value)
        }</span>
        <span class="cov7" title="4">if tu.mutation.UserCleared() </span><span class="cov0" title="0">{
                edge := &amp;sqlgraph.EdgeSpec{
                        Rel:     sqlgraph.M2O,
                        Inverse: true,
                        Table:   token.UserTable,
                        Columns: []string{token.UserColumn},
                        Bidi:    false,
                        Target: &amp;sqlgraph.EdgeTarget{
                                IDSpec: sqlgraph.NewFieldSpec(user.FieldID, field.TypeString),
                        },
                }
                _spec.Edges.Clear = append(_spec.Edges.Clear, edge)
        }</span>
        <span class="cov7" title="4">if nodes := tu.mutation.UserIDs(); len(nodes) &gt; 0 </span><span class="cov0" title="0">{
                edge := &amp;sqlgraph.EdgeSpec{
                        Rel:     sqlgraph.M2O,
                        Inverse: true,
                        Table:   token.UserTable,
                        Columns: []string{token.UserColumn},
                        Bidi:    false,
                        Target: &amp;sqlgraph.EdgeTarget{
                                IDSpec: sqlgraph.NewFieldSpec(user.FieldID, field.TypeString),
                        },
                }
                for _, k := range nodes </span><span class="cov0" title="0">{
                        edge.Target.Nodes = append(edge.Target.Nodes, k)
                }</span>
                <span class="cov0" title="0">_spec.Edges.Add = append(_spec.Edges.Add, edge)</span>
        }
        <span class="cov7" title="4">if n, err = sqlgraph.UpdateNodes(ctx, tu.driver, _spec); err != nil </span><span class="cov0" title="0">{
                if _, ok := err.(*sqlgraph.NotFoundError); ok </span><span class="cov0" title="0">{
                        err = &amp;NotFoundError{token.Label}
                }</span> else<span class="cov0" title="0"> if sqlgraph.IsConstraintError(err) </span><span class="cov0" title="0">{
                        err = &amp;ConstraintError{msg: err.Error(), wrap: err}
                }</span>
                <span class="cov0" title="0">return 0, err</span>
        }
        <span class="cov7" title="4">tu.mutation.done = true
        return n, nil</span>
}

// TokenUpdateOne is the builder for updating a single Token entity.
type TokenUpdateOne struct {
        config
        fields   []string
        hooks    []Hook
        mutation *TokenMutation
}

// SetToken sets the "token" field.
func (tuo *TokenUpdateOne) SetToken(s string) *TokenUpdateOne <span class="cov0" title="0">{
        tuo.mutation.SetToken(s)
        return tuo
}</span>

// SetNillableToken sets the "token" field if the given value is not nil.
func (tuo *TokenUpdateOne) SetNillableToken(s *string) *TokenUpdateOne <span class="cov0" title="0">{
        if s != nil </span><span class="cov0" title="0">{
                tuo.SetToken(*s)
        }</span>
        <span class="cov0" title="0">return tuo</span>
}

// SetType sets the "type" field.
func (tuo *TokenUpdateOne) SetType(t token.Type) *TokenUpdateOne <span class="cov0" title="0">{
        tuo.mutation.SetType(t)
        return tuo
}</span>

// SetNillableType sets the "type" field if the given value is not nil.
func (tuo *TokenUpdateOne) SetNillableType(t *token.Type) *TokenUpdateOne <span class="cov0" title="0">{
        if t != nil </span><span class="cov0" title="0">{
                tuo.SetType(*t)
        }</span>
        <span class="cov0" title="0">return tuo</span>
}

// SetExpiresAt sets the "expires_at" field.
func (tuo *TokenUpdateOne) SetExpiresAt(t time.Time) *TokenUpdateOne <span class="cov0" title="0">{
        tuo.mutation.SetExpiresAt(t)
        return tuo
}</span>

// SetNillableExpiresAt sets the "expires_at" field if the given value is not nil.
func (tuo *TokenUpdateOne) SetNillableExpiresAt(t *time.Time) *TokenUpdateOne <span class="cov0" title="0">{
        if t != nil </span><span class="cov0" title="0">{
                tuo.SetExpiresAt(*t)
        }</span>
        <span class="cov0" title="0">return tuo</span>
}

// SetRevoked sets the "revoked" field.
func (tuo *TokenUpdateOne) SetRevoked(b bool) *TokenUpdateOne <span class="cov1" title="1">{
        tuo.mutation.SetRevoked(b)
        return tuo
}</span>

// SetNillableRevoked sets the "revoked" field if the given value is not nil.
func (tuo *TokenUpdateOne) SetNillableRevoked(b *bool) *TokenUpdateOne <span class="cov0" title="0">{
        if b != nil </span><span class="cov0" title="0">{
                tuo.SetRevoked(*b)
        }</span>
        <span class="cov0" title="0">return tuo</span>
}

// SetCreatedAt sets the "created_at" field.
func (tuo *TokenUpdateOne) SetCreatedAt(t time.Time) *TokenUpdateOne <span class="cov0" title="0">{
        tuo.mutation.SetCreatedAt(t)
        return tuo
}</span>

// SetNillableCreatedAt sets the "created_at" field if the given value is not nil.
func (tuo *TokenUpdateOne) SetNillableCreatedAt(t *time.Time) *TokenUpdateOne <span class="cov0" title="0">{
        if t != nil </span><span class="cov0" title="0">{
                tuo.SetCreatedAt(*t)
        }</span>
        <span class="cov0" title="0">return tuo</span>
}

// SetUpdatedAt sets the "updated_at" field.
func (tuo *TokenUpdateOne) SetUpdatedAt(t time.Time) *TokenUpdateOne <span class="cov0" title="0">{
        tuo.mutation.SetUpdatedAt(t)
        return tuo
}</span>

// SetUserID sets the "user" edge to the User entity by ID.
func (tuo *TokenUpdateOne) SetUserID(id string) *TokenUpdateOne <span class="cov0" title="0">{
        tuo.mutation.SetUserID(id)
        return tuo
}</span>

// SetUser sets the "user" edge to the User entity.
func (tuo *TokenUpdateOne) SetUser(u *User) *TokenUpdateOne <span class="cov0" title="0">{
        return tuo.SetUserID(u.ID)
}</span>

// Mutation returns the TokenMutation object of the builder.
func (tuo *TokenUpdateOne) Mutation() *TokenMutation <span class="cov0" title="0">{
        return tuo.mutation
}</span>

// ClearUser clears the "user" edge to the User entity.
func (tuo *TokenUpdateOne) ClearUser() *TokenUpdateOne <span class="cov0" title="0">{
        tuo.mutation.ClearUser()
        return tuo
}</span>

// Where appends a list predicates to the TokenUpdate builder.
func (tuo *TokenUpdateOne) Where(ps ...predicate.Token) *TokenUpdateOne <span class="cov0" title="0">{
        tuo.mutation.Where(ps...)
        return tuo
}</span>

// Select allows selecting one or more fields (columns) of the returned entity.
// The default is selecting all fields defined in the entity schema.
func (tuo *TokenUpdateOne) Select(field string, fields ...string) *TokenUpdateOne <span class="cov0" title="0">{
        tuo.fields = append([]string{field}, fields...)
        return tuo
}</span>

// Save executes the query and returns the updated Token entity.
func (tuo *TokenUpdateOne) Save(ctx context.Context) (*Token, error) <span class="cov1" title="1">{
        tuo.defaults()
        return withHooks(ctx, tuo.sqlSave, tuo.mutation, tuo.hooks)
}</span>

// SaveX is like Save, but panics if an error occurs.
func (tuo *TokenUpdateOne) SaveX(ctx context.Context) *Token <span class="cov0" title="0">{
        node, err := tuo.Save(ctx)
        if err != nil </span><span class="cov0" title="0">{
                panic(err)</span>
        }
        <span class="cov0" title="0">return node</span>
}

// Exec executes the query on the entity.
func (tuo *TokenUpdateOne) Exec(ctx context.Context) error <span class="cov0" title="0">{
        _, err := tuo.Save(ctx)
        return err
}</span>

// ExecX is like Exec, but panics if an error occurs.
func (tuo *TokenUpdateOne) ExecX(ctx context.Context) <span class="cov0" title="0">{
        if err := tuo.Exec(ctx); err != nil </span><span class="cov0" title="0">{
                panic(err)</span>
        }
}

// defaults sets the default values of the builder before save.
func (tuo *TokenUpdateOne) defaults() <span class="cov1" title="1">{
        if _, ok := tuo.mutation.UpdatedAt(); !ok </span><span class="cov1" title="1">{
                v := token.UpdateDefaultUpdatedAt()
                tuo.mutation.SetUpdatedAt(v)
        }</span>
}

// check runs all checks and user-defined validators on the builder.
func (tuo *TokenUpdateOne) check() error <span class="cov1" title="1">{
        if v, ok := tuo.mutation.GetType(); ok </span><span class="cov0" title="0">{
                if err := token.TypeValidator(v); err != nil </span><span class="cov0" title="0">{
                        return &amp;ValidationError{Name: "type", err: fmt.Errorf(`ent: validator failed for field "Token.type": %w`, err)}
                }</span>
        }
        <span class="cov1" title="1">if _, ok := tuo.mutation.UserID(); tuo.mutation.UserCleared() &amp;&amp; !ok </span><span class="cov0" title="0">{
                return errors.New(`ent: clearing a required unique edge "Token.user"`)
        }</span>
        <span class="cov1" title="1">return nil</span>
}

func (tuo *TokenUpdateOne) sqlSave(ctx context.Context) (_node *Token, err error) <span class="cov1" title="1">{
        if err := tuo.check(); err != nil </span><span class="cov0" title="0">{
                return _node, err
        }</span>
        <span class="cov1" title="1">_spec := sqlgraph.NewUpdateSpec(token.Table, token.Columns, sqlgraph.NewFieldSpec(token.FieldID, field.TypeString))
        id, ok := tuo.mutation.ID()
        if !ok </span><span class="cov0" title="0">{
                return nil, &amp;ValidationError{Name: "id", err: errors.New(`ent: missing "Token.id" for update`)}
        }</span>
        <span class="cov1" title="1">_spec.Node.ID.Value = id
        if fields := tuo.fields; len(fields) &gt; 0 </span><span class="cov0" title="0">{
                _spec.Node.Columns = make([]string, 0, len(fields))
                _spec.Node.Columns = append(_spec.Node.Columns, token.FieldID)
                for _, f := range fields </span><span class="cov0" title="0">{
                        if !token.ValidColumn(f) </span><span class="cov0" title="0">{
                                return nil, &amp;ValidationError{Name: f, err: fmt.Errorf("ent: invalid field %q for query", f)}
                        }</span>
                        <span class="cov0" title="0">if f != token.FieldID </span><span class="cov0" title="0">{
                                _spec.Node.Columns = append(_spec.Node.Columns, f)
                        }</span>
                }
        }
        <span class="cov1" title="1">if ps := tuo.mutation.predicates; len(ps) &gt; 0 </span><span class="cov0" title="0">{
                _spec.Predicate = func(selector *sql.Selector) </span><span class="cov0" title="0">{
                        for i := range ps </span><span class="cov0" title="0">{
                                ps[i](selector)
                        }</span>
                }
        }
        <span class="cov1" title="1">if value, ok := tuo.mutation.Token(); ok </span><span class="cov0" title="0">{
                _spec.SetField(token.FieldToken, field.TypeString, value)
        }</span>
        <span class="cov1" title="1">if value, ok := tuo.mutation.GetType(); ok </span><span class="cov0" title="0">{
                _spec.SetField(token.FieldType, field.TypeEnum, value)
        }</span>
        <span class="cov1" title="1">if value, ok := tuo.mutation.ExpiresAt(); ok </span><span class="cov0" title="0">{
                _spec.SetField(token.FieldExpiresAt, field.TypeTime, value)
        }</span>
        <span class="cov1" title="1">if value, ok := tuo.mutation.Revoked(); ok </span><span class="cov1" title="1">{
                _spec.SetField(token.FieldRevoked, field.TypeBool, value)
        }</span>
        <span class="cov1" title="1">if value, ok := tuo.mutation.CreatedAt(); ok </span><span class="cov0" title="0">{
                _spec.SetField(token.FieldCreatedAt, field.TypeTime, value)
        }</span>
        <span class="cov1" title="1">if value, ok := tuo.mutation.UpdatedAt(); ok </span><span class="cov1" title="1">{
                _spec.SetField(token.FieldUpdatedAt, field.TypeTime, value)
        }</span>
        <span class="cov1" title="1">if tuo.mutation.UserCleared() </span><span class="cov0" title="0">{
                edge := &amp;sqlgraph.EdgeSpec{
                        Rel:     sqlgraph.M2O,
                        Inverse: true,
                        Table:   token.UserTable,
                        Columns: []string{token.UserColumn},
                        Bidi:    false,
                        Target: &amp;sqlgraph.EdgeTarget{
                                IDSpec: sqlgraph.NewFieldSpec(user.FieldID, field.TypeString),
                        },
                }
                _spec.Edges.Clear = append(_spec.Edges.Clear, edge)
        }</span>
        <span class="cov1" title="1">if nodes := tuo.mutation.UserIDs(); len(nodes) &gt; 0 </span><span class="cov0" title="0">{
                edge := &amp;sqlgraph.EdgeSpec{
                        Rel:     sqlgraph.M2O,
                        Inverse: true,
                        Table:   token.UserTable,
                        Columns: []string{token.UserColumn},
                        Bidi:    false,
                        Target: &amp;sqlgraph.EdgeTarget{
                                IDSpec: sqlgraph.NewFieldSpec(user.FieldID, field.TypeString),
                        },
                }
                for _, k := range nodes </span><span class="cov0" title="0">{
                        edge.Target.Nodes = append(edge.Target.Nodes, k)
                }</span>
                <span class="cov0" title="0">_spec.Edges.Add = append(_spec.Edges.Add, edge)</span>
        }
        <span class="cov1" title="1">_node = &amp;Token{config: tuo.config}
        _spec.Assign = _node.assignValues
        _spec.ScanValues = _node.scanValues
        if err = sqlgraph.UpdateNode(ctx, tuo.driver, _spec); err != nil </span><span class="cov0" title="0">{
                if _, ok := err.(*sqlgraph.NotFoundError); ok </span><span class="cov0" title="0">{
                        err = &amp;NotFoundError{token.Label}
                }</span> else<span class="cov0" title="0"> if sqlgraph.IsConstraintError(err) </span><span class="cov0" title="0">{
                        err = &amp;ConstraintError{msg: err.Error(), wrap: err}
                }</span>
                <span class="cov0" title="0">return nil, err</span>
        }
        <span class="cov1" title="1">tuo.mutation.done = true
        return _node, nil</span>
}
</pre>
		
		<pre class="file" id="file26" style="display: none">// Code generated by ent, DO NOT EDIT.

package ent

import (
        "context"
        "sync"

        "entgo.io/ent/dialect"
)

// Tx is a transactional client that is created by calling Client.Tx().
type Tx struct {
        config
        // Role is the client for interacting with the Role builders.
        Role *RoleClient
        // Token is the client for interacting with the Token builders.
        Token *TokenClient
        // User is the client for interacting with the User builders.
        User *UserClient

        // lazily loaded.
        client     *Client
        clientOnce sync.Once
        // ctx lives for the life of the transaction. It is
        // the same context used by the underlying connection.
        ctx context.Context
}

type (
        // Committer is the interface that wraps the Commit method.
        Committer interface {
                Commit(context.Context, *Tx) error
        }

        // The CommitFunc type is an adapter to allow the use of ordinary
        // function as a Committer. If f is a function with the appropriate
        // signature, CommitFunc(f) is a Committer that calls f.
        CommitFunc func(context.Context, *Tx) error

        // CommitHook defines the "commit middleware". A function that gets a Committer
        // and returns a Committer. For example:
        //
        //        hook := func(next ent.Committer) ent.Committer {
        //                return ent.CommitFunc(func(ctx context.Context, tx *ent.Tx) error {
        //                        // Do some stuff before.
        //                        if err := next.Commit(ctx, tx); err != nil {
        //                                return err
        //                        }
        //                        // Do some stuff after.
        //                        return nil
        //                })
        //        }
        //
        CommitHook func(Committer) Committer
)

// Commit calls f(ctx, m).
func (f CommitFunc) Commit(ctx context.Context, tx *Tx) error <span class="cov0" title="0">{
        return f(ctx, tx)
}</span>

// Commit commits the transaction.
func (tx *Tx) Commit() error <span class="cov0" title="0">{
        txDriver := tx.config.driver.(*txDriver)
        var fn Committer = CommitFunc(func(context.Context, *Tx) error </span><span class="cov0" title="0">{
                return txDriver.tx.Commit()
        }</span>)
        <span class="cov0" title="0">txDriver.mu.Lock()
        hooks := append([]CommitHook(nil), txDriver.onCommit...)
        txDriver.mu.Unlock()
        for i := len(hooks) - 1; i &gt;= 0; i-- </span><span class="cov0" title="0">{
                fn = hooks[i](fn)
        }</span>
        <span class="cov0" title="0">return fn.Commit(tx.ctx, tx)</span>
}

// OnCommit adds a hook to call on commit.
func (tx *Tx) OnCommit(f CommitHook) <span class="cov0" title="0">{
        txDriver := tx.config.driver.(*txDriver)
        txDriver.mu.Lock()
        txDriver.onCommit = append(txDriver.onCommit, f)
        txDriver.mu.Unlock()
}</span>

type (
        // Rollbacker is the interface that wraps the Rollback method.
        Rollbacker interface {
                Rollback(context.Context, *Tx) error
        }

        // The RollbackFunc type is an adapter to allow the use of ordinary
        // function as a Rollbacker. If f is a function with the appropriate
        // signature, RollbackFunc(f) is a Rollbacker that calls f.
        RollbackFunc func(context.Context, *Tx) error

        // RollbackHook defines the "rollback middleware". A function that gets a Rollbacker
        // and returns a Rollbacker. For example:
        //
        //        hook := func(next ent.Rollbacker) ent.Rollbacker {
        //                return ent.RollbackFunc(func(ctx context.Context, tx *ent.Tx) error {
        //                        // Do some stuff before.
        //                        if err := next.Rollback(ctx, tx); err != nil {
        //                                return err
        //                        }
        //                        // Do some stuff after.
        //                        return nil
        //                })
        //        }
        //
        RollbackHook func(Rollbacker) Rollbacker
)

// Rollback calls f(ctx, m).
func (f RollbackFunc) Rollback(ctx context.Context, tx *Tx) error <span class="cov0" title="0">{
        return f(ctx, tx)
}</span>

// Rollback rollbacks the transaction.
func (tx *Tx) Rollback() error <span class="cov0" title="0">{
        txDriver := tx.config.driver.(*txDriver)
        var fn Rollbacker = RollbackFunc(func(context.Context, *Tx) error </span><span class="cov0" title="0">{
                return txDriver.tx.Rollback()
        }</span>)
        <span class="cov0" title="0">txDriver.mu.Lock()
        hooks := append([]RollbackHook(nil), txDriver.onRollback...)
        txDriver.mu.Unlock()
        for i := len(hooks) - 1; i &gt;= 0; i-- </span><span class="cov0" title="0">{
                fn = hooks[i](fn)
        }</span>
        <span class="cov0" title="0">return fn.Rollback(tx.ctx, tx)</span>
}

// OnRollback adds a hook to call on rollback.
func (tx *Tx) OnRollback(f RollbackHook) <span class="cov0" title="0">{
        txDriver := tx.config.driver.(*txDriver)
        txDriver.mu.Lock()
        txDriver.onRollback = append(txDriver.onRollback, f)
        txDriver.mu.Unlock()
}</span>

// Client returns a Client that binds to current transaction.
func (tx *Tx) Client() *Client <span class="cov0" title="0">{
        tx.clientOnce.Do(func() </span><span class="cov0" title="0">{
                tx.client = &amp;Client{config: tx.config}
                tx.client.init()
        }</span>)
        <span class="cov0" title="0">return tx.client</span>
}

func (tx *Tx) init() <span class="cov0" title="0">{
        tx.Role = NewRoleClient(tx.config)
        tx.Token = NewTokenClient(tx.config)
        tx.User = NewUserClient(tx.config)
}</span>

// txDriver wraps the given dialect.Tx with a nop dialect.Driver implementation.
// The idea is to support transactions without adding any extra code to the builders.
// When a builder calls to driver.Tx(), it gets the same dialect.Tx instance.
// Commit and Rollback are nop for the internal builders and the user must call one
// of them in order to commit or rollback the transaction.
//
// If a closed transaction is embedded in one of the generated entities, and the entity
// applies a query, for example: Role.QueryXXX(), the query will be executed
// through the driver which created this transaction.
//
// Note that txDriver is not goroutine safe.
type txDriver struct {
        // the driver we started the transaction from.
        drv dialect.Driver
        // tx is the underlying transaction.
        tx dialect.Tx
        // completion hooks.
        mu         sync.Mutex
        onCommit   []CommitHook
        onRollback []RollbackHook
}

// newTx creates a new transactional driver.
func newTx(ctx context.Context, drv dialect.Driver) (*txDriver, error) <span class="cov0" title="0">{
        tx, err := drv.Tx(ctx)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return &amp;txDriver{tx: tx, drv: drv}, nil</span>
}

// Tx returns the transaction wrapper (txDriver) to avoid Commit or Rollback calls
// from the internal builders. Should be called only by the internal builders.
func (tx *txDriver) Tx(context.Context) (dialect.Tx, error) <span class="cov0" title="0">{ return tx, nil }</span>

// Dialect returns the dialect of the driver we started the transaction from.
func (tx *txDriver) Dialect() string <span class="cov0" title="0">{ return tx.drv.Dialect() }</span>

// Close is a nop close.
func (*txDriver) Close() error <span class="cov0" title="0">{ return nil }</span>

// Commit is a nop commit for the internal builders.
// User must call `Tx.Commit` in order to commit the transaction.
func (*txDriver) Commit() error <span class="cov0" title="0">{ return nil }</span>

// Rollback is a nop rollback for the internal builders.
// User must call `Tx.Rollback` in order to rollback the transaction.
func (*txDriver) Rollback() error <span class="cov0" title="0">{ return nil }</span>

// Exec calls tx.Exec.
func (tx *txDriver) Exec(ctx context.Context, query string, args, v any) error <span class="cov0" title="0">{
        return tx.tx.Exec(ctx, query, args, v)
}</span>

// Query calls tx.Query.
func (tx *txDriver) Query(ctx context.Context, query string, args, v any) error <span class="cov0" title="0">{
        return tx.tx.Query(ctx, query, args, v)
}</span>

var _ dialect.Driver = (*txDriver)(nil)
</pre>
		
		<pre class="file" id="file27" style="display: none">// Code generated by ent, DO NOT EDIT.

package ent

import (
        "auth/ent/user"
        "fmt"
        "strings"
        "time"

        "entgo.io/ent"
        "entgo.io/ent/dialect/sql"
)

// User is the model entity for the User schema.
type User struct {
        config `json:"-"`
        // ID of the ent.
        ID string `json:"id,omitempty"`
        // Username holds the value of the "username" field.
        Username string `json:"username,omitempty"`
        // Email holds the value of the "email" field.
        Email string `json:"email,omitempty"`
        // Password holds the value of the "password" field.
        Password string `json:"password,omitempty"`
        // CreatedAt holds the value of the "created_at" field.
        CreatedAt time.Time `json:"created_at,omitempty"`
        // UpdatedAt holds the value of the "updated_at" field.
        UpdatedAt time.Time `json:"updated_at,omitempty"`
        // Edges holds the relations/edges for other nodes in the graph.
        // The values are being populated by the UserQuery when eager-loading is set.
        Edges        UserEdges `json:"edges"`
        selectValues sql.SelectValues
}

// UserEdges holds the relations/edges for other nodes in the graph.
type UserEdges struct {
        // Roles holds the value of the roles edge.
        Roles []*Role `json:"roles,omitempty"`
        // Tokens holds the value of the tokens edge.
        Tokens []*Token `json:"tokens,omitempty"`
        // loadedTypes holds the information for reporting if a
        // type was loaded (or requested) in eager-loading or not.
        loadedTypes [2]bool
}

// RolesOrErr returns the Roles value or an error if the edge
// was not loaded in eager-loading.
func (e UserEdges) RolesOrErr() ([]*Role, error) <span class="cov0" title="0">{
        if e.loadedTypes[0] </span><span class="cov0" title="0">{
                return e.Roles, nil
        }</span>
        <span class="cov0" title="0">return nil, &amp;NotLoadedError{edge: "roles"}</span>
}

// TokensOrErr returns the Tokens value or an error if the edge
// was not loaded in eager-loading.
func (e UserEdges) TokensOrErr() ([]*Token, error) <span class="cov0" title="0">{
        if e.loadedTypes[1] </span><span class="cov0" title="0">{
                return e.Tokens, nil
        }</span>
        <span class="cov0" title="0">return nil, &amp;NotLoadedError{edge: "tokens"}</span>
}

// scanValues returns the types for scanning values from sql.Rows.
func (*User) scanValues(columns []string) ([]any, error) <span class="cov7" title="41">{
        values := make([]any, len(columns))
        for i := range columns </span><span class="cov10" title="246">{
                switch columns[i] </span>{
                case user.FieldID, user.FieldUsername, user.FieldEmail, user.FieldPassword:<span class="cov9" title="164">
                        values[i] = new(sql.NullString)</span>
                case user.FieldCreatedAt, user.FieldUpdatedAt:<span class="cov8" title="82">
                        values[i] = new(sql.NullTime)</span>
                default:<span class="cov0" title="0">
                        values[i] = new(sql.UnknownType)</span>
                }
        }
        <span class="cov7" title="41">return values, nil</span>
}

// assignValues assigns the values that were returned from sql.Rows (after scanning)
// to the User fields.
func (u *User) assignValues(columns []string, values []any) error <span class="cov7" title="41">{
        if m, n := len(values), len(columns); m &lt; n </span><span class="cov0" title="0">{
                return fmt.Errorf("mismatch number of scan values: %d != %d", m, n)
        }</span>
        <span class="cov7" title="41">for i := range columns </span><span class="cov10" title="246">{
                switch columns[i] </span>{
                case user.FieldID:<span class="cov7" title="41">
                        if value, ok := values[i].(*sql.NullString); !ok </span><span class="cov0" title="0">{
                                return fmt.Errorf("unexpected type %T for field id", values[i])
                        }</span> else<span class="cov7" title="41"> if value.Valid </span><span class="cov7" title="41">{
                                u.ID = value.String
                        }</span>
                case user.FieldUsername:<span class="cov7" title="41">
                        if value, ok := values[i].(*sql.NullString); !ok </span><span class="cov0" title="0">{
                                return fmt.Errorf("unexpected type %T for field username", values[i])
                        }</span> else<span class="cov7" title="41"> if value.Valid </span><span class="cov7" title="41">{
                                u.Username = value.String
                        }</span>
                case user.FieldEmail:<span class="cov7" title="41">
                        if value, ok := values[i].(*sql.NullString); !ok </span><span class="cov0" title="0">{
                                return fmt.Errorf("unexpected type %T for field email", values[i])
                        }</span> else<span class="cov7" title="41"> if value.Valid </span><span class="cov7" title="41">{
                                u.Email = value.String
                        }</span>
                case user.FieldPassword:<span class="cov7" title="41">
                        if value, ok := values[i].(*sql.NullString); !ok </span><span class="cov0" title="0">{
                                return fmt.Errorf("unexpected type %T for field password", values[i])
                        }</span> else<span class="cov7" title="41"> if value.Valid </span><span class="cov7" title="41">{
                                u.Password = value.String
                        }</span>
                case user.FieldCreatedAt:<span class="cov7" title="41">
                        if value, ok := values[i].(*sql.NullTime); !ok </span><span class="cov0" title="0">{
                                return fmt.Errorf("unexpected type %T for field created_at", values[i])
                        }</span> else<span class="cov7" title="41"> if value.Valid </span><span class="cov7" title="41">{
                                u.CreatedAt = value.Time
                        }</span>
                case user.FieldUpdatedAt:<span class="cov7" title="41">
                        if value, ok := values[i].(*sql.NullTime); !ok </span><span class="cov0" title="0">{
                                return fmt.Errorf("unexpected type %T for field updated_at", values[i])
                        }</span> else<span class="cov7" title="41"> if value.Valid </span><span class="cov7" title="41">{
                                u.UpdatedAt = value.Time
                        }</span>
                default:<span class="cov0" title="0">
                        u.selectValues.Set(columns[i], values[i])</span>
                }
        }
        <span class="cov7" title="41">return nil</span>
}

// Value returns the ent.Value that was dynamically selected and assigned to the User.
// This includes values selected through modifiers, order, etc.
func (u *User) Value(name string) (ent.Value, error) <span class="cov0" title="0">{
        return u.selectValues.Get(name)
}</span>

// QueryRoles queries the "roles" edge of the User entity.
func (u *User) QueryRoles() *RoleQuery <span class="cov1" title="1">{
        return NewUserClient(u.config).QueryRoles(u)
}</span>

// QueryTokens queries the "tokens" edge of the User entity.
func (u *User) QueryTokens() *TokenQuery <span class="cov1" title="1">{
        return NewUserClient(u.config).QueryTokens(u)
}</span>

// Update returns a builder for updating this User.
// Note that you need to call User.Unwrap() before calling this method if this User
// was returned from a transaction, and the transaction was committed or rolled back.
func (u *User) Update() *UserUpdateOne <span class="cov0" title="0">{
        return NewUserClient(u.config).UpdateOne(u)
}</span>

// Unwrap unwraps the User entity that was returned from a transaction after it was closed,
// so that all future queries will be executed through the driver which created the transaction.
func (u *User) Unwrap() *User <span class="cov0" title="0">{
        _tx, ok := u.config.driver.(*txDriver)
        if !ok </span><span class="cov0" title="0">{
                panic("ent: User is not a transactional entity")</span>
        }
        <span class="cov0" title="0">u.config.driver = _tx.drv
        return u</span>
}

// String implements the fmt.Stringer.
func (u *User) String() string <span class="cov1" title="1">{
        var builder strings.Builder
        builder.WriteString("User(")
        builder.WriteString(fmt.Sprintf("id=%v, ", u.ID))
        builder.WriteString("username=")
        builder.WriteString(u.Username)
        builder.WriteString(", ")
        builder.WriteString("email=")
        builder.WriteString(u.Email)
        builder.WriteString(", ")
        builder.WriteString("password=")
        builder.WriteString(u.Password)
        builder.WriteString(", ")
        builder.WriteString("created_at=")
        builder.WriteString(u.CreatedAt.Format(time.ANSIC))
        builder.WriteString(", ")
        builder.WriteString("updated_at=")
        builder.WriteString(u.UpdatedAt.Format(time.ANSIC))
        builder.WriteByte(')')
        return builder.String()
}</span>

// Users is a parsable slice of User.
type Users []*User
</pre>
		
		<pre class="file" id="file28" style="display: none">// Code generated by ent, DO NOT EDIT.

package user

import (
        "time"

        "entgo.io/ent"
        "entgo.io/ent/dialect/sql"
        "entgo.io/ent/dialect/sql/sqlgraph"
)

const (
        // Label holds the string label denoting the user type in the database.
        Label = "user"
        // FieldID holds the string denoting the id field in the database.
        FieldID = "id"
        // FieldUsername holds the string denoting the username field in the database.
        FieldUsername = "username"
        // FieldEmail holds the string denoting the email field in the database.
        FieldEmail = "email"
        // FieldPassword holds the string denoting the password field in the database.
        FieldPassword = "password"
        // FieldCreatedAt holds the string denoting the created_at field in the database.
        FieldCreatedAt = "created_at"
        // FieldUpdatedAt holds the string denoting the updated_at field in the database.
        FieldUpdatedAt = "updated_at"
        // EdgeRoles holds the string denoting the roles edge name in mutations.
        EdgeRoles = "roles"
        // EdgeTokens holds the string denoting the tokens edge name in mutations.
        EdgeTokens = "tokens"
        // Table holds the table name of the user in the database.
        Table = "users"
        // RolesTable is the table that holds the roles relation/edge. The primary key declared below.
        RolesTable = "user_roles"
        // RolesInverseTable is the table name for the Role entity.
        // It exists in this package in order to avoid circular dependency with the "role" package.
        RolesInverseTable = "roles"
        // TokensTable is the table that holds the tokens relation/edge.
        TokensTable = "tokens"
        // TokensInverseTable is the table name for the Token entity.
        // It exists in this package in order to avoid circular dependency with the "token" package.
        TokensInverseTable = "tokens"
        // TokensColumn is the table column denoting the tokens relation/edge.
        TokensColumn = "user_tokens"
)

// Columns holds all SQL columns for user fields.
var Columns = []string{
        FieldID,
        FieldUsername,
        FieldEmail,
        FieldPassword,
        FieldCreatedAt,
        FieldUpdatedAt,
}

var (
        // RolesPrimaryKey and RolesColumn2 are the table columns denoting the
        // primary key for the roles relation (M2M).
        RolesPrimaryKey = []string{"user_id", "role_id"}
)

// ValidColumn reports if the column name is valid (part of the table columns).
func ValidColumn(column string) bool <span class="cov0" title="0">{
        for i := range Columns </span><span class="cov0" title="0">{
                if column == Columns[i] </span><span class="cov0" title="0">{
                        return true
                }</span>
        }
        <span class="cov0" title="0">return false</span>
}

// Note that the variables below are initialized by the runtime
// package on the initialization of the application. Therefore,
// it should be imported in the main as follows:
//
//        import _ "auth/ent/runtime"
var (
        Hooks [1]ent.Hook
        // DefaultCreatedAt holds the default value on creation for the "created_at" field.
        DefaultCreatedAt func() time.Time
        // DefaultUpdatedAt holds the default value on creation for the "updated_at" field.
        DefaultUpdatedAt func() time.Time
        // UpdateDefaultUpdatedAt holds the default value on update for the "updated_at" field.
        UpdateDefaultUpdatedAt func() time.Time
        // DefaultID holds the default value on creation for the "id" field.
        DefaultID func() string
)

// OrderOption defines the ordering options for the User queries.
type OrderOption func(*sql.Selector)

// ByID orders the results by the id field.
func ByID(opts ...sql.OrderTermOption) OrderOption <span class="cov0" title="0">{
        return sql.OrderByField(FieldID, opts...).ToFunc()
}</span>

// ByUsername orders the results by the username field.
func ByUsername(opts ...sql.OrderTermOption) OrderOption <span class="cov0" title="0">{
        return sql.OrderByField(FieldUsername, opts...).ToFunc()
}</span>

// ByEmail orders the results by the email field.
func ByEmail(opts ...sql.OrderTermOption) OrderOption <span class="cov0" title="0">{
        return sql.OrderByField(FieldEmail, opts...).ToFunc()
}</span>

// ByPassword orders the results by the password field.
func ByPassword(opts ...sql.OrderTermOption) OrderOption <span class="cov0" title="0">{
        return sql.OrderByField(FieldPassword, opts...).ToFunc()
}</span>

// ByCreatedAt orders the results by the created_at field.
func ByCreatedAt(opts ...sql.OrderTermOption) OrderOption <span class="cov0" title="0">{
        return sql.OrderByField(FieldCreatedAt, opts...).ToFunc()
}</span>

// ByUpdatedAt orders the results by the updated_at field.
func ByUpdatedAt(opts ...sql.OrderTermOption) OrderOption <span class="cov0" title="0">{
        return sql.OrderByField(FieldUpdatedAt, opts...).ToFunc()
}</span>

// ByRolesCount orders the results by roles count.
func ByRolesCount(opts ...sql.OrderTermOption) OrderOption <span class="cov0" title="0">{
        return func(s *sql.Selector) </span><span class="cov0" title="0">{
                sqlgraph.OrderByNeighborsCount(s, newRolesStep(), opts...)
        }</span>
}

// ByRoles orders the results by roles terms.
func ByRoles(term sql.OrderTerm, terms ...sql.OrderTerm) OrderOption <span class="cov0" title="0">{
        return func(s *sql.Selector) </span><span class="cov0" title="0">{
                sqlgraph.OrderByNeighborTerms(s, newRolesStep(), append([]sql.OrderTerm{term}, terms...)...)
        }</span>
}

// ByTokensCount orders the results by tokens count.
func ByTokensCount(opts ...sql.OrderTermOption) OrderOption <span class="cov0" title="0">{
        return func(s *sql.Selector) </span><span class="cov0" title="0">{
                sqlgraph.OrderByNeighborsCount(s, newTokensStep(), opts...)
        }</span>
}

// ByTokens orders the results by tokens terms.
func ByTokens(term sql.OrderTerm, terms ...sql.OrderTerm) OrderOption <span class="cov0" title="0">{
        return func(s *sql.Selector) </span><span class="cov0" title="0">{
                sqlgraph.OrderByNeighborTerms(s, newTokensStep(), append([]sql.OrderTerm{term}, terms...)...)
        }</span>
}
func newRolesStep() *sqlgraph.Step <span class="cov8" title="1">{
        return sqlgraph.NewStep(
                sqlgraph.From(Table, FieldID),
                sqlgraph.To(RolesInverseTable, FieldID),
                sqlgraph.Edge(sqlgraph.M2M, false, RolesTable, RolesPrimaryKey...),
        )
}</span>
func newTokensStep() *sqlgraph.Step <span class="cov0" title="0">{
        return sqlgraph.NewStep(
                sqlgraph.From(Table, FieldID),
                sqlgraph.To(TokensInverseTable, FieldID),
                sqlgraph.Edge(sqlgraph.O2M, false, TokensTable, TokensColumn),
        )
}</span>
</pre>
		
		<pre class="file" id="file29" style="display: none">// Code generated by ent, DO NOT EDIT.

package user

import (
        "auth/ent/predicate"
        "time"

        "entgo.io/ent/dialect/sql"
        "entgo.io/ent/dialect/sql/sqlgraph"
)

// ID filters vertices based on their ID field.
func ID(id string) predicate.User <span class="cov10" title="18">{
        return predicate.User(sql.FieldEQ(FieldID, id))
}</span>

// IDEQ applies the EQ predicate on the ID field.
func IDEQ(id string) predicate.User <span class="cov0" title="0">{
        return predicate.User(sql.FieldEQ(FieldID, id))
}</span>

// IDNEQ applies the NEQ predicate on the ID field.
func IDNEQ(id string) predicate.User <span class="cov0" title="0">{
        return predicate.User(sql.FieldNEQ(FieldID, id))
}</span>

// IDIn applies the In predicate on the ID field.
func IDIn(ids ...string) predicate.User <span class="cov0" title="0">{
        return predicate.User(sql.FieldIn(FieldID, ids...))
}</span>

// IDNotIn applies the NotIn predicate on the ID field.
func IDNotIn(ids ...string) predicate.User <span class="cov0" title="0">{
        return predicate.User(sql.FieldNotIn(FieldID, ids...))
}</span>

// IDGT applies the GT predicate on the ID field.
func IDGT(id string) predicate.User <span class="cov0" title="0">{
        return predicate.User(sql.FieldGT(FieldID, id))
}</span>

// IDGTE applies the GTE predicate on the ID field.
func IDGTE(id string) predicate.User <span class="cov0" title="0">{
        return predicate.User(sql.FieldGTE(FieldID, id))
}</span>

// IDLT applies the LT predicate on the ID field.
func IDLT(id string) predicate.User <span class="cov0" title="0">{
        return predicate.User(sql.FieldLT(FieldID, id))
}</span>

// IDLTE applies the LTE predicate on the ID field.
func IDLTE(id string) predicate.User <span class="cov0" title="0">{
        return predicate.User(sql.FieldLTE(FieldID, id))
}</span>

// IDEqualFold applies the EqualFold predicate on the ID field.
func IDEqualFold(id string) predicate.User <span class="cov0" title="0">{
        return predicate.User(sql.FieldEqualFold(FieldID, id))
}</span>

// IDContainsFold applies the ContainsFold predicate on the ID field.
func IDContainsFold(id string) predicate.User <span class="cov0" title="0">{
        return predicate.User(sql.FieldContainsFold(FieldID, id))
}</span>

// Username applies equality check predicate on the "username" field. It's identical to UsernameEQ.
func Username(v string) predicate.User <span class="cov7" title="9">{
        return predicate.User(sql.FieldEQ(FieldUsername, v))
}</span>

// Email applies equality check predicate on the "email" field. It's identical to EmailEQ.
func Email(v string) predicate.User <span class="cov3" title="2">{
        return predicate.User(sql.FieldEQ(FieldEmail, v))
}</span>

// Password applies equality check predicate on the "password" field. It's identical to PasswordEQ.
func Password(v string) predicate.User <span class="cov0" title="0">{
        return predicate.User(sql.FieldEQ(FieldPassword, v))
}</span>

// CreatedAt applies equality check predicate on the "created_at" field. It's identical to CreatedAtEQ.
func CreatedAt(v time.Time) predicate.User <span class="cov0" title="0">{
        return predicate.User(sql.FieldEQ(FieldCreatedAt, v))
}</span>

// UpdatedAt applies equality check predicate on the "updated_at" field. It's identical to UpdatedAtEQ.
func UpdatedAt(v time.Time) predicate.User <span class="cov0" title="0">{
        return predicate.User(sql.FieldEQ(FieldUpdatedAt, v))
}</span>

// UsernameEQ applies the EQ predicate on the "username" field.
func UsernameEQ(v string) predicate.User <span class="cov0" title="0">{
        return predicate.User(sql.FieldEQ(FieldUsername, v))
}</span>

// UsernameNEQ applies the NEQ predicate on the "username" field.
func UsernameNEQ(v string) predicate.User <span class="cov0" title="0">{
        return predicate.User(sql.FieldNEQ(FieldUsername, v))
}</span>

// UsernameIn applies the In predicate on the "username" field.
func UsernameIn(vs ...string) predicate.User <span class="cov0" title="0">{
        return predicate.User(sql.FieldIn(FieldUsername, vs...))
}</span>

// UsernameNotIn applies the NotIn predicate on the "username" field.
func UsernameNotIn(vs ...string) predicate.User <span class="cov0" title="0">{
        return predicate.User(sql.FieldNotIn(FieldUsername, vs...))
}</span>

// UsernameGT applies the GT predicate on the "username" field.
func UsernameGT(v string) predicate.User <span class="cov0" title="0">{
        return predicate.User(sql.FieldGT(FieldUsername, v))
}</span>

// UsernameGTE applies the GTE predicate on the "username" field.
func UsernameGTE(v string) predicate.User <span class="cov0" title="0">{
        return predicate.User(sql.FieldGTE(FieldUsername, v))
}</span>

// UsernameLT applies the LT predicate on the "username" field.
func UsernameLT(v string) predicate.User <span class="cov0" title="0">{
        return predicate.User(sql.FieldLT(FieldUsername, v))
}</span>

// UsernameLTE applies the LTE predicate on the "username" field.
func UsernameLTE(v string) predicate.User <span class="cov0" title="0">{
        return predicate.User(sql.FieldLTE(FieldUsername, v))
}</span>

// UsernameContains applies the Contains predicate on the "username" field.
func UsernameContains(v string) predicate.User <span class="cov1" title="1">{
        return predicate.User(sql.FieldContains(FieldUsername, v))
}</span>

// UsernameHasPrefix applies the HasPrefix predicate on the "username" field.
func UsernameHasPrefix(v string) predicate.User <span class="cov0" title="0">{
        return predicate.User(sql.FieldHasPrefix(FieldUsername, v))
}</span>

// UsernameHasSuffix applies the HasSuffix predicate on the "username" field.
func UsernameHasSuffix(v string) predicate.User <span class="cov0" title="0">{
        return predicate.User(sql.FieldHasSuffix(FieldUsername, v))
}</span>

// UsernameEqualFold applies the EqualFold predicate on the "username" field.
func UsernameEqualFold(v string) predicate.User <span class="cov0" title="0">{
        return predicate.User(sql.FieldEqualFold(FieldUsername, v))
}</span>

// UsernameContainsFold applies the ContainsFold predicate on the "username" field.
func UsernameContainsFold(v string) predicate.User <span class="cov0" title="0">{
        return predicate.User(sql.FieldContainsFold(FieldUsername, v))
}</span>

// EmailEQ applies the EQ predicate on the "email" field.
func EmailEQ(v string) predicate.User <span class="cov0" title="0">{
        return predicate.User(sql.FieldEQ(FieldEmail, v))
}</span>

// EmailNEQ applies the NEQ predicate on the "email" field.
func EmailNEQ(v string) predicate.User <span class="cov0" title="0">{
        return predicate.User(sql.FieldNEQ(FieldEmail, v))
}</span>

// EmailIn applies the In predicate on the "email" field.
func EmailIn(vs ...string) predicate.User <span class="cov0" title="0">{
        return predicate.User(sql.FieldIn(FieldEmail, vs...))
}</span>

// EmailNotIn applies the NotIn predicate on the "email" field.
func EmailNotIn(vs ...string) predicate.User <span class="cov0" title="0">{
        return predicate.User(sql.FieldNotIn(FieldEmail, vs...))
}</span>

// EmailGT applies the GT predicate on the "email" field.
func EmailGT(v string) predicate.User <span class="cov0" title="0">{
        return predicate.User(sql.FieldGT(FieldEmail, v))
}</span>

// EmailGTE applies the GTE predicate on the "email" field.
func EmailGTE(v string) predicate.User <span class="cov0" title="0">{
        return predicate.User(sql.FieldGTE(FieldEmail, v))
}</span>

// EmailLT applies the LT predicate on the "email" field.
func EmailLT(v string) predicate.User <span class="cov0" title="0">{
        return predicate.User(sql.FieldLT(FieldEmail, v))
}</span>

// EmailLTE applies the LTE predicate on the "email" field.
func EmailLTE(v string) predicate.User <span class="cov0" title="0">{
        return predicate.User(sql.FieldLTE(FieldEmail, v))
}</span>

// EmailContains applies the Contains predicate on the "email" field.
func EmailContains(v string) predicate.User <span class="cov1" title="1">{
        return predicate.User(sql.FieldContains(FieldEmail, v))
}</span>

// EmailHasPrefix applies the HasPrefix predicate on the "email" field.
func EmailHasPrefix(v string) predicate.User <span class="cov0" title="0">{
        return predicate.User(sql.FieldHasPrefix(FieldEmail, v))
}</span>

// EmailHasSuffix applies the HasSuffix predicate on the "email" field.
func EmailHasSuffix(v string) predicate.User <span class="cov0" title="0">{
        return predicate.User(sql.FieldHasSuffix(FieldEmail, v))
}</span>

// EmailEqualFold applies the EqualFold predicate on the "email" field.
func EmailEqualFold(v string) predicate.User <span class="cov0" title="0">{
        return predicate.User(sql.FieldEqualFold(FieldEmail, v))
}</span>

// EmailContainsFold applies the ContainsFold predicate on the "email" field.
func EmailContainsFold(v string) predicate.User <span class="cov0" title="0">{
        return predicate.User(sql.FieldContainsFold(FieldEmail, v))
}</span>

// PasswordEQ applies the EQ predicate on the "password" field.
func PasswordEQ(v string) predicate.User <span class="cov0" title="0">{
        return predicate.User(sql.FieldEQ(FieldPassword, v))
}</span>

// PasswordNEQ applies the NEQ predicate on the "password" field.
func PasswordNEQ(v string) predicate.User <span class="cov0" title="0">{
        return predicate.User(sql.FieldNEQ(FieldPassword, v))
}</span>

// PasswordIn applies the In predicate on the "password" field.
func PasswordIn(vs ...string) predicate.User <span class="cov0" title="0">{
        return predicate.User(sql.FieldIn(FieldPassword, vs...))
}</span>

// PasswordNotIn applies the NotIn predicate on the "password" field.
func PasswordNotIn(vs ...string) predicate.User <span class="cov0" title="0">{
        return predicate.User(sql.FieldNotIn(FieldPassword, vs...))
}</span>

// PasswordGT applies the GT predicate on the "password" field.
func PasswordGT(v string) predicate.User <span class="cov0" title="0">{
        return predicate.User(sql.FieldGT(FieldPassword, v))
}</span>

// PasswordGTE applies the GTE predicate on the "password" field.
func PasswordGTE(v string) predicate.User <span class="cov0" title="0">{
        return predicate.User(sql.FieldGTE(FieldPassword, v))
}</span>

// PasswordLT applies the LT predicate on the "password" field.
func PasswordLT(v string) predicate.User <span class="cov0" title="0">{
        return predicate.User(sql.FieldLT(FieldPassword, v))
}</span>

// PasswordLTE applies the LTE predicate on the "password" field.
func PasswordLTE(v string) predicate.User <span class="cov0" title="0">{
        return predicate.User(sql.FieldLTE(FieldPassword, v))
}</span>

// PasswordContains applies the Contains predicate on the "password" field.
func PasswordContains(v string) predicate.User <span class="cov0" title="0">{
        return predicate.User(sql.FieldContains(FieldPassword, v))
}</span>

// PasswordHasPrefix applies the HasPrefix predicate on the "password" field.
func PasswordHasPrefix(v string) predicate.User <span class="cov0" title="0">{
        return predicate.User(sql.FieldHasPrefix(FieldPassword, v))
}</span>

// PasswordHasSuffix applies the HasSuffix predicate on the "password" field.
func PasswordHasSuffix(v string) predicate.User <span class="cov0" title="0">{
        return predicate.User(sql.FieldHasSuffix(FieldPassword, v))
}</span>

// PasswordEqualFold applies the EqualFold predicate on the "password" field.
func PasswordEqualFold(v string) predicate.User <span class="cov0" title="0">{
        return predicate.User(sql.FieldEqualFold(FieldPassword, v))
}</span>

// PasswordContainsFold applies the ContainsFold predicate on the "password" field.
func PasswordContainsFold(v string) predicate.User <span class="cov0" title="0">{
        return predicate.User(sql.FieldContainsFold(FieldPassword, v))
}</span>

// CreatedAtEQ applies the EQ predicate on the "created_at" field.
func CreatedAtEQ(v time.Time) predicate.User <span class="cov0" title="0">{
        return predicate.User(sql.FieldEQ(FieldCreatedAt, v))
}</span>

// CreatedAtNEQ applies the NEQ predicate on the "created_at" field.
func CreatedAtNEQ(v time.Time) predicate.User <span class="cov0" title="0">{
        return predicate.User(sql.FieldNEQ(FieldCreatedAt, v))
}</span>

// CreatedAtIn applies the In predicate on the "created_at" field.
func CreatedAtIn(vs ...time.Time) predicate.User <span class="cov0" title="0">{
        return predicate.User(sql.FieldIn(FieldCreatedAt, vs...))
}</span>

// CreatedAtNotIn applies the NotIn predicate on the "created_at" field.
func CreatedAtNotIn(vs ...time.Time) predicate.User <span class="cov0" title="0">{
        return predicate.User(sql.FieldNotIn(FieldCreatedAt, vs...))
}</span>

// CreatedAtGT applies the GT predicate on the "created_at" field.
func CreatedAtGT(v time.Time) predicate.User <span class="cov0" title="0">{
        return predicate.User(sql.FieldGT(FieldCreatedAt, v))
}</span>

// CreatedAtGTE applies the GTE predicate on the "created_at" field.
func CreatedAtGTE(v time.Time) predicate.User <span class="cov0" title="0">{
        return predicate.User(sql.FieldGTE(FieldCreatedAt, v))
}</span>

// CreatedAtLT applies the LT predicate on the "created_at" field.
func CreatedAtLT(v time.Time) predicate.User <span class="cov0" title="0">{
        return predicate.User(sql.FieldLT(FieldCreatedAt, v))
}</span>

// CreatedAtLTE applies the LTE predicate on the "created_at" field.
func CreatedAtLTE(v time.Time) predicate.User <span class="cov0" title="0">{
        return predicate.User(sql.FieldLTE(FieldCreatedAt, v))
}</span>

// UpdatedAtEQ applies the EQ predicate on the "updated_at" field.
func UpdatedAtEQ(v time.Time) predicate.User <span class="cov0" title="0">{
        return predicate.User(sql.FieldEQ(FieldUpdatedAt, v))
}</span>

// UpdatedAtNEQ applies the NEQ predicate on the "updated_at" field.
func UpdatedAtNEQ(v time.Time) predicate.User <span class="cov0" title="0">{
        return predicate.User(sql.FieldNEQ(FieldUpdatedAt, v))
}</span>

// UpdatedAtIn applies the In predicate on the "updated_at" field.
func UpdatedAtIn(vs ...time.Time) predicate.User <span class="cov0" title="0">{
        return predicate.User(sql.FieldIn(FieldUpdatedAt, vs...))
}</span>

// UpdatedAtNotIn applies the NotIn predicate on the "updated_at" field.
func UpdatedAtNotIn(vs ...time.Time) predicate.User <span class="cov0" title="0">{
        return predicate.User(sql.FieldNotIn(FieldUpdatedAt, vs...))
}</span>

// UpdatedAtGT applies the GT predicate on the "updated_at" field.
func UpdatedAtGT(v time.Time) predicate.User <span class="cov0" title="0">{
        return predicate.User(sql.FieldGT(FieldUpdatedAt, v))
}</span>

// UpdatedAtGTE applies the GTE predicate on the "updated_at" field.
func UpdatedAtGTE(v time.Time) predicate.User <span class="cov0" title="0">{
        return predicate.User(sql.FieldGTE(FieldUpdatedAt, v))
}</span>

// UpdatedAtLT applies the LT predicate on the "updated_at" field.
func UpdatedAtLT(v time.Time) predicate.User <span class="cov0" title="0">{
        return predicate.User(sql.FieldLT(FieldUpdatedAt, v))
}</span>

// UpdatedAtLTE applies the LTE predicate on the "updated_at" field.
func UpdatedAtLTE(v time.Time) predicate.User <span class="cov0" title="0">{
        return predicate.User(sql.FieldLTE(FieldUpdatedAt, v))
}</span>

// HasRoles applies the HasEdge predicate on the "roles" edge.
func HasRoles() predicate.User <span class="cov0" title="0">{
        return predicate.User(func(s *sql.Selector) </span><span class="cov0" title="0">{
                step := sqlgraph.NewStep(
                        sqlgraph.From(Table, FieldID),
                        sqlgraph.Edge(sqlgraph.M2M, false, RolesTable, RolesPrimaryKey...),
                )
                sqlgraph.HasNeighbors(s, step)
        }</span>)
}

// HasRolesWith applies the HasEdge predicate on the "roles" edge with a given conditions (other predicates).
func HasRolesWith(preds ...predicate.Role) predicate.User <span class="cov1" title="1">{
        return predicate.User(func(s *sql.Selector) </span><span class="cov1" title="1">{
                step := newRolesStep()
                sqlgraph.HasNeighborsWith(s, step, func(s *sql.Selector) </span><span class="cov1" title="1">{
                        for _, p := range preds </span><span class="cov1" title="1">{
                                p(s)
                        }</span>
                })
        })
}

// HasTokens applies the HasEdge predicate on the "tokens" edge.
func HasTokens() predicate.User <span class="cov0" title="0">{
        return predicate.User(func(s *sql.Selector) </span><span class="cov0" title="0">{
                step := sqlgraph.NewStep(
                        sqlgraph.From(Table, FieldID),
                        sqlgraph.Edge(sqlgraph.O2M, false, TokensTable, TokensColumn),
                )
                sqlgraph.HasNeighbors(s, step)
        }</span>)
}

// HasTokensWith applies the HasEdge predicate on the "tokens" edge with a given conditions (other predicates).
func HasTokensWith(preds ...predicate.Token) predicate.User <span class="cov0" title="0">{
        return predicate.User(func(s *sql.Selector) </span><span class="cov0" title="0">{
                step := newTokensStep()
                sqlgraph.HasNeighborsWith(s, step, func(s *sql.Selector) </span><span class="cov0" title="0">{
                        for _, p := range preds </span><span class="cov0" title="0">{
                                p(s)
                        }</span>
                })
        })
}

// And groups predicates with the AND operator between them.
func And(predicates ...predicate.User) predicate.User <span class="cov0" title="0">{
        return predicate.User(sql.AndPredicates(predicates...))
}</span>

// Or groups predicates with the OR operator between them.
func Or(predicates ...predicate.User) predicate.User <span class="cov1" title="1">{
        return predicate.User(sql.OrPredicates(predicates...))
}</span>

// Not applies the not operator on the given predicate.
func Not(p predicate.User) predicate.User <span class="cov0" title="0">{
        return predicate.User(sql.NotPredicates(p))
}</span>
</pre>
		
		<pre class="file" id="file30" style="display: none">// Code generated by ent, DO NOT EDIT.

package ent

import (
        "auth/ent/role"
        "auth/ent/token"
        "auth/ent/user"
        "context"
        "errors"
        "fmt"
        "time"

        "entgo.io/ent/dialect/sql/sqlgraph"
        "entgo.io/ent/schema/field"
)

// UserCreate is the builder for creating a User entity.
type UserCreate struct {
        config
        mutation *UserMutation
        hooks    []Hook
}

// SetUsername sets the "username" field.
func (uc *UserCreate) SetUsername(s string) *UserCreate <span class="cov10" title="44">{
        uc.mutation.SetUsername(s)
        return uc
}</span>

// SetEmail sets the "email" field.
func (uc *UserCreate) SetEmail(s string) *UserCreate <span class="cov10" title="44">{
        uc.mutation.SetEmail(s)
        return uc
}</span>

// SetPassword sets the "password" field.
func (uc *UserCreate) SetPassword(s string) *UserCreate <span class="cov10" title="44">{
        uc.mutation.SetPassword(s)
        return uc
}</span>

// SetCreatedAt sets the "created_at" field.
func (uc *UserCreate) SetCreatedAt(t time.Time) *UserCreate <span class="cov0" title="0">{
        uc.mutation.SetCreatedAt(t)
        return uc
}</span>

// SetNillableCreatedAt sets the "created_at" field if the given value is not nil.
func (uc *UserCreate) SetNillableCreatedAt(t *time.Time) *UserCreate <span class="cov0" title="0">{
        if t != nil </span><span class="cov0" title="0">{
                uc.SetCreatedAt(*t)
        }</span>
        <span class="cov0" title="0">return uc</span>
}

// SetUpdatedAt sets the "updated_at" field.
func (uc *UserCreate) SetUpdatedAt(t time.Time) *UserCreate <span class="cov0" title="0">{
        uc.mutation.SetUpdatedAt(t)
        return uc
}</span>

// SetNillableUpdatedAt sets the "updated_at" field if the given value is not nil.
func (uc *UserCreate) SetNillableUpdatedAt(t *time.Time) *UserCreate <span class="cov0" title="0">{
        if t != nil </span><span class="cov0" title="0">{
                uc.SetUpdatedAt(*t)
        }</span>
        <span class="cov0" title="0">return uc</span>
}

// SetID sets the "id" field.
func (uc *UserCreate) SetID(s string) *UserCreate <span class="cov5" title="6">{
        uc.mutation.SetID(s)
        return uc
}</span>

// SetNillableID sets the "id" field if the given value is not nil.
func (uc *UserCreate) SetNillableID(s *string) *UserCreate <span class="cov0" title="0">{
        if s != nil </span><span class="cov0" title="0">{
                uc.SetID(*s)
        }</span>
        <span class="cov0" title="0">return uc</span>
}

// AddRoleIDs adds the "roles" edge to the Role entity by IDs.
func (uc *UserCreate) AddRoleIDs(ids ...string) *UserCreate <span class="cov0" title="0">{
        uc.mutation.AddRoleIDs(ids...)
        return uc
}</span>

// AddRoles adds the "roles" edges to the Role entity.
func (uc *UserCreate) AddRoles(r ...*Role) *UserCreate <span class="cov0" title="0">{
        ids := make([]string, len(r))
        for i := range r </span><span class="cov0" title="0">{
                ids[i] = r[i].ID
        }</span>
        <span class="cov0" title="0">return uc.AddRoleIDs(ids...)</span>
}

// AddTokenIDs adds the "tokens" edge to the Token entity by IDs.
func (uc *UserCreate) AddTokenIDs(ids ...string) *UserCreate <span class="cov0" title="0">{
        uc.mutation.AddTokenIDs(ids...)
        return uc
}</span>

// AddTokens adds the "tokens" edges to the Token entity.
func (uc *UserCreate) AddTokens(t ...*Token) *UserCreate <span class="cov0" title="0">{
        ids := make([]string, len(t))
        for i := range t </span><span class="cov0" title="0">{
                ids[i] = t[i].ID
        }</span>
        <span class="cov0" title="0">return uc.AddTokenIDs(ids...)</span>
}

// Mutation returns the UserMutation object of the builder.
func (uc *UserCreate) Mutation() *UserMutation <span class="cov0" title="0">{
        return uc.mutation
}</span>

// Save creates the User in the database.
func (uc *UserCreate) Save(ctx context.Context) (*User, error) <span class="cov10" title="44">{
        if err := uc.defaults(); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov10" title="44">return withHooks(ctx, uc.sqlSave, uc.mutation, uc.hooks)</span>
}

// SaveX calls Save and panics if Save returns an error.
func (uc *UserCreate) SaveX(ctx context.Context) *User <span class="cov1" title="1">{
        v, err := uc.Save(ctx)
        if err != nil </span><span class="cov0" title="0">{
                panic(err)</span>
        }
        <span class="cov1" title="1">return v</span>
}

// Exec executes the query.
func (uc *UserCreate) Exec(ctx context.Context) error <span class="cov0" title="0">{
        _, err := uc.Save(ctx)
        return err
}</span>

// ExecX is like Exec, but panics if an error occurs.
func (uc *UserCreate) ExecX(ctx context.Context) <span class="cov0" title="0">{
        if err := uc.Exec(ctx); err != nil </span><span class="cov0" title="0">{
                panic(err)</span>
        }
}

// defaults sets the default values of the builder before save.
func (uc *UserCreate) defaults() error <span class="cov10" title="44">{
        if _, ok := uc.mutation.CreatedAt(); !ok </span><span class="cov10" title="44">{
                if user.DefaultCreatedAt == nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("ent: uninitialized user.DefaultCreatedAt (forgotten import ent/runtime?)")
                }</span>
                <span class="cov10" title="44">v := user.DefaultCreatedAt()
                uc.mutation.SetCreatedAt(v)</span>
        }
        <span class="cov10" title="44">if _, ok := uc.mutation.UpdatedAt(); !ok </span><span class="cov10" title="44">{
                if user.DefaultUpdatedAt == nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("ent: uninitialized user.DefaultUpdatedAt (forgotten import ent/runtime?)")
                }</span>
                <span class="cov10" title="44">v := user.DefaultUpdatedAt()
                uc.mutation.SetUpdatedAt(v)</span>
        }
        <span class="cov10" title="44">if _, ok := uc.mutation.ID(); !ok </span><span class="cov9" title="38">{
                if user.DefaultID == nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("ent: uninitialized user.DefaultID (forgotten import ent/runtime?)")
                }</span>
                <span class="cov9" title="38">v := user.DefaultID()
                uc.mutation.SetID(v)</span>
        }
        <span class="cov10" title="44">return nil</span>
}

// check runs all checks and user-defined validators on the builder.
func (uc *UserCreate) check() error <span class="cov10" title="44">{
        if _, ok := uc.mutation.Username(); !ok </span><span class="cov0" title="0">{
                return &amp;ValidationError{Name: "username", err: errors.New(`ent: missing required field "User.username"`)}
        }</span>
        <span class="cov10" title="44">if _, ok := uc.mutation.Email(); !ok </span><span class="cov0" title="0">{
                return &amp;ValidationError{Name: "email", err: errors.New(`ent: missing required field "User.email"`)}
        }</span>
        <span class="cov10" title="44">if _, ok := uc.mutation.Password(); !ok </span><span class="cov0" title="0">{
                return &amp;ValidationError{Name: "password", err: errors.New(`ent: missing required field "User.password"`)}
        }</span>
        <span class="cov10" title="44">if _, ok := uc.mutation.CreatedAt(); !ok </span><span class="cov0" title="0">{
                return &amp;ValidationError{Name: "created_at", err: errors.New(`ent: missing required field "User.created_at"`)}
        }</span>
        <span class="cov10" title="44">if _, ok := uc.mutation.UpdatedAt(); !ok </span><span class="cov0" title="0">{
                return &amp;ValidationError{Name: "updated_at", err: errors.New(`ent: missing required field "User.updated_at"`)}
        }</span>
        <span class="cov10" title="44">return nil</span>
}

func (uc *UserCreate) sqlSave(ctx context.Context) (*User, error) <span class="cov10" title="44">{
        if err := uc.check(); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov10" title="44">_node, _spec := uc.createSpec()
        if err := sqlgraph.CreateNode(ctx, uc.driver, _spec); err != nil </span><span class="cov2" title="2">{
                if sqlgraph.IsConstraintError(err) </span><span class="cov2" title="2">{
                        err = &amp;ConstraintError{msg: err.Error(), wrap: err}
                }</span>
                <span class="cov2" title="2">return nil, err</span>
        }
        <span class="cov9" title="42">if _spec.ID.Value != nil </span><span class="cov9" title="42">{
                if id, ok := _spec.ID.Value.(string); ok </span><span class="cov9" title="42">{
                        _node.ID = id
                }</span> else<span class="cov0" title="0"> {
                        return nil, fmt.Errorf("unexpected User.ID type: %T", _spec.ID.Value)
                }</span>
        }
        <span class="cov9" title="42">uc.mutation.id = &amp;_node.ID
        uc.mutation.done = true
        return _node, nil</span>
}

func (uc *UserCreate) createSpec() (*User, *sqlgraph.CreateSpec) <span class="cov10" title="44">{
        var (
                _node = &amp;User{config: uc.config}
                _spec = sqlgraph.NewCreateSpec(user.Table, sqlgraph.NewFieldSpec(user.FieldID, field.TypeString))
        )
        if id, ok := uc.mutation.ID(); ok </span><span class="cov10" title="44">{
                _node.ID = id
                _spec.ID.Value = id
        }</span>
        <span class="cov10" title="44">if value, ok := uc.mutation.Username(); ok </span><span class="cov10" title="44">{
                _spec.SetField(user.FieldUsername, field.TypeString, value)
                _node.Username = value
        }</span>
        <span class="cov10" title="44">if value, ok := uc.mutation.Email(); ok </span><span class="cov10" title="44">{
                _spec.SetField(user.FieldEmail, field.TypeString, value)
                _node.Email = value
        }</span>
        <span class="cov10" title="44">if value, ok := uc.mutation.Password(); ok </span><span class="cov10" title="44">{
                _spec.SetField(user.FieldPassword, field.TypeString, value)
                _node.Password = value
        }</span>
        <span class="cov10" title="44">if value, ok := uc.mutation.CreatedAt(); ok </span><span class="cov10" title="44">{
                _spec.SetField(user.FieldCreatedAt, field.TypeTime, value)
                _node.CreatedAt = value
        }</span>
        <span class="cov10" title="44">if value, ok := uc.mutation.UpdatedAt(); ok </span><span class="cov10" title="44">{
                _spec.SetField(user.FieldUpdatedAt, field.TypeTime, value)
                _node.UpdatedAt = value
        }</span>
        <span class="cov10" title="44">if nodes := uc.mutation.RolesIDs(); len(nodes) &gt; 0 </span><span class="cov0" title="0">{
                edge := &amp;sqlgraph.EdgeSpec{
                        Rel:     sqlgraph.M2M,
                        Inverse: false,
                        Table:   user.RolesTable,
                        Columns: user.RolesPrimaryKey,
                        Bidi:    false,
                        Target: &amp;sqlgraph.EdgeTarget{
                                IDSpec: sqlgraph.NewFieldSpec(role.FieldID, field.TypeString),
                        },
                }
                for _, k := range nodes </span><span class="cov0" title="0">{
                        edge.Target.Nodes = append(edge.Target.Nodes, k)
                }</span>
                <span class="cov0" title="0">_spec.Edges = append(_spec.Edges, edge)</span>
        }
        <span class="cov10" title="44">if nodes := uc.mutation.TokensIDs(); len(nodes) &gt; 0 </span><span class="cov0" title="0">{
                edge := &amp;sqlgraph.EdgeSpec{
                        Rel:     sqlgraph.O2M,
                        Inverse: false,
                        Table:   user.TokensTable,
                        Columns: []string{user.TokensColumn},
                        Bidi:    false,
                        Target: &amp;sqlgraph.EdgeTarget{
                                IDSpec: sqlgraph.NewFieldSpec(token.FieldID, field.TypeString),
                        },
                }
                for _, k := range nodes </span><span class="cov0" title="0">{
                        edge.Target.Nodes = append(edge.Target.Nodes, k)
                }</span>
                <span class="cov0" title="0">_spec.Edges = append(_spec.Edges, edge)</span>
        }
        <span class="cov10" title="44">return _node, _spec</span>
}

// UserCreateBulk is the builder for creating many User entities in bulk.
type UserCreateBulk struct {
        config
        err      error
        builders []*UserCreate
}

// Save creates the User entities in the database.
func (ucb *UserCreateBulk) Save(ctx context.Context) ([]*User, error) <span class="cov0" title="0">{
        if ucb.err != nil </span><span class="cov0" title="0">{
                return nil, ucb.err
        }</span>
        <span class="cov0" title="0">specs := make([]*sqlgraph.CreateSpec, len(ucb.builders))
        nodes := make([]*User, len(ucb.builders))
        mutators := make([]Mutator, len(ucb.builders))
        for i := range ucb.builders </span><span class="cov0" title="0">{
                func(i int, root context.Context) </span><span class="cov0" title="0">{
                        builder := ucb.builders[i]
                        builder.defaults()
                        var mut Mutator = MutateFunc(func(ctx context.Context, m Mutation) (Value, error) </span><span class="cov0" title="0">{
                                mutation, ok := m.(*UserMutation)
                                if !ok </span><span class="cov0" title="0">{
                                        return nil, fmt.Errorf("unexpected mutation type %T", m)
                                }</span>
                                <span class="cov0" title="0">if err := builder.check(); err != nil </span><span class="cov0" title="0">{
                                        return nil, err
                                }</span>
                                <span class="cov0" title="0">builder.mutation = mutation
                                var err error
                                nodes[i], specs[i] = builder.createSpec()
                                if i &lt; len(mutators)-1 </span><span class="cov0" title="0">{
                                        _, err = mutators[i+1].Mutate(root, ucb.builders[i+1].mutation)
                                }</span> else<span class="cov0" title="0"> {
                                        spec := &amp;sqlgraph.BatchCreateSpec{Nodes: specs}
                                        // Invoke the actual operation on the latest mutation in the chain.
                                        if err = sqlgraph.BatchCreate(ctx, ucb.driver, spec); err != nil </span><span class="cov0" title="0">{
                                                if sqlgraph.IsConstraintError(err) </span><span class="cov0" title="0">{
                                                        err = &amp;ConstraintError{msg: err.Error(), wrap: err}
                                                }</span>
                                        }
                                }
                                <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                                        return nil, err
                                }</span>
                                <span class="cov0" title="0">mutation.id = &amp;nodes[i].ID
                                mutation.done = true
                                return nodes[i], nil</span>
                        })
                        <span class="cov0" title="0">for i := len(builder.hooks) - 1; i &gt;= 0; i-- </span><span class="cov0" title="0">{
                                mut = builder.hooks[i](mut)
                        }</span>
                        <span class="cov0" title="0">mutators[i] = mut</span>
                }(i, ctx)
        }
        <span class="cov0" title="0">if len(mutators) &gt; 0 </span><span class="cov0" title="0">{
                if _, err := mutators[0].Mutate(ctx, ucb.builders[0].mutation); err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
        }
        <span class="cov0" title="0">return nodes, nil</span>
}

// SaveX is like Save, but panics if an error occurs.
func (ucb *UserCreateBulk) SaveX(ctx context.Context) []*User <span class="cov0" title="0">{
        v, err := ucb.Save(ctx)
        if err != nil </span><span class="cov0" title="0">{
                panic(err)</span>
        }
        <span class="cov0" title="0">return v</span>
}

// Exec executes the query.
func (ucb *UserCreateBulk) Exec(ctx context.Context) error <span class="cov0" title="0">{
        _, err := ucb.Save(ctx)
        return err
}</span>

// ExecX is like Exec, but panics if an error occurs.
func (ucb *UserCreateBulk) ExecX(ctx context.Context) <span class="cov0" title="0">{
        if err := ucb.Exec(ctx); err != nil </span><span class="cov0" title="0">{
                panic(err)</span>
        }
}
</pre>
		
		<pre class="file" id="file31" style="display: none">// Code generated by ent, DO NOT EDIT.

package ent

import (
        "auth/ent/predicate"
        "auth/ent/user"
        "context"

        "entgo.io/ent/dialect/sql"
        "entgo.io/ent/dialect/sql/sqlgraph"
        "entgo.io/ent/schema/field"
)

// UserDelete is the builder for deleting a User entity.
type UserDelete struct {
        config
        hooks    []Hook
        mutation *UserMutation
}

// Where appends a list predicates to the UserDelete builder.
func (ud *UserDelete) Where(ps ...predicate.User) *UserDelete <span class="cov6" title="2">{
        ud.mutation.Where(ps...)
        return ud
}</span>

// Exec executes the deletion query and returns how many vertices were deleted.
func (ud *UserDelete) Exec(ctx context.Context) (int, error) <span class="cov10" title="3">{
        return withHooks(ctx, ud.sqlExec, ud.mutation, ud.hooks)
}</span>

// ExecX is like Exec, but panics if an error occurs.
func (ud *UserDelete) ExecX(ctx context.Context) int <span class="cov0" title="0">{
        n, err := ud.Exec(ctx)
        if err != nil </span><span class="cov0" title="0">{
                panic(err)</span>
        }
        <span class="cov0" title="0">return n</span>
}

func (ud *UserDelete) sqlExec(ctx context.Context) (int, error) <span class="cov10" title="3">{
        _spec := sqlgraph.NewDeleteSpec(user.Table, sqlgraph.NewFieldSpec(user.FieldID, field.TypeString))
        if ps := ud.mutation.predicates; len(ps) &gt; 0 </span><span class="cov6" title="2">{
                _spec.Predicate = func(selector *sql.Selector) </span><span class="cov6" title="2">{
                        for i := range ps </span><span class="cov6" title="2">{
                                ps[i](selector)
                        }</span>
                }
        }
        <span class="cov10" title="3">affected, err := sqlgraph.DeleteNodes(ctx, ud.driver, _spec)
        if err != nil &amp;&amp; sqlgraph.IsConstraintError(err) </span><span class="cov0" title="0">{
                err = &amp;ConstraintError{msg: err.Error(), wrap: err}
        }</span>
        <span class="cov10" title="3">ud.mutation.done = true
        return affected, err</span>
}

// UserDeleteOne is the builder for deleting a single User entity.
type UserDeleteOne struct {
        ud *UserDelete
}

// Where appends a list predicates to the UserDelete builder.
func (udo *UserDeleteOne) Where(ps ...predicate.User) *UserDeleteOne <span class="cov0" title="0">{
        udo.ud.mutation.Where(ps...)
        return udo
}</span>

// Exec executes the deletion query.
func (udo *UserDeleteOne) Exec(ctx context.Context) error <span class="cov6" title="2">{
        n, err := udo.ud.Exec(ctx)
        switch </span>{
        case err != nil:<span class="cov0" title="0">
                return err</span>
        case n == 0:<span class="cov1" title="1">
                return &amp;NotFoundError{user.Label}</span>
        default:<span class="cov1" title="1">
                return nil</span>
        }
}

// ExecX is like Exec, but panics if an error occurs.
func (udo *UserDeleteOne) ExecX(ctx context.Context) <span class="cov0" title="0">{
        if err := udo.Exec(ctx); err != nil </span><span class="cov0" title="0">{
                panic(err)</span>
        }
}
</pre>
		
		<pre class="file" id="file32" style="display: none">// Code generated by ent, DO NOT EDIT.

package ent

import (
        "auth/ent/predicate"
        "auth/ent/role"
        "auth/ent/token"
        "auth/ent/user"
        "context"
        "database/sql/driver"
        "fmt"
        "math"

        "entgo.io/ent/dialect/sql"
        "entgo.io/ent/dialect/sql/sqlgraph"
        "entgo.io/ent/schema/field"
)

// UserQuery is the builder for querying User entities.
type UserQuery struct {
        config
        ctx        *QueryContext
        order      []user.OrderOption
        inters     []Interceptor
        predicates []predicate.User
        withRoles  *RoleQuery
        withTokens *TokenQuery
        // intermediate query (i.e. traversal path).
        sql  *sql.Selector
        path func(context.Context) (*sql.Selector, error)
}

// Where adds a new predicate for the UserQuery builder.
func (uq *UserQuery) Where(ps ...predicate.User) *UserQuery <span class="cov9" title="24">{
        uq.predicates = append(uq.predicates, ps...)
        return uq
}</span>

// Limit the number of records to be returned by this query.
func (uq *UserQuery) Limit(limit int) *UserQuery <span class="cov9" title="24">{
        uq.ctx.Limit = &amp;limit
        return uq
}</span>

// Offset to start from.
func (uq *UserQuery) Offset(offset int) *UserQuery <span class="cov2" title="2">{
        uq.ctx.Offset = &amp;offset
        return uq
}</span>

// Unique configures the query builder to filter duplicate records on query.
// By default, unique is set to true, and can be disabled using this method.
func (uq *UserQuery) Unique(unique bool) *UserQuery <span class="cov0" title="0">{
        uq.ctx.Unique = &amp;unique
        return uq
}</span>

// Order specifies how the records should be ordered.
func (uq *UserQuery) Order(o ...user.OrderOption) *UserQuery <span class="cov0" title="0">{
        uq.order = append(uq.order, o...)
        return uq
}</span>

// QueryRoles chains the current query on the "roles" edge.
func (uq *UserQuery) QueryRoles() *RoleQuery <span class="cov0" title="0">{
        query := (&amp;RoleClient{config: uq.config}).Query()
        query.path = func(ctx context.Context) (fromU *sql.Selector, err error) </span><span class="cov0" title="0">{
                if err := uq.prepareQuery(ctx); err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">selector := uq.sqlQuery(ctx)
                if err := selector.Err(); err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">step := sqlgraph.NewStep(
                        sqlgraph.From(user.Table, user.FieldID, selector),
                        sqlgraph.To(role.Table, role.FieldID),
                        sqlgraph.Edge(sqlgraph.M2M, false, user.RolesTable, user.RolesPrimaryKey...),
                )
                fromU = sqlgraph.SetNeighbors(uq.driver.Dialect(), step)
                return fromU, nil</span>
        }
        <span class="cov0" title="0">return query</span>
}

// QueryTokens chains the current query on the "tokens" edge.
func (uq *UserQuery) QueryTokens() *TokenQuery <span class="cov0" title="0">{
        query := (&amp;TokenClient{config: uq.config}).Query()
        query.path = func(ctx context.Context) (fromU *sql.Selector, err error) </span><span class="cov0" title="0">{
                if err := uq.prepareQuery(ctx); err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">selector := uq.sqlQuery(ctx)
                if err := selector.Err(); err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">step := sqlgraph.NewStep(
                        sqlgraph.From(user.Table, user.FieldID, selector),
                        sqlgraph.To(token.Table, token.FieldID),
                        sqlgraph.Edge(sqlgraph.O2M, false, user.TokensTable, user.TokensColumn),
                )
                fromU = sqlgraph.SetNeighbors(uq.driver.Dialect(), step)
                return fromU, nil</span>
        }
        <span class="cov0" title="0">return query</span>
}

// First returns the first User entity from the query.
// Returns a *NotFoundError when no User was found.
func (uq *UserQuery) First(ctx context.Context) (*User, error) <span class="cov0" title="0">{
        nodes, err := uq.Limit(1).All(setContextOp(ctx, uq.ctx, "First"))
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">if len(nodes) == 0 </span><span class="cov0" title="0">{
                return nil, &amp;NotFoundError{user.Label}
        }</span>
        <span class="cov0" title="0">return nodes[0], nil</span>
}

// FirstX is like First, but panics if an error occurs.
func (uq *UserQuery) FirstX(ctx context.Context) *User <span class="cov0" title="0">{
        node, err := uq.First(ctx)
        if err != nil &amp;&amp; !IsNotFound(err) </span><span class="cov0" title="0">{
                panic(err)</span>
        }
        <span class="cov0" title="0">return node</span>
}

// FirstID returns the first User ID from the query.
// Returns a *NotFoundError when no User ID was found.
func (uq *UserQuery) FirstID(ctx context.Context) (id string, err error) <span class="cov0" title="0">{
        var ids []string
        if ids, err = uq.Limit(1).IDs(setContextOp(ctx, uq.ctx, "FirstID")); err != nil </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov0" title="0">if len(ids) == 0 </span><span class="cov0" title="0">{
                err = &amp;NotFoundError{user.Label}
                return
        }</span>
        <span class="cov0" title="0">return ids[0], nil</span>
}

// FirstIDX is like FirstID, but panics if an error occurs.
func (uq *UserQuery) FirstIDX(ctx context.Context) string <span class="cov0" title="0">{
        id, err := uq.FirstID(ctx)
        if err != nil &amp;&amp; !IsNotFound(err) </span><span class="cov0" title="0">{
                panic(err)</span>
        }
        <span class="cov0" title="0">return id</span>
}

// Only returns a single User entity found by the query, ensuring it only returns one.
// Returns a *NotSingularError when more than one User entity is found.
// Returns a *NotFoundError when no User entities are found.
func (uq *UserQuery) Only(ctx context.Context) (*User, error) <span class="cov9" title="22">{
        nodes, err := uq.Limit(2).All(setContextOp(ctx, uq.ctx, "Only"))
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov9" title="22">switch len(nodes) </span>{
        case 1:<span class="cov8" title="17">
                return nodes[0], nil</span>
        case 0:<span class="cov5" title="5">
                return nil, &amp;NotFoundError{user.Label}</span>
        default:<span class="cov0" title="0">
                return nil, &amp;NotSingularError{user.Label}</span>
        }
}

// OnlyX is like Only, but panics if an error occurs.
func (uq *UserQuery) OnlyX(ctx context.Context) *User <span class="cov0" title="0">{
        node, err := uq.Only(ctx)
        if err != nil </span><span class="cov0" title="0">{
                panic(err)</span>
        }
        <span class="cov0" title="0">return node</span>
}

// OnlyID is like Only, but returns the only User ID in the query.
// Returns a *NotSingularError when more than one User ID is found.
// Returns a *NotFoundError when no entities are found.
func (uq *UserQuery) OnlyID(ctx context.Context) (id string, err error) <span class="cov0" title="0">{
        var ids []string
        if ids, err = uq.Limit(2).IDs(setContextOp(ctx, uq.ctx, "OnlyID")); err != nil </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov0" title="0">switch len(ids) </span>{
        case 1:<span class="cov0" title="0">
                id = ids[0]</span>
        case 0:<span class="cov0" title="0">
                err = &amp;NotFoundError{user.Label}</span>
        default:<span class="cov0" title="0">
                err = &amp;NotSingularError{user.Label}</span>
        }
        <span class="cov0" title="0">return</span>
}

// OnlyIDX is like OnlyID, but panics if an error occurs.
func (uq *UserQuery) OnlyIDX(ctx context.Context) string <span class="cov0" title="0">{
        id, err := uq.OnlyID(ctx)
        if err != nil </span><span class="cov0" title="0">{
                panic(err)</span>
        }
        <span class="cov0" title="0">return id</span>
}

// All executes the query and returns a list of Users.
func (uq *UserQuery) All(ctx context.Context) ([]*User, error) <span class="cov9" title="27">{
        ctx = setContextOp(ctx, uq.ctx, "All")
        if err := uq.prepareQuery(ctx); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov9" title="27">qr := querierAll[[]*User, *UserQuery]()
        return withInterceptors[[]*User](ctx, uq, qr, uq.inters)</span>
}

// AllX is like All, but panics if an error occurs.
func (uq *UserQuery) AllX(ctx context.Context) []*User <span class="cov0" title="0">{
        nodes, err := uq.All(ctx)
        if err != nil </span><span class="cov0" title="0">{
                panic(err)</span>
        }
        <span class="cov0" title="0">return nodes</span>
}

// IDs executes the query and returns a list of User IDs.
func (uq *UserQuery) IDs(ctx context.Context) (ids []string, err error) <span class="cov0" title="0">{
        if uq.ctx.Unique == nil &amp;&amp; uq.path != nil </span><span class="cov0" title="0">{
                uq.Unique(true)
        }</span>
        <span class="cov0" title="0">ctx = setContextOp(ctx, uq.ctx, "IDs")
        if err = uq.Select(user.FieldID).Scan(ctx, &amp;ids); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return ids, nil</span>
}

// IDsX is like IDs, but panics if an error occurs.
func (uq *UserQuery) IDsX(ctx context.Context) []string <span class="cov0" title="0">{
        ids, err := uq.IDs(ctx)
        if err != nil </span><span class="cov0" title="0">{
                panic(err)</span>
        }
        <span class="cov0" title="0">return ids</span>
}

// Count returns the count of the given query.
func (uq *UserQuery) Count(ctx context.Context) (int, error) <span class="cov2" title="2">{
        ctx = setContextOp(ctx, uq.ctx, "Count")
        if err := uq.prepareQuery(ctx); err != nil </span><span class="cov0" title="0">{
                return 0, err
        }</span>
        <span class="cov2" title="2">return withInterceptors[int](ctx, uq, querierCount[*UserQuery](), uq.inters)</span>
}

// CountX is like Count, but panics if an error occurs.
func (uq *UserQuery) CountX(ctx context.Context) int <span class="cov0" title="0">{
        count, err := uq.Count(ctx)
        if err != nil </span><span class="cov0" title="0">{
                panic(err)</span>
        }
        <span class="cov0" title="0">return count</span>
}

// Exist returns true if the query has elements in the graph.
func (uq *UserQuery) Exist(ctx context.Context) (bool, error) <span class="cov0" title="0">{
        ctx = setContextOp(ctx, uq.ctx, "Exist")
        switch _, err := uq.FirstID(ctx); </span>{
        case IsNotFound(err):<span class="cov0" title="0">
                return false, nil</span>
        case err != nil:<span class="cov0" title="0">
                return false, fmt.Errorf("ent: check existence: %w", err)</span>
        default:<span class="cov0" title="0">
                return true, nil</span>
        }
}

// ExistX is like Exist, but panics if an error occurs.
func (uq *UserQuery) ExistX(ctx context.Context) bool <span class="cov0" title="0">{
        exist, err := uq.Exist(ctx)
        if err != nil </span><span class="cov0" title="0">{
                panic(err)</span>
        }
        <span class="cov0" title="0">return exist</span>
}

// Clone returns a duplicate of the UserQuery builder, including all associated steps. It can be
// used to prepare common query builders and use them differently after the clone is made.
func (uq *UserQuery) Clone() *UserQuery <span class="cov0" title="0">{
        if uq == nil </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov0" title="0">return &amp;UserQuery{
                config:     uq.config,
                ctx:        uq.ctx.Clone(),
                order:      append([]user.OrderOption{}, uq.order...),
                inters:     append([]Interceptor{}, uq.inters...),
                predicates: append([]predicate.User{}, uq.predicates...),
                withRoles:  uq.withRoles.Clone(),
                withTokens: uq.withTokens.Clone(),
                // clone intermediate query.
                sql:  uq.sql.Clone(),
                path: uq.path,
        }</span>
}

// WithRoles tells the query-builder to eager-load the nodes that are connected to
// the "roles" edge. The optional arguments are used to configure the query builder of the edge.
func (uq *UserQuery) WithRoles(opts ...func(*RoleQuery)) *UserQuery <span class="cov3" title="3">{
        query := (&amp;RoleClient{config: uq.config}).Query()
        for _, opt := range opts </span><span class="cov0" title="0">{
                opt(query)
        }</span>
        <span class="cov3" title="3">uq.withRoles = query
        return uq</span>
}

// WithTokens tells the query-builder to eager-load the nodes that are connected to
// the "tokens" edge. The optional arguments are used to configure the query builder of the edge.
func (uq *UserQuery) WithTokens(opts ...func(*TokenQuery)) *UserQuery <span class="cov0" title="0">{
        query := (&amp;TokenClient{config: uq.config}).Query()
        for _, opt := range opts </span><span class="cov0" title="0">{
                opt(query)
        }</span>
        <span class="cov0" title="0">uq.withTokens = query
        return uq</span>
}

// GroupBy is used to group vertices by one or more fields/columns.
// It is often used with aggregate functions, like: count, max, mean, min, sum.
//
// Example:
//
//        var v []struct {
//                Username string `json:"username,omitempty"`
//                Count int `json:"count,omitempty"`
//        }
//
//        client.User.Query().
//                GroupBy(user.FieldUsername).
//                Aggregate(ent.Count()).
//                Scan(ctx, &amp;v)
func (uq *UserQuery) GroupBy(field string, fields ...string) *UserGroupBy <span class="cov0" title="0">{
        uq.ctx.Fields = append([]string{field}, fields...)
        grbuild := &amp;UserGroupBy{build: uq}
        grbuild.flds = &amp;uq.ctx.Fields
        grbuild.label = user.Label
        grbuild.scan = grbuild.Scan
        return grbuild
}</span>

// Select allows the selection one or more fields/columns for the given query,
// instead of selecting all fields in the entity.
//
// Example:
//
//        var v []struct {
//                Username string `json:"username,omitempty"`
//        }
//
//        client.User.Query().
//                Select(user.FieldUsername).
//                Scan(ctx, &amp;v)
func (uq *UserQuery) Select(fields ...string) *UserSelect <span class="cov0" title="0">{
        uq.ctx.Fields = append(uq.ctx.Fields, fields...)
        sbuild := &amp;UserSelect{UserQuery: uq}
        sbuild.label = user.Label
        sbuild.flds, sbuild.scan = &amp;uq.ctx.Fields, sbuild.Scan
        return sbuild
}</span>

// Aggregate returns a UserSelect configured with the given aggregations.
func (uq *UserQuery) Aggregate(fns ...AggregateFunc) *UserSelect <span class="cov0" title="0">{
        return uq.Select().Aggregate(fns...)
}</span>

func (uq *UserQuery) prepareQuery(ctx context.Context) error <span class="cov10" title="30">{
        for _, inter := range uq.inters </span><span class="cov0" title="0">{
                if inter == nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("ent: uninitialized interceptor (forgotten import ent/runtime?)")
                }</span>
                <span class="cov0" title="0">if trv, ok := inter.(Traverser); ok </span><span class="cov0" title="0">{
                        if err := trv.Traverse(ctx, uq); err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                }
        }
        <span class="cov10" title="30">for _, f := range uq.ctx.Fields </span><span class="cov0" title="0">{
                if !user.ValidColumn(f) </span><span class="cov0" title="0">{
                        return &amp;ValidationError{Name: f, err: fmt.Errorf("ent: invalid field %q for query", f)}
                }</span>
        }
        <span class="cov10" title="30">if uq.path != nil </span><span class="cov2" title="2">{
                prev, err := uq.path(ctx)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov2" title="2">uq.sql = prev</span>
        }
        <span class="cov10" title="30">return nil</span>
}

func (uq *UserQuery) sqlAll(ctx context.Context, hooks ...queryHook) ([]*User, error) <span class="cov9" title="28">{
        var (
                nodes       = []*User{}
                _spec       = uq.querySpec()
                loadedTypes = [2]bool{
                        uq.withRoles != nil,
                        uq.withTokens != nil,
                }
        )
        _spec.ScanValues = func(columns []string) ([]any, error) </span><span class="cov9" title="28">{
                return (*User).scanValues(nil, columns)
        }</span>
        <span class="cov9" title="28">_spec.Assign = func(columns []string, values []any) error </span><span class="cov9" title="28">{
                node := &amp;User{config: uq.config}
                nodes = append(nodes, node)
                node.Edges.loadedTypes = loadedTypes
                return node.assignValues(columns, values)
        }</span>
        <span class="cov9" title="28">for i := range hooks </span><span class="cov1" title="1">{
                hooks[i](ctx, _spec)
        }</span>
        <span class="cov9" title="28">if err := sqlgraph.QueryNodes(ctx, uq.driver, _spec); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov9" title="28">if len(nodes) == 0 </span><span class="cov5" title="5">{
                return nodes, nil
        }</span>
        <span class="cov9" title="23">if query := uq.withRoles; query != nil </span><span class="cov3" title="3">{
                if err := uq.loadRoles(ctx, query, nodes,
                        func(n *User) </span><span class="cov3" title="3">{ n.Edges.Roles = []*Role{} }</span>,
                        func(n *User, e *Role) <span class="cov2" title="2">{ n.Edges.Roles = append(n.Edges.Roles, e) }</span>); err != nil <span class="cov0" title="0">{
                        return nil, err
                }</span>
        }
        <span class="cov9" title="23">if query := uq.withTokens; query != nil </span><span class="cov0" title="0">{
                if err := uq.loadTokens(ctx, query, nodes,
                        func(n *User) </span><span class="cov0" title="0">{ n.Edges.Tokens = []*Token{} }</span>,
                        func(n *User, e *Token) <span class="cov0" title="0">{ n.Edges.Tokens = append(n.Edges.Tokens, e) }</span>); err != nil <span class="cov0" title="0">{
                        return nil, err
                }</span>
        }
        <span class="cov9" title="23">return nodes, nil</span>
}

func (uq *UserQuery) loadRoles(ctx context.Context, query *RoleQuery, nodes []*User, init func(*User), assign func(*User, *Role)) error <span class="cov3" title="3">{
        edgeIDs := make([]driver.Value, len(nodes))
        byID := make(map[string]*User)
        nids := make(map[string]map[*User]struct{})
        for i, node := range nodes </span><span class="cov3" title="3">{
                edgeIDs[i] = node.ID
                byID[node.ID] = node
                if init != nil </span><span class="cov3" title="3">{
                        init(node)
                }</span>
        }
        <span class="cov3" title="3">query.Where(func(s *sql.Selector) </span><span class="cov3" title="3">{
                joinT := sql.Table(user.RolesTable)
                s.Join(joinT).On(s.C(role.FieldID), joinT.C(user.RolesPrimaryKey[1]))
                s.Where(sql.InValues(joinT.C(user.RolesPrimaryKey[0]), edgeIDs...))
                columns := s.SelectedColumns()
                s.Select(joinT.C(user.RolesPrimaryKey[0]))
                s.AppendSelect(columns...)
                s.SetDistinct(false)
        }</span>)
        <span class="cov3" title="3">if err := query.prepareQuery(ctx); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov3" title="3">qr := QuerierFunc(func(ctx context.Context, q Query) (Value, error) </span><span class="cov3" title="3">{
                return query.sqlAll(ctx, func(_ context.Context, spec *sqlgraph.QuerySpec) </span><span class="cov3" title="3">{
                        assign := spec.Assign
                        values := spec.ScanValues
                        spec.ScanValues = func(columns []string) ([]any, error) </span><span class="cov2" title="2">{
                                values, err := values(columns[1:])
                                if err != nil </span><span class="cov0" title="0">{
                                        return nil, err
                                }</span>
                                <span class="cov2" title="2">return append([]any{new(sql.NullString)}, values...), nil</span>
                        }
                        <span class="cov3" title="3">spec.Assign = func(columns []string, values []any) error </span><span class="cov2" title="2">{
                                outValue := values[0].(*sql.NullString).String
                                inValue := values[1].(*sql.NullString).String
                                if nids[inValue] == nil </span><span class="cov2" title="2">{
                                        nids[inValue] = map[*User]struct{}{byID[outValue]: {}}
                                        return assign(columns[1:], values[1:])
                                }</span>
                                <span class="cov0" title="0">nids[inValue][byID[outValue]] = struct{}{}
                                return nil</span>
                        }
                })
        })
        <span class="cov3" title="3">neighbors, err := withInterceptors[[]*Role](ctx, query, qr, query.inters)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov3" title="3">for _, n := range neighbors </span><span class="cov2" title="2">{
                nodes, ok := nids[n.ID]
                if !ok </span><span class="cov0" title="0">{
                        return fmt.Errorf(`unexpected "roles" node returned %v`, n.ID)
                }</span>
                <span class="cov2" title="2">for kn := range nodes </span><span class="cov2" title="2">{
                        assign(kn, n)
                }</span>
        }
        <span class="cov3" title="3">return nil</span>
}
func (uq *UserQuery) loadTokens(ctx context.Context, query *TokenQuery, nodes []*User, init func(*User), assign func(*User, *Token)) error <span class="cov0" title="0">{
        fks := make([]driver.Value, 0, len(nodes))
        nodeids := make(map[string]*User)
        for i := range nodes </span><span class="cov0" title="0">{
                fks = append(fks, nodes[i].ID)
                nodeids[nodes[i].ID] = nodes[i]
                if init != nil </span><span class="cov0" title="0">{
                        init(nodes[i])
                }</span>
        }
        <span class="cov0" title="0">query.withFKs = true
        query.Where(predicate.Token(func(s *sql.Selector) </span><span class="cov0" title="0">{
                s.Where(sql.InValues(s.C(user.TokensColumn), fks...))
        }</span>))
        <span class="cov0" title="0">neighbors, err := query.All(ctx)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">for _, n := range neighbors </span><span class="cov0" title="0">{
                fk := n.user_tokens
                if fk == nil </span><span class="cov0" title="0">{
                        return fmt.Errorf(`foreign-key "user_tokens" is nil for node %v`, n.ID)
                }</span>
                <span class="cov0" title="0">node, ok := nodeids[*fk]
                if !ok </span><span class="cov0" title="0">{
                        return fmt.Errorf(`unexpected referenced foreign-key "user_tokens" returned %v for node %v`, *fk, n.ID)
                }</span>
                <span class="cov0" title="0">assign(node, n)</span>
        }
        <span class="cov0" title="0">return nil</span>
}

func (uq *UserQuery) sqlCount(ctx context.Context) (int, error) <span class="cov2" title="2">{
        _spec := uq.querySpec()
        _spec.Node.Columns = uq.ctx.Fields
        if len(uq.ctx.Fields) &gt; 0 </span><span class="cov0" title="0">{
                _spec.Unique = uq.ctx.Unique != nil &amp;&amp; *uq.ctx.Unique
        }</span>
        <span class="cov2" title="2">return sqlgraph.CountNodes(ctx, uq.driver, _spec)</span>
}

func (uq *UserQuery) querySpec() *sqlgraph.QuerySpec <span class="cov10" title="30">{
        _spec := sqlgraph.NewQuerySpec(user.Table, user.Columns, sqlgraph.NewFieldSpec(user.FieldID, field.TypeString))
        _spec.From = uq.sql
        if unique := uq.ctx.Unique; unique != nil </span><span class="cov0" title="0">{
                _spec.Unique = *unique
        }</span> else<span class="cov10" title="30"> if uq.path != nil </span><span class="cov2" title="2">{
                _spec.Unique = true
        }</span>
        <span class="cov10" title="30">if fields := uq.ctx.Fields; len(fields) &gt; 0 </span><span class="cov0" title="0">{
                _spec.Node.Columns = make([]string, 0, len(fields))
                _spec.Node.Columns = append(_spec.Node.Columns, user.FieldID)
                for i := range fields </span><span class="cov0" title="0">{
                        if fields[i] != user.FieldID </span><span class="cov0" title="0">{
                                _spec.Node.Columns = append(_spec.Node.Columns, fields[i])
                        }</span>
                }
        }
        <span class="cov10" title="30">if ps := uq.predicates; len(ps) &gt; 0 </span><span class="cov9" title="24">{
                _spec.Predicate = func(selector *sql.Selector) </span><span class="cov9" title="24">{
                        for i := range ps </span><span class="cov9" title="24">{
                                ps[i](selector)
                        }</span>
                }
        }
        <span class="cov10" title="30">if limit := uq.ctx.Limit; limit != nil </span><span class="cov9" title="24">{
                _spec.Limit = *limit
        }</span>
        <span class="cov10" title="30">if offset := uq.ctx.Offset; offset != nil </span><span class="cov2" title="2">{
                _spec.Offset = *offset
        }</span>
        <span class="cov10" title="30">if ps := uq.order; len(ps) &gt; 0 </span><span class="cov0" title="0">{
                _spec.Order = func(selector *sql.Selector) </span><span class="cov0" title="0">{
                        for i := range ps </span><span class="cov0" title="0">{
                                ps[i](selector)
                        }</span>
                }
        }
        <span class="cov10" title="30">return _spec</span>
}

func (uq *UserQuery) sqlQuery(ctx context.Context) *sql.Selector <span class="cov0" title="0">{
        builder := sql.Dialect(uq.driver.Dialect())
        t1 := builder.Table(user.Table)
        columns := uq.ctx.Fields
        if len(columns) == 0 </span><span class="cov0" title="0">{
                columns = user.Columns
        }</span>
        <span class="cov0" title="0">selector := builder.Select(t1.Columns(columns...)...).From(t1)
        if uq.sql != nil </span><span class="cov0" title="0">{
                selector = uq.sql
                selector.Select(selector.Columns(columns...)...)
        }</span>
        <span class="cov0" title="0">if uq.ctx.Unique != nil &amp;&amp; *uq.ctx.Unique </span><span class="cov0" title="0">{
                selector.Distinct()
        }</span>
        <span class="cov0" title="0">for _, p := range uq.predicates </span><span class="cov0" title="0">{
                p(selector)
        }</span>
        <span class="cov0" title="0">for _, p := range uq.order </span><span class="cov0" title="0">{
                p(selector)
        }</span>
        <span class="cov0" title="0">if offset := uq.ctx.Offset; offset != nil </span><span class="cov0" title="0">{
                // limit is mandatory for offset clause. We start
                // with default value, and override it below if needed.
                selector.Offset(*offset).Limit(math.MaxInt32)
        }</span>
        <span class="cov0" title="0">if limit := uq.ctx.Limit; limit != nil </span><span class="cov0" title="0">{
                selector.Limit(*limit)
        }</span>
        <span class="cov0" title="0">return selector</span>
}

// UserGroupBy is the group-by builder for User entities.
type UserGroupBy struct {
        selector
        build *UserQuery
}

// Aggregate adds the given aggregation functions to the group-by query.
func (ugb *UserGroupBy) Aggregate(fns ...AggregateFunc) *UserGroupBy <span class="cov0" title="0">{
        ugb.fns = append(ugb.fns, fns...)
        return ugb
}</span>

// Scan applies the selector query and scans the result into the given value.
func (ugb *UserGroupBy) Scan(ctx context.Context, v any) error <span class="cov0" title="0">{
        ctx = setContextOp(ctx, ugb.build.ctx, "GroupBy")
        if err := ugb.build.prepareQuery(ctx); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">return scanWithInterceptors[*UserQuery, *UserGroupBy](ctx, ugb.build, ugb, ugb.build.inters, v)</span>
}

func (ugb *UserGroupBy) sqlScan(ctx context.Context, root *UserQuery, v any) error <span class="cov0" title="0">{
        selector := root.sqlQuery(ctx).Select()
        aggregation := make([]string, 0, len(ugb.fns))
        for _, fn := range ugb.fns </span><span class="cov0" title="0">{
                aggregation = append(aggregation, fn(selector))
        }</span>
        <span class="cov0" title="0">if len(selector.SelectedColumns()) == 0 </span><span class="cov0" title="0">{
                columns := make([]string, 0, len(*ugb.flds)+len(ugb.fns))
                for _, f := range *ugb.flds </span><span class="cov0" title="0">{
                        columns = append(columns, selector.C(f))
                }</span>
                <span class="cov0" title="0">columns = append(columns, aggregation...)
                selector.Select(columns...)</span>
        }
        <span class="cov0" title="0">selector.GroupBy(selector.Columns(*ugb.flds...)...)
        if err := selector.Err(); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">rows := &amp;sql.Rows{}
        query, args := selector.Query()
        if err := ugb.build.driver.Query(ctx, query, args, rows); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">defer rows.Close()
        return sql.ScanSlice(rows, v)</span>
}

// UserSelect is the builder for selecting fields of User entities.
type UserSelect struct {
        *UserQuery
        selector
}

// Aggregate adds the given aggregation functions to the selector query.
func (us *UserSelect) Aggregate(fns ...AggregateFunc) *UserSelect <span class="cov0" title="0">{
        us.fns = append(us.fns, fns...)
        return us
}</span>

// Scan applies the selector query and scans the result into the given value.
func (us *UserSelect) Scan(ctx context.Context, v any) error <span class="cov0" title="0">{
        ctx = setContextOp(ctx, us.ctx, "Select")
        if err := us.prepareQuery(ctx); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">return scanWithInterceptors[*UserQuery, *UserSelect](ctx, us.UserQuery, us, us.inters, v)</span>
}

func (us *UserSelect) sqlScan(ctx context.Context, root *UserQuery, v any) error <span class="cov0" title="0">{
        selector := root.sqlQuery(ctx)
        aggregation := make([]string, 0, len(us.fns))
        for _, fn := range us.fns </span><span class="cov0" title="0">{
                aggregation = append(aggregation, fn(selector))
        }</span>
        <span class="cov0" title="0">switch n := len(*us.selector.flds); </span>{
        case n == 0 &amp;&amp; len(aggregation) &gt; 0:<span class="cov0" title="0">
                selector.Select(aggregation...)</span>
        case n != 0 &amp;&amp; len(aggregation) &gt; 0:<span class="cov0" title="0">
                selector.AppendSelect(aggregation...)</span>
        }
        <span class="cov0" title="0">rows := &amp;sql.Rows{}
        query, args := selector.Query()
        if err := us.driver.Query(ctx, query, args, rows); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">defer rows.Close()
        return sql.ScanSlice(rows, v)</span>
}
</pre>
		
		<pre class="file" id="file33" style="display: none">// Code generated by ent, DO NOT EDIT.

package ent

import (
        "auth/ent/predicate"
        "auth/ent/role"
        "auth/ent/token"
        "auth/ent/user"
        "context"
        "errors"
        "fmt"
        "time"

        "entgo.io/ent/dialect/sql"
        "entgo.io/ent/dialect/sql/sqlgraph"
        "entgo.io/ent/schema/field"
)

// UserUpdate is the builder for updating User entities.
type UserUpdate struct {
        config
        hooks    []Hook
        mutation *UserMutation
}

// Where appends a list predicates to the UserUpdate builder.
func (uu *UserUpdate) Where(ps ...predicate.User) *UserUpdate <span class="cov0" title="0">{
        uu.mutation.Where(ps...)
        return uu
}</span>

// SetUsername sets the "username" field.
func (uu *UserUpdate) SetUsername(s string) *UserUpdate <span class="cov0" title="0">{
        uu.mutation.SetUsername(s)
        return uu
}</span>

// SetNillableUsername sets the "username" field if the given value is not nil.
func (uu *UserUpdate) SetNillableUsername(s *string) *UserUpdate <span class="cov0" title="0">{
        if s != nil </span><span class="cov0" title="0">{
                uu.SetUsername(*s)
        }</span>
        <span class="cov0" title="0">return uu</span>
}

// SetEmail sets the "email" field.
func (uu *UserUpdate) SetEmail(s string) *UserUpdate <span class="cov0" title="0">{
        uu.mutation.SetEmail(s)
        return uu
}</span>

// SetNillableEmail sets the "email" field if the given value is not nil.
func (uu *UserUpdate) SetNillableEmail(s *string) *UserUpdate <span class="cov0" title="0">{
        if s != nil </span><span class="cov0" title="0">{
                uu.SetEmail(*s)
        }</span>
        <span class="cov0" title="0">return uu</span>
}

// SetPassword sets the "password" field.
func (uu *UserUpdate) SetPassword(s string) *UserUpdate <span class="cov0" title="0">{
        uu.mutation.SetPassword(s)
        return uu
}</span>

// SetNillablePassword sets the "password" field if the given value is not nil.
func (uu *UserUpdate) SetNillablePassword(s *string) *UserUpdate <span class="cov0" title="0">{
        if s != nil </span><span class="cov0" title="0">{
                uu.SetPassword(*s)
        }</span>
        <span class="cov0" title="0">return uu</span>
}

// SetCreatedAt sets the "created_at" field.
func (uu *UserUpdate) SetCreatedAt(t time.Time) *UserUpdate <span class="cov0" title="0">{
        uu.mutation.SetCreatedAt(t)
        return uu
}</span>

// SetNillableCreatedAt sets the "created_at" field if the given value is not nil.
func (uu *UserUpdate) SetNillableCreatedAt(t *time.Time) *UserUpdate <span class="cov0" title="0">{
        if t != nil </span><span class="cov0" title="0">{
                uu.SetCreatedAt(*t)
        }</span>
        <span class="cov0" title="0">return uu</span>
}

// SetUpdatedAt sets the "updated_at" field.
func (uu *UserUpdate) SetUpdatedAt(t time.Time) *UserUpdate <span class="cov0" title="0">{
        uu.mutation.SetUpdatedAt(t)
        return uu
}</span>

// AddRoleIDs adds the "roles" edge to the Role entity by IDs.
func (uu *UserUpdate) AddRoleIDs(ids ...string) *UserUpdate <span class="cov0" title="0">{
        uu.mutation.AddRoleIDs(ids...)
        return uu
}</span>

// AddRoles adds the "roles" edges to the Role entity.
func (uu *UserUpdate) AddRoles(r ...*Role) *UserUpdate <span class="cov0" title="0">{
        ids := make([]string, len(r))
        for i := range r </span><span class="cov0" title="0">{
                ids[i] = r[i].ID
        }</span>
        <span class="cov0" title="0">return uu.AddRoleIDs(ids...)</span>
}

// AddTokenIDs adds the "tokens" edge to the Token entity by IDs.
func (uu *UserUpdate) AddTokenIDs(ids ...string) *UserUpdate <span class="cov0" title="0">{
        uu.mutation.AddTokenIDs(ids...)
        return uu
}</span>

// AddTokens adds the "tokens" edges to the Token entity.
func (uu *UserUpdate) AddTokens(t ...*Token) *UserUpdate <span class="cov0" title="0">{
        ids := make([]string, len(t))
        for i := range t </span><span class="cov0" title="0">{
                ids[i] = t[i].ID
        }</span>
        <span class="cov0" title="0">return uu.AddTokenIDs(ids...)</span>
}

// Mutation returns the UserMutation object of the builder.
func (uu *UserUpdate) Mutation() *UserMutation <span class="cov0" title="0">{
        return uu.mutation
}</span>

// ClearRoles clears all "roles" edges to the Role entity.
func (uu *UserUpdate) ClearRoles() *UserUpdate <span class="cov0" title="0">{
        uu.mutation.ClearRoles()
        return uu
}</span>

// RemoveRoleIDs removes the "roles" edge to Role entities by IDs.
func (uu *UserUpdate) RemoveRoleIDs(ids ...string) *UserUpdate <span class="cov0" title="0">{
        uu.mutation.RemoveRoleIDs(ids...)
        return uu
}</span>

// RemoveRoles removes "roles" edges to Role entities.
func (uu *UserUpdate) RemoveRoles(r ...*Role) *UserUpdate <span class="cov0" title="0">{
        ids := make([]string, len(r))
        for i := range r </span><span class="cov0" title="0">{
                ids[i] = r[i].ID
        }</span>
        <span class="cov0" title="0">return uu.RemoveRoleIDs(ids...)</span>
}

// ClearTokens clears all "tokens" edges to the Token entity.
func (uu *UserUpdate) ClearTokens() *UserUpdate <span class="cov0" title="0">{
        uu.mutation.ClearTokens()
        return uu
}</span>

// RemoveTokenIDs removes the "tokens" edge to Token entities by IDs.
func (uu *UserUpdate) RemoveTokenIDs(ids ...string) *UserUpdate <span class="cov0" title="0">{
        uu.mutation.RemoveTokenIDs(ids...)
        return uu
}</span>

// RemoveTokens removes "tokens" edges to Token entities.
func (uu *UserUpdate) RemoveTokens(t ...*Token) *UserUpdate <span class="cov0" title="0">{
        ids := make([]string, len(t))
        for i := range t </span><span class="cov0" title="0">{
                ids[i] = t[i].ID
        }</span>
        <span class="cov0" title="0">return uu.RemoveTokenIDs(ids...)</span>
}

// Save executes the query and returns the number of nodes affected by the update operation.
func (uu *UserUpdate) Save(ctx context.Context) (int, error) <span class="cov0" title="0">{
        if err := uu.defaults(); err != nil </span><span class="cov0" title="0">{
                return 0, err
        }</span>
        <span class="cov0" title="0">return withHooks(ctx, uu.sqlSave, uu.mutation, uu.hooks)</span>
}

// SaveX is like Save, but panics if an error occurs.
func (uu *UserUpdate) SaveX(ctx context.Context) int <span class="cov0" title="0">{
        affected, err := uu.Save(ctx)
        if err != nil </span><span class="cov0" title="0">{
                panic(err)</span>
        }
        <span class="cov0" title="0">return affected</span>
}

// Exec executes the query.
func (uu *UserUpdate) Exec(ctx context.Context) error <span class="cov0" title="0">{
        _, err := uu.Save(ctx)
        return err
}</span>

// ExecX is like Exec, but panics if an error occurs.
func (uu *UserUpdate) ExecX(ctx context.Context) <span class="cov0" title="0">{
        if err := uu.Exec(ctx); err != nil </span><span class="cov0" title="0">{
                panic(err)</span>
        }
}

// defaults sets the default values of the builder before save.
func (uu *UserUpdate) defaults() error <span class="cov0" title="0">{
        if _, ok := uu.mutation.UpdatedAt(); !ok </span><span class="cov0" title="0">{
                if user.UpdateDefaultUpdatedAt == nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("ent: uninitialized user.UpdateDefaultUpdatedAt (forgotten import ent/runtime?)")
                }</span>
                <span class="cov0" title="0">v := user.UpdateDefaultUpdatedAt()
                uu.mutation.SetUpdatedAt(v)</span>
        }
        <span class="cov0" title="0">return nil</span>
}

func (uu *UserUpdate) sqlSave(ctx context.Context) (n int, err error) <span class="cov0" title="0">{
        _spec := sqlgraph.NewUpdateSpec(user.Table, user.Columns, sqlgraph.NewFieldSpec(user.FieldID, field.TypeString))
        if ps := uu.mutation.predicates; len(ps) &gt; 0 </span><span class="cov0" title="0">{
                _spec.Predicate = func(selector *sql.Selector) </span><span class="cov0" title="0">{
                        for i := range ps </span><span class="cov0" title="0">{
                                ps[i](selector)
                        }</span>
                }
        }
        <span class="cov0" title="0">if value, ok := uu.mutation.Username(); ok </span><span class="cov0" title="0">{
                _spec.SetField(user.FieldUsername, field.TypeString, value)
        }</span>
        <span class="cov0" title="0">if value, ok := uu.mutation.Email(); ok </span><span class="cov0" title="0">{
                _spec.SetField(user.FieldEmail, field.TypeString, value)
        }</span>
        <span class="cov0" title="0">if value, ok := uu.mutation.Password(); ok </span><span class="cov0" title="0">{
                _spec.SetField(user.FieldPassword, field.TypeString, value)
        }</span>
        <span class="cov0" title="0">if value, ok := uu.mutation.CreatedAt(); ok </span><span class="cov0" title="0">{
                _spec.SetField(user.FieldCreatedAt, field.TypeTime, value)
        }</span>
        <span class="cov0" title="0">if value, ok := uu.mutation.UpdatedAt(); ok </span><span class="cov0" title="0">{
                _spec.SetField(user.FieldUpdatedAt, field.TypeTime, value)
        }</span>
        <span class="cov0" title="0">if uu.mutation.RolesCleared() </span><span class="cov0" title="0">{
                edge := &amp;sqlgraph.EdgeSpec{
                        Rel:     sqlgraph.M2M,
                        Inverse: false,
                        Table:   user.RolesTable,
                        Columns: user.RolesPrimaryKey,
                        Bidi:    false,
                        Target: &amp;sqlgraph.EdgeTarget{
                                IDSpec: sqlgraph.NewFieldSpec(role.FieldID, field.TypeString),
                        },
                }
                _spec.Edges.Clear = append(_spec.Edges.Clear, edge)
        }</span>
        <span class="cov0" title="0">if nodes := uu.mutation.RemovedRolesIDs(); len(nodes) &gt; 0 &amp;&amp; !uu.mutation.RolesCleared() </span><span class="cov0" title="0">{
                edge := &amp;sqlgraph.EdgeSpec{
                        Rel:     sqlgraph.M2M,
                        Inverse: false,
                        Table:   user.RolesTable,
                        Columns: user.RolesPrimaryKey,
                        Bidi:    false,
                        Target: &amp;sqlgraph.EdgeTarget{
                                IDSpec: sqlgraph.NewFieldSpec(role.FieldID, field.TypeString),
                        },
                }
                for _, k := range nodes </span><span class="cov0" title="0">{
                        edge.Target.Nodes = append(edge.Target.Nodes, k)
                }</span>
                <span class="cov0" title="0">_spec.Edges.Clear = append(_spec.Edges.Clear, edge)</span>
        }
        <span class="cov0" title="0">if nodes := uu.mutation.RolesIDs(); len(nodes) &gt; 0 </span><span class="cov0" title="0">{
                edge := &amp;sqlgraph.EdgeSpec{
                        Rel:     sqlgraph.M2M,
                        Inverse: false,
                        Table:   user.RolesTable,
                        Columns: user.RolesPrimaryKey,
                        Bidi:    false,
                        Target: &amp;sqlgraph.EdgeTarget{
                                IDSpec: sqlgraph.NewFieldSpec(role.FieldID, field.TypeString),
                        },
                }
                for _, k := range nodes </span><span class="cov0" title="0">{
                        edge.Target.Nodes = append(edge.Target.Nodes, k)
                }</span>
                <span class="cov0" title="0">_spec.Edges.Add = append(_spec.Edges.Add, edge)</span>
        }
        <span class="cov0" title="0">if uu.mutation.TokensCleared() </span><span class="cov0" title="0">{
                edge := &amp;sqlgraph.EdgeSpec{
                        Rel:     sqlgraph.O2M,
                        Inverse: false,
                        Table:   user.TokensTable,
                        Columns: []string{user.TokensColumn},
                        Bidi:    false,
                        Target: &amp;sqlgraph.EdgeTarget{
                                IDSpec: sqlgraph.NewFieldSpec(token.FieldID, field.TypeString),
                        },
                }
                _spec.Edges.Clear = append(_spec.Edges.Clear, edge)
        }</span>
        <span class="cov0" title="0">if nodes := uu.mutation.RemovedTokensIDs(); len(nodes) &gt; 0 &amp;&amp; !uu.mutation.TokensCleared() </span><span class="cov0" title="0">{
                edge := &amp;sqlgraph.EdgeSpec{
                        Rel:     sqlgraph.O2M,
                        Inverse: false,
                        Table:   user.TokensTable,
                        Columns: []string{user.TokensColumn},
                        Bidi:    false,
                        Target: &amp;sqlgraph.EdgeTarget{
                                IDSpec: sqlgraph.NewFieldSpec(token.FieldID, field.TypeString),
                        },
                }
                for _, k := range nodes </span><span class="cov0" title="0">{
                        edge.Target.Nodes = append(edge.Target.Nodes, k)
                }</span>
                <span class="cov0" title="0">_spec.Edges.Clear = append(_spec.Edges.Clear, edge)</span>
        }
        <span class="cov0" title="0">if nodes := uu.mutation.TokensIDs(); len(nodes) &gt; 0 </span><span class="cov0" title="0">{
                edge := &amp;sqlgraph.EdgeSpec{
                        Rel:     sqlgraph.O2M,
                        Inverse: false,
                        Table:   user.TokensTable,
                        Columns: []string{user.TokensColumn},
                        Bidi:    false,
                        Target: &amp;sqlgraph.EdgeTarget{
                                IDSpec: sqlgraph.NewFieldSpec(token.FieldID, field.TypeString),
                        },
                }
                for _, k := range nodes </span><span class="cov0" title="0">{
                        edge.Target.Nodes = append(edge.Target.Nodes, k)
                }</span>
                <span class="cov0" title="0">_spec.Edges.Add = append(_spec.Edges.Add, edge)</span>
        }
        <span class="cov0" title="0">if n, err = sqlgraph.UpdateNodes(ctx, uu.driver, _spec); err != nil </span><span class="cov0" title="0">{
                if _, ok := err.(*sqlgraph.NotFoundError); ok </span><span class="cov0" title="0">{
                        err = &amp;NotFoundError{user.Label}
                }</span> else<span class="cov0" title="0"> if sqlgraph.IsConstraintError(err) </span><span class="cov0" title="0">{
                        err = &amp;ConstraintError{msg: err.Error(), wrap: err}
                }</span>
                <span class="cov0" title="0">return 0, err</span>
        }
        <span class="cov0" title="0">uu.mutation.done = true
        return n, nil</span>
}

// UserUpdateOne is the builder for updating a single User entity.
type UserUpdateOne struct {
        config
        fields   []string
        hooks    []Hook
        mutation *UserMutation
}

// SetUsername sets the "username" field.
func (uuo *UserUpdateOne) SetUsername(s string) *UserUpdateOne <span class="cov1" title="1">{
        uuo.mutation.SetUsername(s)
        return uuo
}</span>

// SetNillableUsername sets the "username" field if the given value is not nil.
func (uuo *UserUpdateOne) SetNillableUsername(s *string) *UserUpdateOne <span class="cov0" title="0">{
        if s != nil </span><span class="cov0" title="0">{
                uuo.SetUsername(*s)
        }</span>
        <span class="cov0" title="0">return uuo</span>
}

// SetEmail sets the "email" field.
func (uuo *UserUpdateOne) SetEmail(s string) *UserUpdateOne <span class="cov1" title="1">{
        uuo.mutation.SetEmail(s)
        return uuo
}</span>

// SetNillableEmail sets the "email" field if the given value is not nil.
func (uuo *UserUpdateOne) SetNillableEmail(s *string) *UserUpdateOne <span class="cov0" title="0">{
        if s != nil </span><span class="cov0" title="0">{
                uuo.SetEmail(*s)
        }</span>
        <span class="cov0" title="0">return uuo</span>
}

// SetPassword sets the "password" field.
func (uuo *UserUpdateOne) SetPassword(s string) *UserUpdateOne <span class="cov4" title="3">{
        uuo.mutation.SetPassword(s)
        return uuo
}</span>

// SetNillablePassword sets the "password" field if the given value is not nil.
func (uuo *UserUpdateOne) SetNillablePassword(s *string) *UserUpdateOne <span class="cov0" title="0">{
        if s != nil </span><span class="cov0" title="0">{
                uuo.SetPassword(*s)
        }</span>
        <span class="cov0" title="0">return uuo</span>
}

// SetCreatedAt sets the "created_at" field.
func (uuo *UserUpdateOne) SetCreatedAt(t time.Time) *UserUpdateOne <span class="cov0" title="0">{
        uuo.mutation.SetCreatedAt(t)
        return uuo
}</span>

// SetNillableCreatedAt sets the "created_at" field if the given value is not nil.
func (uuo *UserUpdateOne) SetNillableCreatedAt(t *time.Time) *UserUpdateOne <span class="cov0" title="0">{
        if t != nil </span><span class="cov0" title="0">{
                uuo.SetCreatedAt(*t)
        }</span>
        <span class="cov0" title="0">return uuo</span>
}

// SetUpdatedAt sets the "updated_at" field.
func (uuo *UserUpdateOne) SetUpdatedAt(t time.Time) *UserUpdateOne <span class="cov3" title="2">{
        uuo.mutation.SetUpdatedAt(t)
        return uuo
}</span>

// AddRoleIDs adds the "roles" edge to the Role entity by IDs.
func (uuo *UserUpdateOne) AddRoleIDs(ids ...string) *UserUpdateOne <span class="cov8" title="8">{
        uuo.mutation.AddRoleIDs(ids...)
        return uuo
}</span>

// AddRoles adds the "roles" edges to the Role entity.
func (uuo *UserUpdateOne) AddRoles(r ...*Role) *UserUpdateOne <span class="cov0" title="0">{
        ids := make([]string, len(r))
        for i := range r </span><span class="cov0" title="0">{
                ids[i] = r[i].ID
        }</span>
        <span class="cov0" title="0">return uuo.AddRoleIDs(ids...)</span>
}

// AddTokenIDs adds the "tokens" edge to the Token entity by IDs.
func (uuo *UserUpdateOne) AddTokenIDs(ids ...string) *UserUpdateOne <span class="cov0" title="0">{
        uuo.mutation.AddTokenIDs(ids...)
        return uuo
}</span>

// AddTokens adds the "tokens" edges to the Token entity.
func (uuo *UserUpdateOne) AddTokens(t ...*Token) *UserUpdateOne <span class="cov0" title="0">{
        ids := make([]string, len(t))
        for i := range t </span><span class="cov0" title="0">{
                ids[i] = t[i].ID
        }</span>
        <span class="cov0" title="0">return uuo.AddTokenIDs(ids...)</span>
}

// Mutation returns the UserMutation object of the builder.
func (uuo *UserUpdateOne) Mutation() *UserMutation <span class="cov0" title="0">{
        return uuo.mutation
}</span>

// ClearRoles clears all "roles" edges to the Role entity.
func (uuo *UserUpdateOne) ClearRoles() *UserUpdateOne <span class="cov0" title="0">{
        uuo.mutation.ClearRoles()
        return uuo
}</span>

// RemoveRoleIDs removes the "roles" edge to Role entities by IDs.
func (uuo *UserUpdateOne) RemoveRoleIDs(ids ...string) *UserUpdateOne <span class="cov3" title="2">{
        uuo.mutation.RemoveRoleIDs(ids...)
        return uuo
}</span>

// RemoveRoles removes "roles" edges to Role entities.
func (uuo *UserUpdateOne) RemoveRoles(r ...*Role) *UserUpdateOne <span class="cov0" title="0">{
        ids := make([]string, len(r))
        for i := range r </span><span class="cov0" title="0">{
                ids[i] = r[i].ID
        }</span>
        <span class="cov0" title="0">return uuo.RemoveRoleIDs(ids...)</span>
}

// ClearTokens clears all "tokens" edges to the Token entity.
func (uuo *UserUpdateOne) ClearTokens() *UserUpdateOne <span class="cov0" title="0">{
        uuo.mutation.ClearTokens()
        return uuo
}</span>

// RemoveTokenIDs removes the "tokens" edge to Token entities by IDs.
func (uuo *UserUpdateOne) RemoveTokenIDs(ids ...string) *UserUpdateOne <span class="cov0" title="0">{
        uuo.mutation.RemoveTokenIDs(ids...)
        return uuo
}</span>

// RemoveTokens removes "tokens" edges to Token entities.
func (uuo *UserUpdateOne) RemoveTokens(t ...*Token) *UserUpdateOne <span class="cov0" title="0">{
        ids := make([]string, len(t))
        for i := range t </span><span class="cov0" title="0">{
                ids[i] = t[i].ID
        }</span>
        <span class="cov0" title="0">return uuo.RemoveTokenIDs(ids...)</span>
}

// Where appends a list predicates to the UserUpdate builder.
func (uuo *UserUpdateOne) Where(ps ...predicate.User) *UserUpdateOne <span class="cov0" title="0">{
        uuo.mutation.Where(ps...)
        return uuo
}</span>

// Select allows selecting one or more fields (columns) of the returned entity.
// The default is selecting all fields defined in the entity schema.
func (uuo *UserUpdateOne) Select(field string, fields ...string) *UserUpdateOne <span class="cov0" title="0">{
        uuo.fields = append([]string{field}, fields...)
        return uuo
}</span>

// Save executes the query and returns the updated User entity.
func (uuo *UserUpdateOne) Save(ctx context.Context) (*User, error) <span class="cov10" title="13">{
        if err := uuo.defaults(); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov10" title="13">return withHooks(ctx, uuo.sqlSave, uuo.mutation, uuo.hooks)</span>
}

// SaveX is like Save, but panics if an error occurs.
func (uuo *UserUpdateOne) SaveX(ctx context.Context) *User <span class="cov0" title="0">{
        node, err := uuo.Save(ctx)
        if err != nil </span><span class="cov0" title="0">{
                panic(err)</span>
        }
        <span class="cov0" title="0">return node</span>
}

// Exec executes the query on the entity.
func (uuo *UserUpdateOne) Exec(ctx context.Context) error <span class="cov9" title="12">{
        _, err := uuo.Save(ctx)
        return err
}</span>

// ExecX is like Exec, but panics if an error occurs.
func (uuo *UserUpdateOne) ExecX(ctx context.Context) <span class="cov0" title="0">{
        if err := uuo.Exec(ctx); err != nil </span><span class="cov0" title="0">{
                panic(err)</span>
        }
}

// defaults sets the default values of the builder before save.
func (uuo *UserUpdateOne) defaults() error <span class="cov10" title="13">{
        if _, ok := uuo.mutation.UpdatedAt(); !ok </span><span class="cov9" title="11">{
                if user.UpdateDefaultUpdatedAt == nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("ent: uninitialized user.UpdateDefaultUpdatedAt (forgotten import ent/runtime?)")
                }</span>
                <span class="cov9" title="11">v := user.UpdateDefaultUpdatedAt()
                uuo.mutation.SetUpdatedAt(v)</span>
        }
        <span class="cov10" title="13">return nil</span>
}

func (uuo *UserUpdateOne) sqlSave(ctx context.Context) (_node *User, err error) <span class="cov10" title="13">{
        _spec := sqlgraph.NewUpdateSpec(user.Table, user.Columns, sqlgraph.NewFieldSpec(user.FieldID, field.TypeString))
        id, ok := uuo.mutation.ID()
        if !ok </span><span class="cov0" title="0">{
                return nil, &amp;ValidationError{Name: "id", err: errors.New(`ent: missing "User.id" for update`)}
        }</span>
        <span class="cov10" title="13">_spec.Node.ID.Value = id
        if fields := uuo.fields; len(fields) &gt; 0 </span><span class="cov0" title="0">{
                _spec.Node.Columns = make([]string, 0, len(fields))
                _spec.Node.Columns = append(_spec.Node.Columns, user.FieldID)
                for _, f := range fields </span><span class="cov0" title="0">{
                        if !user.ValidColumn(f) </span><span class="cov0" title="0">{
                                return nil, &amp;ValidationError{Name: f, err: fmt.Errorf("ent: invalid field %q for query", f)}
                        }</span>
                        <span class="cov0" title="0">if f != user.FieldID </span><span class="cov0" title="0">{
                                _spec.Node.Columns = append(_spec.Node.Columns, f)
                        }</span>
                }
        }
        <span class="cov10" title="13">if ps := uuo.mutation.predicates; len(ps) &gt; 0 </span><span class="cov0" title="0">{
                _spec.Predicate = func(selector *sql.Selector) </span><span class="cov0" title="0">{
                        for i := range ps </span><span class="cov0" title="0">{
                                ps[i](selector)
                        }</span>
                }
        }
        <span class="cov10" title="13">if value, ok := uuo.mutation.Username(); ok </span><span class="cov1" title="1">{
                _spec.SetField(user.FieldUsername, field.TypeString, value)
        }</span>
        <span class="cov10" title="13">if value, ok := uuo.mutation.Email(); ok </span><span class="cov1" title="1">{
                _spec.SetField(user.FieldEmail, field.TypeString, value)
        }</span>
        <span class="cov10" title="13">if value, ok := uuo.mutation.Password(); ok </span><span class="cov4" title="3">{
                _spec.SetField(user.FieldPassword, field.TypeString, value)
        }</span>
        <span class="cov10" title="13">if value, ok := uuo.mutation.CreatedAt(); ok </span><span class="cov0" title="0">{
                _spec.SetField(user.FieldCreatedAt, field.TypeTime, value)
        }</span>
        <span class="cov10" title="13">if value, ok := uuo.mutation.UpdatedAt(); ok </span><span class="cov10" title="13">{
                _spec.SetField(user.FieldUpdatedAt, field.TypeTime, value)
        }</span>
        <span class="cov10" title="13">if uuo.mutation.RolesCleared() </span><span class="cov0" title="0">{
                edge := &amp;sqlgraph.EdgeSpec{
                        Rel:     sqlgraph.M2M,
                        Inverse: false,
                        Table:   user.RolesTable,
                        Columns: user.RolesPrimaryKey,
                        Bidi:    false,
                        Target: &amp;sqlgraph.EdgeTarget{
                                IDSpec: sqlgraph.NewFieldSpec(role.FieldID, field.TypeString),
                        },
                }
                _spec.Edges.Clear = append(_spec.Edges.Clear, edge)
        }</span>
        <span class="cov10" title="13">if nodes := uuo.mutation.RemovedRolesIDs(); len(nodes) &gt; 0 &amp;&amp; !uuo.mutation.RolesCleared() </span><span class="cov3" title="2">{
                edge := &amp;sqlgraph.EdgeSpec{
                        Rel:     sqlgraph.M2M,
                        Inverse: false,
                        Table:   user.RolesTable,
                        Columns: user.RolesPrimaryKey,
                        Bidi:    false,
                        Target: &amp;sqlgraph.EdgeTarget{
                                IDSpec: sqlgraph.NewFieldSpec(role.FieldID, field.TypeString),
                        },
                }
                for _, k := range nodes </span><span class="cov3" title="2">{
                        edge.Target.Nodes = append(edge.Target.Nodes, k)
                }</span>
                <span class="cov3" title="2">_spec.Edges.Clear = append(_spec.Edges.Clear, edge)</span>
        }
        <span class="cov10" title="13">if nodes := uuo.mutation.RolesIDs(); len(nodes) &gt; 0 </span><span class="cov8" title="8">{
                edge := &amp;sqlgraph.EdgeSpec{
                        Rel:     sqlgraph.M2M,
                        Inverse: false,
                        Table:   user.RolesTable,
                        Columns: user.RolesPrimaryKey,
                        Bidi:    false,
                        Target: &amp;sqlgraph.EdgeTarget{
                                IDSpec: sqlgraph.NewFieldSpec(role.FieldID, field.TypeString),
                        },
                }
                for _, k := range nodes </span><span class="cov8" title="8">{
                        edge.Target.Nodes = append(edge.Target.Nodes, k)
                }</span>
                <span class="cov8" title="8">_spec.Edges.Add = append(_spec.Edges.Add, edge)</span>
        }
        <span class="cov10" title="13">if uuo.mutation.TokensCleared() </span><span class="cov0" title="0">{
                edge := &amp;sqlgraph.EdgeSpec{
                        Rel:     sqlgraph.O2M,
                        Inverse: false,
                        Table:   user.TokensTable,
                        Columns: []string{user.TokensColumn},
                        Bidi:    false,
                        Target: &amp;sqlgraph.EdgeTarget{
                                IDSpec: sqlgraph.NewFieldSpec(token.FieldID, field.TypeString),
                        },
                }
                _spec.Edges.Clear = append(_spec.Edges.Clear, edge)
        }</span>
        <span class="cov10" title="13">if nodes := uuo.mutation.RemovedTokensIDs(); len(nodes) &gt; 0 &amp;&amp; !uuo.mutation.TokensCleared() </span><span class="cov0" title="0">{
                edge := &amp;sqlgraph.EdgeSpec{
                        Rel:     sqlgraph.O2M,
                        Inverse: false,
                        Table:   user.TokensTable,
                        Columns: []string{user.TokensColumn},
                        Bidi:    false,
                        Target: &amp;sqlgraph.EdgeTarget{
                                IDSpec: sqlgraph.NewFieldSpec(token.FieldID, field.TypeString),
                        },
                }
                for _, k := range nodes </span><span class="cov0" title="0">{
                        edge.Target.Nodes = append(edge.Target.Nodes, k)
                }</span>
                <span class="cov0" title="0">_spec.Edges.Clear = append(_spec.Edges.Clear, edge)</span>
        }
        <span class="cov10" title="13">if nodes := uuo.mutation.TokensIDs(); len(nodes) &gt; 0 </span><span class="cov0" title="0">{
                edge := &amp;sqlgraph.EdgeSpec{
                        Rel:     sqlgraph.O2M,
                        Inverse: false,
                        Table:   user.TokensTable,
                        Columns: []string{user.TokensColumn},
                        Bidi:    false,
                        Target: &amp;sqlgraph.EdgeTarget{
                                IDSpec: sqlgraph.NewFieldSpec(token.FieldID, field.TypeString),
                        },
                }
                for _, k := range nodes </span><span class="cov0" title="0">{
                        edge.Target.Nodes = append(edge.Target.Nodes, k)
                }</span>
                <span class="cov0" title="0">_spec.Edges.Add = append(_spec.Edges.Add, edge)</span>
        }
        <span class="cov10" title="13">_node = &amp;User{config: uuo.config}
        _spec.Assign = _node.assignValues
        _spec.ScanValues = _node.scanValues
        if err = sqlgraph.UpdateNode(ctx, uuo.driver, _spec); err != nil </span><span class="cov0" title="0">{
                if _, ok := err.(*sqlgraph.NotFoundError); ok </span><span class="cov0" title="0">{
                        err = &amp;NotFoundError{user.Label}
                }</span> else<span class="cov0" title="0"> if sqlgraph.IsConstraintError(err) </span><span class="cov0" title="0">{
                        err = &amp;ConstraintError{msg: err.Error(), wrap: err}
                }</span>
                <span class="cov0" title="0">return nil, err</span>
        }
        <span class="cov10" title="13">uuo.mutation.done = true
        return _node, nil</span>
}
</pre>
		
		<pre class="file" id="file34" style="display: none">package main

import (
        "log"
        "net"
        "time"

        "auth/internal/auth/service"
        "auth/internal/db"
        "auth/internal/interceptor"
        "auth/internal/repository"
        pb "auth/pb"
        "pkg/config"

        "go.uber.org/zap"
        "google.golang.org/grpc"
)

func main() <span class="cov0" title="0">{
        cfg, err := config.Load()
        if err != nil </span><span class="cov0" title="0">{
                log.Fatalf("Failed to load config: %v", err)
        }</span>

        // Connect to the SQLite database
        <span class="cov0" title="0">client, err := db.ConnectEnt(db.Config{
                DatabaseURL: cfg.DatabaseURL,
        })
        if err != nil </span><span class="cov0" title="0">{
                log.Fatalf("Failed to connect to database: %v", err)
        }</span>
        <span class="cov0" title="0">defer client.Close()

        userRepo := repository.NewUserRepository(client)
        tokenRepo := repository.NewTokenRepository(client)
        authService := service.NewAuthService(userRepo, tokenRepo, cfg.JWTSecret, time.Hour)

        lis, err := net.Listen("tcp", cfg.AuthServiceAddr)
        if err != nil </span><span class="cov0" title="0">{
                log.Fatalf("Failed to listen: %v", err)
        }</span>

        <span class="cov0" title="0">logger, _ := zap.NewProduction()
        defer logger.Sync()

        interceptor := interceptor.NewAuthInterceptor(
                interceptor.WithLogger(logger),
                // interceptor.WithTokenValidator(customTokenValidator),
                interceptor.WithSupportedSchemes(interceptor.JWT, interceptor.APIKey),
                // interceptor.WithRefreshTokenFunc(customRefreshFunc),
        )

        grpcServer := grpc.NewServer(
                grpc.UnaryInterceptor(interceptor),
        )

        pb.RegisterAuthServiceServer(grpcServer, authService)

        log.Printf("Starting Auth service on %s", cfg.AuthServiceAddr)
        if err := grpcServer.Serve(lis); err != nil </span><span class="cov0" title="0">{
                log.Fatalf("Failed to serve: %v", err)
        }</span>
}
</pre>
		
		<pre class="file" id="file35" style="display: none">package service

import (
        "context"
        "time"

        "auth/ent"
        "auth/internal/repository"

        "github.com/golang-jwt/jwt/v4"
        "golang.org/x/crypto/bcrypt"
        "google.golang.org/grpc/codes"
        "google.golang.org/grpc/status"
        "google.golang.org/protobuf/types/known/emptypb"

        pb "auth/pb"
)

// IAuthService defines the interface for authentication and user management operations.
// It provides methods for user authentication, token management, and user CRUD operations.
type IAuthService interface {
        // Login authenticates a user and returns a login response with tokens.
        //
        // Parameters:
        //   - ctx: A context.Context for handling deadlines, cancellations, and request-scoped values.
        //   - req: A pointer to pb.LoginRequest containing user credentials and any additional login parameters.
        //
        // Returns:
        //   - *pb.LoginResponse: A response containing authentication tokens (e.g., access token, refresh token) and any additional user information.
        //   - error: An error if authentication fails, such as invalid credentials, account lockout, or internal server issues.
        //
        // The method should implement proper security measures, such as rate limiting and account lockout mechanisms.
        // It should also log authentication attempts for security auditing purposes.
        Login(ctx context.Context, req *pb.LoginRequest) (*pb.LoginResponse, error)

        // Logout terminates a user's active session, invalidating their current authentication tokens.
        //
        // Parameters:
        //   - ctx: A context.Context for handling deadlines, cancellations, and request-scoped values.
        //   - req: A pointer to pb.LogoutRequest containing the user's session information or tokens to be invalidated.
        //
        // Returns:
        //   - *emptypb.Empty: An empty response indicating successful logout.
        //   - error: An error if the logout process fails, such as invalid session, or internal server issues.
        //
        // This method should ensure all related session data is cleared and any distributed caches are updated.
        // It should also log the logout event for security auditing purposes.
        Logout(ctx context.Context, req *pb.LogoutRequest) (*emptypb.Empty, error)

        // RefreshToken extends a user's session by providing a new access token.
        //
        // Parameters:
        //   - ctx: A context.Context for handling deadlines, cancellations, and request-scoped values.
        //   - req: A pointer to pb.RefreshTokenRequest containing the current refresh token.
        //
        // Returns:
        //   - *pb.RefreshTokenResponse: A response containing a new access token and optionally a new refresh token.
        //   - error: An error if token refresh fails, such as expired refresh token, token reuse, or internal server issues.
        //
        // This method should implement proper security checks, including refresh token rotation if applicable.
        // It should also validate the refresh token's expiration and ensure it hasn't been revoked.
        RefreshToken(ctx context.Context, req *pb.RefreshTokenRequest) (*pb.RefreshTokenResponse, error)

        // ValidateToken checks the validity and integrity of a given token.
        //
        // Parameters:
        //   - ctx: A context.Context for handling deadlines, cancellations, and request-scoped values.
        //   - req: A pointer to pb.ValidateTokenRequest containing the token to be validated.
        //
        // Returns:
        //   - *pb.ValidateTokenResponse: A response indicating the token's validity and any associated metadata.
        //   - error: An error if the validation process fails due to internal server issues.
        //
        // This method should check the token's signature, expiration, and ensure it hasn't been revoked.
        // It may also return additional information about the token, such as associated user ID or permissions.
        ValidateToken(ctx context.Context, req *pb.ValidateTokenRequest) (*pb.ValidateTokenResponse, error)

        // RegisterUser creates a new user account in the system.
        //
        // Parameters:
        //   - ctx: A context.Context for handling deadlines, cancellations, and request-scoped values.
        //   - req: A pointer to pb.RegisterUserRequest containing the new user's information.
        //
        // Returns:
        //   - *pb.RegisterUserResponse: A response containing the newly created user's ID and any additional information.
        //   - error: An error if user registration fails, such as duplicate username/email, invalid data, or internal server issues.
        //
        // This method should implement proper data validation, secure password hashing, and any necessary unique constraint checks.
        // It may also trigger additional processes like sending a verification email or assigning default roles.
        RegisterUser(ctx context.Context, req *pb.RegisterUserRequest) (*pb.RegisterUserResponse, error)

        // UpdateUser modifies existing user information.
        //
        // Parameters:
        //   - ctx: A context.Context for handling deadlines, cancellations, and request-scoped values.
        //   - req: A pointer to pb.UpdateUserRequest containing the user ID and fields to be updated.
        //
        // Returns:
        //   - *pb.UpdateUserResponse: A response confirming the update and containing the updated user information.
        //   - error: An error if the update fails, such as user not found, invalid data, or internal server issues.
        //
        // This method should implement proper authorization checks to ensure the requester has permission to update the user.
        // It should also validate the updated data and handle any unique constraint violations.
        UpdateUser(ctx context.Context, req *pb.UpdateUserRequest) (*pb.UpdateUserResponse, error)

        // DeleteUser removes a user account from the system.
        //
        // Parameters:
        //   - ctx: A context.Context for handling deadlines, cancellations, and request-scoped values.
        //   - req: A pointer to pb.DeleteUserRequest containing the ID of the user to be deleted.
        //
        // Returns:
        //   - *emptypb.Empty: An empty response indicating successful deletion.
        //   - error: An error if the deletion fails, such as user not found, unauthorized deletion, or internal server issues.
        //
        // This method should implement proper authorization checks to ensure the requester has permission to delete the user.
        // It should also handle related data cleanups, such as revoking all active sessions and handling foreign key constraints.
        DeleteUser(ctx context.Context, req *pb.DeleteUserRequest) (*emptypb.Empty, error)

        // GetUser retrieves user information based on provided criteria.
        //
        // Parameters:
        //   - ctx: A context.Context for handling deadlines, cancellations, and request-scoped values.
        //   - req: A pointer to pb.GetUserRequest containing search criteria (e.g., user ID, username, email).
        //
        // Returns:
        //   - *pb.GetUserResponse: A response containing the requested user information.
        //   - error: An error if the retrieval fails, such as user not found, unauthorized access, or internal server issues.
        //
        // This method should implement proper authorization checks to ensure the requester has permission to access the user information.
        // It should also consider privacy settings and may return different levels of detail based on the requester's permissions.
        GetUser(ctx context.Context, req *pb.GetUserRequest) (*pb.GetUserResponse, error)
}

type AuthService struct {
        pb.UnimplementedAuthServiceServer
        userRepo    repository.IUserRepository
        tokenRepo   repository.ITokenRepository
        jwtSecret   string
        tokenExpiry time.Duration
}

func NewAuthService(userRepo repository.IUserRepository, tokenRepo repository.ITokenRepository, jwtSecret string, tokenExpiry time.Duration) *AuthService <span class="cov0" title="0">{
        return &amp;AuthService{
                userRepo:    userRepo,
                tokenRepo:   tokenRepo,
                jwtSecret:   jwtSecret,
                tokenExpiry: tokenExpiry,
        }
}</span>

func (s *AuthService) Login(ctx context.Context, req *pb.LoginRequest) (*pb.LoginResponse, error) <span class="cov0" title="0">{
        user, err := s.userRepo.GetByUsername(ctx, req.Username)
        if err != nil </span><span class="cov0" title="0">{
                return nil, status.Errorf(codes.Internal, "Failed to fetch user: %v", err)
        }</span>

        <span class="cov0" title="0">if user == nil || !s.userRepo.CheckPassword(ctx, user.Username, req.Password) </span><span class="cov0" title="0">{
                return nil, status.Errorf(codes.Unauthenticated, "Invalid username or password")
        }</span>

        <span class="cov0" title="0">accessToken, err := s.generateJWT(user)
        if err != nil </span><span class="cov0" title="0">{
                return nil, status.Errorf(codes.Internal, "Failed to generate access token: %v", err)
        }</span>

        <span class="cov0" title="0">refreshToken, err := s.generateRefreshToken(user)
        if err != nil </span><span class="cov0" title="0">{
                return nil, status.Errorf(codes.Internal, "Failed to generate refresh token: %v", err)
        }</span>

        // Store tokens in the database
        <span class="cov0" title="0">_, err = s.tokenRepo.Create(ctx, user.ID, accessToken, "access", time.Now().Add(s.tokenExpiry))
        if err != nil </span><span class="cov0" title="0">{
                return nil, status.Errorf(codes.Internal, "Failed to store access token: %v", err)
        }</span>

        <span class="cov0" title="0">_, err = s.tokenRepo.Create(ctx, user.ID, refreshToken, "refresh", time.Now().Add(24*time.Hour))
        if err != nil </span><span class="cov0" title="0">{
                return nil, status.Errorf(codes.Internal, "Failed to store refresh token: %v", err)
        }</span>

        <span class="cov0" title="0">return &amp;pb.LoginResponse{
                AccessToken:  accessToken,
                RefreshToken: refreshToken,
                ExpiresIn:    int64(s.tokenExpiry.Seconds()),
        }, nil</span>
}

func (s *AuthService) Logout(ctx context.Context, req *pb.LogoutRequest) (*emptypb.Empty, error) <span class="cov0" title="0">{
        if err := s.tokenRepo.RevokeToken(ctx, req.AccessToken); err != nil </span><span class="cov0" title="0">{
                return nil, status.Errorf(codes.Internal, "Failed to revoke token: %v", err)
        }</span>
        <span class="cov0" title="0">return &amp;emptypb.Empty{}, nil</span>
}

func (s *AuthService) RefreshToken(ctx context.Context, req *pb.RefreshTokenRequest) (*pb.RefreshTokenResponse, error) <span class="cov0" title="0">{
        token, err := s.tokenRepo.GetByToken(ctx, req.RefreshToken)
        if err != nil </span><span class="cov0" title="0">{
                return nil, status.Errorf(codes.Unauthenticated, "Invalid refresh token: %v", err)
        }</span>

        <span class="cov0" title="0">if token.Type != "refresh" || token.Revoked || token.ExpiresAt.Before(time.Now()) </span><span class="cov0" title="0">{
                return nil, status.Error(codes.Unauthenticated, "Invalid or expired refresh token")
        }</span>

        <span class="cov0" title="0">user, err := s.userRepo.GetByID(ctx, token.Edges.User.ID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, status.Errorf(codes.Internal, "Failed to fetch user: %v", err)
        }</span>

        <span class="cov0" title="0">accessToken, err := s.generateJWT(user)
        if err != nil </span><span class="cov0" title="0">{
                return nil, status.Errorf(codes.Internal, "Failed to generate access token: %v", err)
        }</span>

        <span class="cov0" title="0">refreshToken, err := s.generateRefreshToken(user)
        if err != nil </span><span class="cov0" title="0">{
                return nil, status.Errorf(codes.Internal, "Failed to generate refresh token: %v", err)
        }</span>

        // Revoke the old refresh token
        <span class="cov0" title="0">if err := s.tokenRepo.RevokeToken(ctx, req.RefreshToken); err != nil </span><span class="cov0" title="0">{
                return nil, status.Errorf(codes.Internal, "Failed to revoke old refresh token: %v", err)
        }</span>

        // Store new tokens in the database
        <span class="cov0" title="0">_, err = s.tokenRepo.Create(ctx, user.ID, accessToken, "access", time.Now().Add(s.tokenExpiry))
        if err != nil </span><span class="cov0" title="0">{
                return nil, status.Errorf(codes.Internal, "Failed to store access token: %v", err)
        }</span>

        <span class="cov0" title="0">_, err = s.tokenRepo.Create(ctx, user.ID, refreshToken, "refresh", time.Now().Add(24*time.Hour))
        if err != nil </span><span class="cov0" title="0">{
                return nil, status.Errorf(codes.Internal, "Failed to store refresh token: %v", err)
        }</span>

        <span class="cov0" title="0">return &amp;pb.RefreshTokenResponse{
                AccessToken:  accessToken,
                RefreshToken: refreshToken,
                ExpiresIn:    int64(s.tokenExpiry.Seconds()),
        }, nil</span>
}

func (s *AuthService) ValidateToken(ctx context.Context, req *pb.ValidateTokenRequest) (*pb.ValidateTokenResponse, error) <span class="cov0" title="0">{
        token, err := s.tokenRepo.GetByToken(ctx, req.Token)
        if err != nil </span><span class="cov0" title="0">{
                return nil, status.Errorf(codes.Unauthenticated, "Invalid token: %v", err)
        }</span>

        <span class="cov0" title="0">if token.Revoked || token.ExpiresAt.Before(time.Now()) </span><span class="cov0" title="0">{
                return nil, status.Error(codes.Unauthenticated, "Token is revoked or expired")
        }</span>

        <span class="cov0" title="0">user, err := s.userRepo.GetByID(ctx, token.Edges.User.ID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, status.Errorf(codes.Internal, "Failed to fetch user: %v", err)
        }</span>

        <span class="cov0" title="0">return &amp;pb.ValidateTokenResponse{
                User: &amp;pb.User{
                        Id:       user.ID,
                        Username: user.Username,
                        Email:    user.Email,
                },
        }, nil</span>
}

func (s *AuthService) RegisterUser(ctx context.Context, req *pb.RegisterUserRequest) (*pb.RegisterUserResponse, error) <span class="cov0" title="0">{
        existingUser, _ := s.userRepo.GetByUsername(ctx, req.Username)
        if existingUser != nil </span><span class="cov0" title="0">{
                return nil, status.Error(codes.AlreadyExists, "Username already exists")
        }</span>

        <span class="cov0" title="0">existingUser, _ = s.userRepo.GetByEmail(ctx, req.Email)
        if existingUser != nil </span><span class="cov0" title="0">{
                return nil, status.Error(codes.AlreadyExists, "Email already exists")
        }</span>

        <span class="cov0" title="0">hashedPassword, err := bcrypt.GenerateFromPassword([]byte(req.Password), bcrypt.DefaultCost)
        if err != nil </span><span class="cov0" title="0">{
                return nil, status.Errorf(codes.Internal, "Failed to hash password: %v", err)
        }</span>

        <span class="cov0" title="0">user := &amp;ent.User{
                Username: req.Username,
                Email:    req.Email,
                Password: string(hashedPassword),
        }

        if user, err = s.userRepo.Create(ctx, user); err != nil </span><span class="cov0" title="0">{
                return nil, status.Errorf(codes.Internal, "Failed to create user: %v", err)
        }</span>

        <span class="cov0" title="0">return &amp;pb.RegisterUserResponse{
                User: &amp;pb.User{
                        Id:       user.ID,
                        Username: user.Username,
                        Email:    user.Email,
                },
        }, nil</span>
}

func (s *AuthService) UpdateUser(ctx context.Context, req *pb.UpdateUserRequest) (*pb.UpdateUserResponse, error) <span class="cov0" title="0">{
        user, err := s.userRepo.GetByID(ctx, req.UserId)
        if err != nil </span><span class="cov0" title="0">{
                return nil, status.Errorf(codes.NotFound, "User not found: %v", err)
        }</span>

        <span class="cov0" title="0">if req.Username != nil </span><span class="cov0" title="0">{
                user.Username = *req.Username
        }</span>
        <span class="cov0" title="0">if req.Email != nil </span><span class="cov0" title="0">{
                user.Email = *req.Email
        }</span>
        <span class="cov0" title="0">if req.Password != nil </span><span class="cov0" title="0">{
                hashedPassword, err := bcrypt.GenerateFromPassword([]byte(*req.Password), bcrypt.DefaultCost)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, status.Errorf(codes.Internal, "Failed to hash password: %v", err)
                }</span>
                <span class="cov0" title="0">user.Password = string(hashedPassword)</span>
        }

        <span class="cov0" title="0">if user, err = s.userRepo.Update(ctx, user); err != nil </span><span class="cov0" title="0">{
                return nil, status.Errorf(codes.Internal, "Failed to update user: %v", err)
        }</span>

        // Revoke all existing tokens for the user
        <span class="cov0" title="0">if err := s.tokenRepo.RevokeAllUserTokens(ctx, user.ID); err != nil </span><span class="cov0" title="0">{
                return nil, status.Errorf(codes.Internal, "Failed to revoke user tokens: %v", err)
        }</span>

        <span class="cov0" title="0">return &amp;pb.UpdateUserResponse{
                User: &amp;pb.User{
                        Id:       user.ID,
                        Username: user.Username,
                        Email:    user.Email,
                },
        }, nil</span>
}

func (s *AuthService) DeleteUser(ctx context.Context, req *pb.DeleteUserRequest) (*emptypb.Empty, error) <span class="cov0" title="0">{
        // Revoke all tokens for the user
        if err := s.tokenRepo.RevokeAllUserTokens(ctx, req.UserId); err != nil </span><span class="cov0" title="0">{
                return nil, status.Errorf(codes.Internal, "Failed to revoke user tokens: %v", err)
        }</span>

        <span class="cov0" title="0">if err := s.userRepo.Delete(ctx, req.UserId); err != nil </span><span class="cov0" title="0">{
                return nil, status.Errorf(codes.Internal, "Failed to delete user: %v", err)
        }</span>

        <span class="cov0" title="0">return &amp;emptypb.Empty{}, nil</span>
}

func (s *AuthService) GetUser(ctx context.Context, req *pb.GetUserRequest) (*pb.GetUserResponse, error) <span class="cov0" title="0">{
        user, err := s.userRepo.GetByID(ctx, req.UserId)
        if err != nil </span><span class="cov0" title="0">{
                return nil, status.Errorf(codes.NotFound, "User not found: %v", err)
        }</span>

        <span class="cov0" title="0">return &amp;pb.GetUserResponse{
                User: &amp;pb.User{
                        Id:       user.ID,
                        Username: user.Username,
                        Email:    user.Email,
                },
        }, nil</span>
}

func (s *AuthService) generateJWT(user *ent.User) (string, error) <span class="cov0" title="0">{
        claims := jwt.MapClaims{
                "user_id":  user.ID,
                "username": user.Username,
                "exp":      time.Now().Add(s.tokenExpiry).Unix(),
        }

        token := jwt.NewWithClaims(jwt.SigningMethodHS256, claims)
        return token.SignedString([]byte(s.jwtSecret))
}</span>

func (s *AuthService) generateRefreshToken(user *ent.User) (string, error) <span class="cov0" title="0">{
        claims := jwt.MapClaims{
                "user_id": user.ID,
                "exp":     time.Now().Add(24 * time.Hour).Unix(), // Refresh token valid for 24 hours
        }

        token := jwt.NewWithClaims(jwt.SigningMethodHS256, claims)
        return token.SignedString([]byte(s.jwtSecret))
}</span>
</pre>
		
		<pre class="file" id="file36" style="display: none">package main

import (
        "log"
        "net"

        "auth/internal/authz/service"
        "auth/internal/db"
        "auth/internal/interceptor"
        "auth/internal/repository"
        pb "auth/pb"
        "pkg/config"

        "go.uber.org/zap"
        "google.golang.org/grpc"
)

func main() <span class="cov0" title="0">{
        cfg, err := config.Load()
        if err != nil </span><span class="cov0" title="0">{
                log.Fatalf("Failed to load config: %v", err)
        }</span>

        // Connect to the SQLite database
        <span class="cov0" title="0">client, err := db.ConnectEnt(db.Config{
                DatabaseURL: cfg.DatabaseURL,
        })
        if err != nil </span><span class="cov0" title="0">{
                log.Fatalf("Failed to connect to database: %v", err)
        }</span>
        <span class="cov0" title="0">defer client.Close()

        roleRepo := repository.NewRoleRepository(client)
        userRepo := repository.NewUserRepository(client)
        authzService := service.NewAuthzService(roleRepo, userRepo)

        lis, err := net.Listen("tcp", cfg.AuthzServiceAddr)
        if err != nil </span><span class="cov0" title="0">{
                log.Fatalf("Failed to listen: %v", err)
        }</span>
        <span class="cov0" title="0">logger, _ := zap.NewProduction()
        defer logger.Sync()

        interceptor := interceptor.NewAuthInterceptor(
                interceptor.WithLogger(logger),
                // interceptor.WithTokenValidator(customTokenValidator),
                interceptor.WithSupportedSchemes(interceptor.JWT, interceptor.APIKey),
                // interceptor.WithRefreshTokenFunc(customRefreshFunc),
        )

        grpcServer := grpc.NewServer(
                grpc.UnaryInterceptor(interceptor),
        )
        pb.RegisterAuthorizationServiceServer(grpcServer, authzService)

        log.Printf("Starting Authz service on %s", cfg.AuthzServiceAddr)
        if err := grpcServer.Serve(lis); err != nil </span><span class="cov0" title="0">{
                log.Fatalf("Failed to serve: %v", err)
        }</span>
}
</pre>
		
		<pre class="file" id="file37" style="display: none">package service

import (
        "context"
        "strconv"

        "auth/ent"
        "auth/internal/repository"

        "google.golang.org/grpc/codes"
        "google.golang.org/grpc/status"
        "google.golang.org/protobuf/types/known/emptypb"

        pb "auth/pb"
)

// IAuthzService defines the interface for authorization and role-based access control (RBAC) operations.
// It provides methods for managing permissions, roles, and user-role associations.
type IAuthzService interface {
        // CheckPermission verifies if a user has a specific permission.
        //
        // Parameters:
        //   - ctx: A context.Context for handling deadlines, cancellations, and request-scoped values.
        //   - req: A pointer to pb.CheckPermissionRequest containing the user ID and the permission to check.
        //
        // Returns:
        //   - *pb.CheckPermissionResponse: A response indicating whether the user has the specified permission.
        //   - error: An error if the check fails due to invalid input or internal server issues.
        //
        // This method should efficiently check the user's roles and the permissions associated with those roles.
        // It may implement caching mechanisms to improve performance for frequent permission checks.
        CheckPermission(ctx context.Context, req *pb.CheckPermissionRequest) (*pb.CheckPermissionResponse, error)

        // GetUserRoles retrieves all roles assigned to a specific user.
        //
        // Parameters:
        //   - ctx: A context.Context for handling deadlines, cancellations, and request-scoped values.
        //   - req: A pointer to pb.GetUserRolesRequest containing the user ID.
        //
        // Returns:
        //   - *pb.GetUserRolesResponse: A response containing a list of roles assigned to the user.
        //   - error: An error if the retrieval fails, such as user not found or internal server issues.
        //
        // This method should handle cases where a user might have multiple roles and ensure all are returned.
        GetUserRoles(ctx context.Context, req *pb.GetUserRolesRequest) (*pb.GetUserRolesResponse, error)

        // AssignRoleToUser assigns a specific role to a user.
        //
        // Parameters:
        //   - ctx: A context.Context for handling deadlines, cancellations, and request-scoped values.
        //   - req: A pointer to pb.AssignRoleToUserRequest containing the user ID and role ID to be assigned.
        //
        // Returns:
        //   - *emptypb.Empty: An empty response indicating successful assignment.
        //   - error: An error if the assignment fails, such as invalid user/role ID or internal server issues.
        //
        // This method should check if the role already exists for the user to avoid duplicate assignments.
        // It may also trigger any necessary cache invalidations or notifications.
        AssignRoleToUser(ctx context.Context, req *pb.AssignRoleToUserRequest) (*emptypb.Empty, error)

        // RemoveRoleFromUser removes a specific role from a user.
        //
        // Parameters:
        //   - ctx: A context.Context for handling deadlines, cancellations, and request-scoped values.
        //   - req: A pointer to pb.RemoveRoleFromUserRequest containing the user ID and role ID to be removed.
        //
        // Returns:
        //   - *emptypb.Empty: An empty response indicating successful removal.
        //   - error: An error if the removal fails, such as role not assigned to the user or internal server issues.
        //
        // This method should handle cases where the role might not be assigned to the user gracefully.
        // It may also trigger any necessary cache invalidations or notifications.
        RemoveRoleFromUser(ctx context.Context, req *pb.RemoveRoleFromUserRequest) (*emptypb.Empty, error)

        // CreateRole creates a new role in the system.
        //
        // Parameters:
        //   - ctx: A context.Context for handling deadlines, cancellations, and request-scoped values.
        //   - req: A pointer to pb.CreateRoleRequest containing the details of the new role.
        //
        // Returns:
        //   - *pb.CreateRoleResponse: A response containing the ID of the newly created role.
        //   - error: An error if creation fails, such as duplicate role name or internal server issues.
        //
        // This method should validate the role details and ensure uniqueness of the role name.
        // It may also set up any default permissions associated with the new role.
        CreateRole(ctx context.Context, req *pb.CreateRoleRequest) (*pb.CreateRoleResponse, error)

        // UpdateRole modifies an existing role in the system.
        //
        // Parameters:
        //   - ctx: A context.Context for handling deadlines, cancellations, and request-scoped values.
        //   - req: A pointer to pb.UpdateRoleRequest containing the role ID and updated details.
        //
        // Returns:
        //   - *pb.UpdateRoleResponse: A response confirming the update and containing the updated role information.
        //   - error: An error if the update fails, such as role not found or internal server issues.
        //
        // This method should validate the updated role details and handle any conflicts with existing roles.
        // It may also trigger updates to user permissions if the role's permissions have changed.
        UpdateRole(ctx context.Context, req *pb.UpdateRoleRequest) (*pb.UpdateRoleResponse, error)

        // DeleteRole removes a role from the system.
        //
        // Parameters:
        //   - ctx: A context.Context for handling deadlines, cancellations, and request-scoped values.
        //   - req: A pointer to pb.DeleteRoleRequest containing the ID of the role to be deleted.
        //
        // Returns:
        //   - *emptypb.Empty: An empty response indicating successful deletion.
        //   - error: An error if the deletion fails, such as role not found or internal server issues.
        //
        // This method should handle the removal of the role from all users it was assigned to.
        // It should also consider the implications of deleting a role and may implement safeguards against deleting critical roles.
        DeleteRole(ctx context.Context, req *pb.DeleteRoleRequest) (*emptypb.Empty, error)

        // GetRole retrieves detailed information about a specific role.
        //
        // Parameters:
        //   - ctx: A context.Context for handling deadlines, cancellations, and request-scoped values.
        //   - req: A pointer to pb.GetRoleRequest containing the ID of the role to retrieve.
        //
        // Returns:
        //   - *pb.GetRoleResponse: A response containing detailed information about the requested role.
        //   - error: An error if the retrieval fails, such as role not found or internal server issues.
        //
        // This method should return comprehensive information about the role, including its permissions and any metadata.
        GetRole(ctx context.Context, req *pb.GetRoleRequest) (*pb.GetRoleResponse, error)

        // ListRoles retrieves a list of roles based on specified criteria.
        //
        // Parameters:
        //   - ctx: A context.Context for handling deadlines, cancellations, and request-scoped values.
        //   - req: A pointer to pb.ListRolesRequest containing any filtering or pagination parameters.
        //
        // Returns:
        //   - *pb.ListRolesResponse: A response containing a list of roles matching the specified criteria.
        //   - error: An error if the listing fails due to invalid parameters or internal server issues.
        //
        // This method should support pagination and filtering to handle large numbers of roles efficiently.
        // It may also implement sorting options for the returned list.
        ListRoles(ctx context.Context, req *pb.ListRolesRequest) (*pb.ListRolesResponse, error)

        // AddPermissionToRole adds a specific permission to a role.
        //
        // Parameters:
        //   - ctx: A context.Context for handling deadlines, cancellations, and request-scoped values.
        //   - req: A pointer to pb.AddPermissionToRoleRequest containing the role ID and the permission to be added.
        //
        // Returns:
        //   - *emptypb.Empty: An empty response indicating successful addition of the permission.
        //   - error: An error if the addition fails, such as invalid role/permission or internal server issues.
        //
        // This method should check if the permission already exists for the role to avoid duplicates.
        // It may also trigger updates to user permissions for all users with this role.
        AddPermissionToRole(ctx context.Context, req *pb.AddPermissionToRoleRequest) (*emptypb.Empty, error)

        // RemovePermissionFromRole removes a specific permission from a role.
        //
        // Parameters:
        //   - ctx: A context.Context for handling deadlines, cancellations, and request-scoped values.
        //   - req: A pointer to pb.RemovePermissionFromRoleRequest containing the role ID and the permission to be removed.
        //
        // Returns:
        //   - *emptypb.Empty: An empty response indicating successful removal of the permission.
        //   - error: An error if the removal fails, such as permission not found in role or internal server issues.
        //
        // This method should handle cases where the permission might not be assigned to the role gracefully.
        // It may also trigger updates to user permissions for all users with this role.
        RemovePermissionFromRole(ctx context.Context, req *pb.RemovePermissionFromRoleRequest) (*emptypb.Empty, error)
}

type AuthzService struct {
        pb.UnimplementedAuthorizationServiceServer
        roleRepo repository.IRoleRepository
        userRepo repository.IUserRepository
}

func NewAuthzService(roleRepo repository.IRoleRepository, userRepo repository.IUserRepository) *AuthzService <span class="cov0" title="0">{
        return &amp;AuthzService{
                roleRepo: roleRepo,
                userRepo: userRepo,
        }
}</span>

func (s *AuthzService) CheckPermission(ctx context.Context, req *pb.CheckPermissionRequest) (*pb.CheckPermissionResponse, error) <span class="cov0" title="0">{
        roles, err := s.roleRepo.GetRolesByUserID(ctx, req.UserId)
        if err != nil </span><span class="cov0" title="0">{
                return nil, status.Errorf(codes.Internal, "Failed to fetch roles: %v", err)
        }</span>

        <span class="cov0" title="0">for _, role := range roles </span><span class="cov0" title="0">{
                if hasPermission(role, req.Permission.Resource, req.Permission.Action) </span><span class="cov0" title="0">{
                        return &amp;pb.CheckPermissionResponse{HasPermission: true}, nil
                }</span>
        }

        <span class="cov0" title="0">return &amp;pb.CheckPermissionResponse{HasPermission: false}, nil</span>
}

func (s *AuthzService) GetUserRoles(ctx context.Context, req *pb.GetUserRolesRequest) (*pb.GetUserRolesResponse, error) <span class="cov0" title="0">{
        roles, err := s.roleRepo.GetRolesByUserID(ctx, req.UserId)
        if err != nil </span><span class="cov0" title="0">{
                return nil, status.Errorf(codes.Internal, "Failed to fetch roles: %v", err)
        }</span>

        <span class="cov0" title="0">pbRoles := make([]*pb.Role, len(roles))
        for i, role := range roles </span><span class="cov0" title="0">{
                pbRoles[i] = &amp;pb.Role{
                        Id:          role.ID,
                        Name:        role.Name,
                        Permissions: role.Permissions,
                }
        }</span>

        <span class="cov0" title="0">return &amp;pb.GetUserRolesResponse{Roles: pbRoles}, nil</span>
}

func (s *AuthzService) AssignRoleToUser(ctx context.Context, req *pb.AssignRoleToUserRequest) (*emptypb.Empty, error) <span class="cov0" title="0">{
        if err := s.roleRepo.AssignRoleToUser(ctx, req.UserId, req.RoleId); err != nil </span><span class="cov0" title="0">{
                return nil, status.Errorf(codes.Internal, "Failed to assign role: %v", err)
        }</span>
        <span class="cov0" title="0">return &amp;emptypb.Empty{}, nil</span>
}

func (s *AuthzService) RemoveRoleFromUser(ctx context.Context, req *pb.RemoveRoleFromUserRequest) (*emptypb.Empty, error) <span class="cov0" title="0">{
        if err := s.roleRepo.RemoveRoleFromUser(ctx, req.UserId, req.RoleId); err != nil </span><span class="cov0" title="0">{
                return nil, status.Errorf(codes.Internal, "Failed to remove role: %v", err)
        }</span>
        <span class="cov0" title="0">return &amp;emptypb.Empty{}, nil</span>
}

func (s *AuthzService) CreateRole(ctx context.Context, req *pb.CreateRoleRequest) (*pb.CreateRoleResponse, error) <span class="cov0" title="0">{
        role := &amp;ent.Role{
                Name:        req.Name,
                Permissions: make([]string, len(req.Permissions)),
        }
        for i, perm := range req.Permissions </span><span class="cov0" title="0">{
                role.Permissions[i] = perm.Resource + ":" + perm.Action
        }</span>

        <span class="cov0" title="0">var err error

        if role, err = s.roleRepo.Create(ctx, role); err != nil </span><span class="cov0" title="0">{
                return nil, status.Errorf(codes.Internal, "Failed to create role: %v", err)
        }</span>

        <span class="cov0" title="0">return &amp;pb.CreateRoleResponse{
                Role: &amp;pb.Role{
                        Id:          role.ID,
                        Name:        role.Name,
                        Permissions: role.Permissions,
                },
        }, nil</span>
}

func (s *AuthzService) UpdateRole(ctx context.Context, req *pb.UpdateRoleRequest) (*pb.UpdateRoleResponse, error) <span class="cov0" title="0">{
        role, err := s.roleRepo.GetByID(ctx, req.RoleId)
        if err != nil </span><span class="cov0" title="0">{
                return nil, status.Errorf(codes.NotFound, "Role not found: %v", err)
        }</span>

        <span class="cov0" title="0">if req.Name != nil </span><span class="cov0" title="0">{
                role.Name = *req.Name
        }</span>
        <span class="cov0" title="0">if req.Permissions != nil </span><span class="cov0" title="0">{
                role.Permissions = make([]string, len(req.Permissions))
                for i, perm := range req.Permissions </span><span class="cov0" title="0">{
                        role.Permissions[i] = perm.Resource + ":" + perm.Action
                }</span>
        }

        <span class="cov0" title="0">if role, err = s.roleRepo.Update(ctx, role); err != nil </span><span class="cov0" title="0">{
                return nil, status.Errorf(codes.Internal, "Failed to update role: %v", err)
        }</span>

        <span class="cov0" title="0">return &amp;pb.UpdateRoleResponse{
                Role: &amp;pb.Role{
                        Id:          role.ID,
                        Name:        role.Name,
                        Permissions: role.Permissions,
                },
        }, nil</span>
}

func (s *AuthzService) DeleteRole(ctx context.Context, req *pb.DeleteRoleRequest) (*emptypb.Empty, error) <span class="cov0" title="0">{
        if err := s.roleRepo.Delete(ctx, req.RoleId); err != nil </span><span class="cov0" title="0">{
                return nil, status.Errorf(codes.Internal, "Failed to delete role: %v", err)

        }</span>

        <span class="cov0" title="0">return &amp;emptypb.Empty{}, nil</span>
}

func (s *AuthzService) GetRole(ctx context.Context, req *pb.GetRoleRequest) (*pb.GetRoleResponse, error) <span class="cov0" title="0">{
        role, err := s.roleRepo.GetByID(ctx, req.RoleId)
        if err != nil </span><span class="cov0" title="0">{
                return nil, status.Errorf(codes.NotFound, "Role not found: %v", err)
        }</span>

        <span class="cov0" title="0">return &amp;pb.GetRoleResponse{
                Role: &amp;pb.Role{
                        Id:          role.ID,
                        Name:        role.Name,
                        Permissions: role.Permissions,
                },
        }, nil</span>
}

func (s *AuthzService) ListRoles(ctx context.Context, req *pb.ListRolesRequest) (*pb.ListRolesResponse, error) <span class="cov0" title="0">{
        nextPageToken, err := strconv.Atoi(req.PageToken)
        if err != nil </span><span class="cov0" title="0">{
                return nil, status.Errorf(codes.InvalidArgument, "Invalid page token: %v", err)
        }</span>
        <span class="cov0" title="0">nextPageToken += int(req.PageSize)
        roles, err := s.roleRepo.List(ctx, int(req.PageSize), nextPageToken)
        if err != nil </span><span class="cov0" title="0">{
                return nil, status.Errorf(codes.Internal, "Failed to list roles: %v", err)
        }</span>

        <span class="cov0" title="0">pbRoles := make([]*pb.Role, len(roles))
        for i, role := range roles </span><span class="cov0" title="0">{
                pbRoles[i] = &amp;pb.Role{
                        Id:          role.ID,
                        Name:        role.Name,
                        Permissions: role.Permissions,
                }
        }</span>

        <span class="cov0" title="0">return &amp;pb.ListRolesResponse{
                Roles:         pbRoles,
                NextPageToken: strconv.Itoa(nextPageToken),
        }, nil</span>
}

func (s *AuthzService) AddPermissionToRole(ctx context.Context, req *pb.AddPermissionToRoleRequest) (*emptypb.Empty, error) <span class="cov0" title="0">{
        permission := req.Permission.Resource + ":" + req.Permission.Action
        if err := s.roleRepo.AddPermission(ctx, req.RoleId, permission); err != nil </span><span class="cov0" title="0">{
                return nil, status.Errorf(codes.Internal, "Failed to add permission: %v", err)
        }</span>
        <span class="cov0" title="0">return &amp;emptypb.Empty{}, nil</span>
}

func (s *AuthzService) RemovePermissionFromRole(ctx context.Context, req *pb.RemovePermissionFromRoleRequest) (*emptypb.Empty, error) <span class="cov0" title="0">{
        permission := req.Permission.Resource + ":" + req.Permission.Action
        if err := s.roleRepo.RemovePermission(ctx, req.RoleId, permission); err != nil </span><span class="cov0" title="0">{
                return nil, status.Errorf(codes.Internal, "Failed to remove permission: %v", err)
        }</span>
        <span class="cov0" title="0">return &amp;emptypb.Empty{}, nil</span>
}

func hasPermission(role *ent.Role, resource, action string) bool <span class="cov0" title="0">{
        permission := resource + ":" + action
        for _, perm := range role.Permissions </span><span class="cov0" title="0">{
                if perm == permission </span><span class="cov0" title="0">{
                        return true
                }</span>
        }
        <span class="cov0" title="0">return false</span>
}
</pre>
		
		<pre class="file" id="file38" style="display: none">// Package db provides functionality to connect to a SQLite database and Redis.
package db

import (
        "auth/ent"
        "context"
        "fmt"
        "log"
        "os"
        "path/filepath"

        "github.com/go-redis/redis/v8"
)

// Config holds the configuration for database connections.
type Config struct {
        // DatabaseURL is the connection string for the SQLite database.
        DatabaseURL string

        // RedisURL is the connection string for Redis.
        RedisURL string

        // MigrationsDir is the directory containing the ent migration files.
        MigrationsDir string
}

// ConnectEnt establishes a connection to the SQLite database and returns an ent client.
// It checks the ent folder and applies the latest migration.
//
// Parameters:
//   - cfg: Config struct containing the DatabaseURL and MigrationsDir.
//
// Returns:
//   - *ent.Client: A pointer to the ent client for database operations.
//   - error: An error if the connection or migration fails, nil otherwise.
func ConnectEnt(cfg Config) (*ent.Client, error) <span class="cov0" title="0">{
        // Open a connection to the SQLite database
        client, err := ent.Open("sqlite3", cfg.DatabaseURL)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed opening connection to sqlite: %v", err)
        }</span>

        // Find the latest migration file
        <span class="cov0" title="0">latestMigration, err := getLatestMigrationFile(cfg.MigrationsDir)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to get latest migration file: %v", err)
        }</span>

        <span class="cov0" title="0">log.Println("latestMigration", latestMigration)

        // // Apply the latest migration
        // err = client.Schema.Create(context.Background(), ent.Migrate(latestMigration))
        // if err != nil {
        //         return nil, fmt.Errorf("failed to apply latest migration: %v", err)
        // }

        return client, nil</span>
}

// getLatestMigrationFile finds the most recent migration file in the specified directory.
//
// Parameters:
//   - dir: The directory containing migration files.
//
// Returns:
//   - string: The content of the latest migration file.
//   - error: An error if reading the migration file fails, nil otherwise.
func getLatestMigrationFile(dir string) (string, error) <span class="cov0" title="0">{
        files, err := os.ReadDir(dir)
        if err != nil </span><span class="cov0" title="0">{
                return "", fmt.Errorf("failed to read migration directory: %v", err)
        }</span>

        <span class="cov0" title="0">var latestFile os.DirEntry
        for _, file := range files </span><span class="cov0" title="0">{
                if !file.IsDir() &amp;&amp; filepath.Ext(file.Name()) == ".sql" </span><span class="cov0" title="0">{
                        if latestFile == nil || file.Name() &gt; latestFile.Name() </span><span class="cov0" title="0">{
                                latestFile = file
                        }</span>
                }
        }

        <span class="cov0" title="0">if latestFile == nil </span><span class="cov0" title="0">{
                return "", fmt.Errorf("no migration files found in directory")
        }</span>

        <span class="cov0" title="0">content, err := os.ReadFile(filepath.Join(dir, latestFile.Name()))
        if err != nil </span><span class="cov0" title="0">{
                return "", fmt.Errorf("failed to read migration file: %v", err)
        }</span>

        <span class="cov0" title="0">return string(content), nil</span>
}

// ConnectRedis establishes a connection to Redis.
//
// Parameters:
//   - redisURL: The URL for connecting to Redis.
//
// Returns:
//   - *redis.Client: A pointer to the Redis client for Redis operations.
//   - error: An error if the connection fails, nil otherwise.
func ConnectRedis(redisURL string) (*redis.Client, error) <span class="cov0" title="0">{
        // Parse the Redis URL
        opts, err := redis.ParseURL(redisURL)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to parse Redis URL: %v", err)
        }</span>

        // Create a new Redis client
        <span class="cov0" title="0">client := redis.NewClient(opts)

        // Ping Redis to check the connection
        if err := client.Ping(context.Background()).Err(); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to connect to Redis: %v", err)
        }</span>

        <span class="cov0" title="0">return client, nil</span>
}
</pre>
		
		<pre class="file" id="file39" style="display: none">// Package interceptor provides middleware for gRPC server authentication.
//
// This package offers a flexible and feature-rich authentication interceptor
// for gRPC servers. It supports multiple authentication schemes, including
// JWT and API keys, and provides options for customization, logging, rate
// limiting, and token refresh.
package interceptor

import (
        "context"
        "time"

        "github.com/dgrijalva/jwt-go"
        "github.com/patrickmn/go-cache"
        "go.uber.org/zap"
        "golang.org/x/time/rate"
        "google.golang.org/grpc"
)

// contextKey is a custom type for context keys to avoid collisions.
type contextKey string

// userClaimsKey is the context key for user claims.
const userClaimsKey contextKey = "userClaims"

// AuthScheme represents different authentication schemes.
type AuthScheme string

const (
        // JWT authentication scheme.
        JWT AuthScheme = "Bearer"
        // APIKey authentication scheme.
        APIKey AuthScheme = "APIKey"
)

// AuthInterceptorConfig holds the configuration for the AuthInterceptor.
type AuthInterceptorConfig struct {
        TokenValidator     func(string) (jwt.MapClaims, error)
        APIKeyValidator    func(string) (bool, error)
        MetadataKey        string
        Logger             *zap.Logger
        RateLimiter        *rate.Limiter
        RefreshTokenFunc   func(string) (string, error)
        SupportedSchemes   []AuthScheme
        TokenRefreshWindow time.Duration
        APIKeyCache        *cache.Cache
}

// AuthInterceptorOption is a function that modifies AuthInterceptorConfig.
type AuthInterceptorOption func(*AuthInterceptorConfig)

// WithTokenValidator sets a custom token validator function.
func WithTokenValidator(validator func(string) (jwt.MapClaims, error)) AuthInterceptorOption <span class="cov1" title="1">{
        return func(config *AuthInterceptorConfig) </span><span class="cov1" title="1">{
                config.TokenValidator = validator
        }</span>
}

// WithAPIKeyValidator sets a custom API key validator function.
func WithAPIKeyValidator(validator func(string) (bool, error)) AuthInterceptorOption <span class="cov1" title="1">{
        return func(config *AuthInterceptorConfig) </span><span class="cov1" title="1">{
                config.APIKeyValidator = validator
        }</span>
}

// WithMetadataKey sets a custom metadata key for the authorization header.
func WithMetadataKey(key string) AuthInterceptorOption <span class="cov1" title="1">{
        return func(config *AuthInterceptorConfig) </span><span class="cov1" title="1">{
                config.MetadataKey = key
        }</span>
}

// WithLogger sets a custom logger.
func WithLogger(logger *zap.Logger) AuthInterceptorOption <span class="cov1" title="1">{
        return func(config *AuthInterceptorConfig) </span><span class="cov1" title="1">{
                config.Logger = logger
        }</span>
}

// WithRateLimiter sets a custom rate limiter.
func WithRateLimiter(limiter *rate.Limiter) AuthInterceptorOption <span class="cov1" title="1">{
        return func(config *AuthInterceptorConfig) </span><span class="cov1" title="1">{
                config.RateLimiter = limiter
        }</span>
}

// WithRefreshTokenFunc sets a custom refresh token function.
func WithRefreshTokenFunc(refreshFunc func(string) (string, error)) AuthInterceptorOption <span class="cov1" title="1">{
        return func(config *AuthInterceptorConfig) </span><span class="cov1" title="1">{
                config.RefreshTokenFunc = refreshFunc
        }</span>
}

// WithSupportedSchemes sets the supported authentication schemes.
func WithSupportedSchemes(schemes ...AuthScheme) AuthInterceptorOption <span class="cov1" title="1">{
        return func(config *AuthInterceptorConfig) </span><span class="cov1" title="1">{
                config.SupportedSchemes = schemes
        }</span>
}

// WithTokenRefreshWindow sets the time window before token expiration to trigger a refresh.
func WithTokenRefreshWindow(window time.Duration) AuthInterceptorOption <span class="cov1" title="1">{
        return func(config *AuthInterceptorConfig) </span><span class="cov1" title="1">{
                config.TokenRefreshWindow = window
        }</span>
}

// WithAPIKeyCache sets the cache for API key validation.
func WithAPIKeyCache(cache *cache.Cache) AuthInterceptorOption <span class="cov1" title="1">{
        return func(config *AuthInterceptorConfig) </span><span class="cov1" title="1">{
                config.APIKeyCache = cache
        }</span>
}

// NewAuthInterceptor creates a new AuthInterceptor with the given options.
//
// Usage:
//
//        interceptor := NewAuthInterceptor(
//                WithLogger(logger),
//                WithTokenValidator(customTokenValidator),
//                WithSupportedSchemes(JWT, APIKey),
//        )
//        server := grpc.NewServer(grpc.UnaryInterceptor(interceptor))
func NewAuthInterceptor(opts ...AuthInterceptorOption) grpc.UnaryServerInterceptor <span class="cov3" title="2">{
        config := &amp;AuthInterceptorConfig{
                TokenValidator:     defaultTokenValidator,
                APIKeyValidator:    defaultAPIKeyValidator,
                MetadataKey:        "authorization",
                Logger:             zap.NewNop(),
                RateLimiter:        rate.NewLimiter(rate.Every(time.Second), 10),
                RefreshTokenFunc:   defaultRefreshTokenFunc,
                SupportedSchemes:   []AuthScheme{JWT},
                TokenRefreshWindow: 5 * time.Minute,
                APIKeyCache:        cache.New(5*time.Minute, 10*time.Minute),
        }

        for _, opt := range opts </span><span class="cov10" title="9">{
                opt(config)
        }</span>

        <span class="cov3" title="2">return func(ctx context.Context, req interface{}, info *grpc.UnaryServerInfo, handler grpc.UnaryHandler) (interface{}, error) </span><span class="cov0" title="0">{
                return authInterceptor(ctx, req, info, handler, config)
        }</span>
}

// authInterceptor is the core function that performs the authentication.
func authInterceptor(ctx context.Context, req interface{}, info *grpc.UnaryServerInfo, handler grpc.UnaryHandler, config *AuthInterceptorConfig) (interface{}, error) <span class="cov6" title="4">{
        if err := validateConfig(config); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov6" title="4">if err := applyRateLimiting(ctx, config); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov6" title="4">authToken, authScheme, err := extractAuthInfo(ctx, config)
        if err != nil </span><span class="cov1" title="1">{
                return nil, err
        }</span>

        <span class="cov5" title="3">claims, err := authenticateRequest(ctx, authToken, authScheme, config)
        if err != nil </span><span class="cov1" title="1">{
                return nil, err
        }</span>

        <span class="cov3" title="2">newCtx := context.WithValue(ctx, userClaimsKey, claims)
        logAuthenticatedRequest(newCtx, info, config, claims)

        return handler(newCtx, req)</span>
}
</pre>
		
		<pre class="file" id="file40" style="display: none">package interceptor

import (
        "context"
        "fmt"
        "strings"
        "time"

        "github.com/dgrijalva/jwt-go"
        "github.com/patrickmn/go-cache"
        "go.uber.org/zap"
        "google.golang.org/grpc"
        "google.golang.org/grpc/codes"
        "google.golang.org/grpc/metadata"
        "google.golang.org/grpc/peer"
        "google.golang.org/grpc/status"
)

// validateConfig validates the configuration.
func validateConfig(config *AuthInterceptorConfig) error <span class="cov8" title="7">{
        if config == nil </span><span class="cov1" title="1">{
                return status.Errorf(codes.Internal, "AuthInterceptorConfig is nil")
        }</span>
        <span class="cov8" title="6">if config.Logger == nil </span><span class="cov1" title="1">{
                config.Logger = zap.NewNop()
        }</span>
        <span class="cov8" title="6">return nil</span>
}

// applyRateLimiting applies rate limiting to the request.
func applyRateLimiting(ctx context.Context, config *AuthInterceptorConfig) error <span class="cov7" title="5">{
        if config.RateLimiter != nil </span><span class="cov0" title="0">{
                if err := config.RateLimiter.Wait(ctx); err != nil </span><span class="cov0" title="0">{
                        config.Logger.Warn("Rate limit exceeded", zap.Error(err))
                        return status.Errorf(codes.ResourceExhausted, "Rate limit exceeded")
                }</span>
        }
        <span class="cov7" title="5">return nil</span>
}

// extractAuthInfo extracts the authentication information from the context.
func extractAuthInfo(ctx context.Context, config *AuthInterceptorConfig) (string, AuthScheme, error) <span class="cov9" title="9">{
        md, ok := metadata.FromIncomingContext(ctx)
        if !ok </span><span class="cov3" title="2">{
                config.Logger.Warn("Missing metadata")
                return "", "", status.Errorf(codes.Unauthenticated, "Missing metadata")
        }</span>

        <span class="cov8" title="7">authHeader, ok := md[config.MetadataKey]
        if !ok || len(authHeader) == 0 </span><span class="cov1" title="1">{
                config.Logger.Warn("Missing authorization header")
                return "", "", status.Errorf(codes.Unauthenticated, "Missing authorization header")
        }</span>

        <span class="cov8" title="6">authParts := strings.SplitN(authHeader[0], " ", 2)
        if len(authParts) != 2 </span><span class="cov1" title="1">{
                config.Logger.Warn("Invalid authorization header format")
                return "", "", status.Errorf(codes.Unauthenticated, "Invalid authorization header format")
        }</span>

        <span class="cov7" title="5">return authParts[1], AuthScheme(authParts[0]), nil</span>
}

// authenticateRequest authenticates a request using the given token and scheme.
func authenticateRequest(ctx context.Context, authToken string, authScheme AuthScheme, config *AuthInterceptorConfig) (jwt.MapClaims, error) <span class="cov8" title="6">{
        switch authScheme </span>{
        case JWT:<span class="cov3" title="2">
                return authenticateJWT(ctx, authToken, config)</span>
        case APIKey:<span class="cov3" title="2">
                return authenticateAPIKey(authToken, config)</span>
        default:<span class="cov3" title="2">
                config.Logger.Warn("Unsupported authentication scheme", zap.String("scheme", string(authScheme)))
                return nil, status.Errorf(codes.Unauthenticated, "Unsupported authentication scheme")</span>
        }
}

// authenticateJWT authenticates a request using a JWT token.
func authenticateJWT(ctx context.Context, authToken string, config *AuthInterceptorConfig) (jwt.MapClaims, error) <span class="cov9" title="8">{
        if config.TokenValidator == nil </span><span class="cov0" title="0">{
                return nil, status.Errorf(codes.Internal, "TokenValidator is not configured")
        }</span>

        <span class="cov9" title="8">claims, err := config.TokenValidator(authToken)
        if err != nil </span><span class="cov1" title="1">{
                config.Logger.Warn("Invalid JWT token", zap.Error(err))
                return nil, status.Errorf(codes.Unauthenticated, "Invalid token: %v", err)
        }</span>

        <span class="cov8" title="7">newToken, err := refreshTokenIfNeeded(ctx, authToken, claims, config)
        if err != nil </span><span class="cov1" title="1">{
                config.Logger.Warn("Failed to refresh token", zap.Error(err))
        }</span> else<span class="cov8" title="6"> if newToken != "" </span><span class="cov3" title="2">{
                md, ok := metadata.FromIncomingContext(ctx)
                if !ok </span><span class="cov0" title="0">{
                        md = metadata.New(nil)
                }</span>
                <span class="cov3" title="2">md = md.Copy()
                md.Set("new-token", newToken)
                ctx = metadata.NewIncomingContext(ctx, md)
                fmt.Println("ctx: ", ctx)</span>
        }

        <span class="cov8" title="7">return claims, nil</span>
}

// refreshTokenIfNeeded checks if the token needs to be refreshed and triggers a refresh if needed.
func refreshTokenIfNeeded(ctx context.Context, authToken string, claims jwt.MapClaims, config *AuthInterceptorConfig) (string, error) <span class="cov8" title="7">{
        if exp, ok := claims["exp"].(float64); ok </span><span class="cov7" title="5">{
                expTime := time.Unix(int64(exp), 0)
                if time.Until(expTime) &lt; config.TokenRefreshWindow &amp;&amp; config.RefreshTokenFunc != nil </span><span class="cov5" title="3">{
                        newToken, err := config.RefreshTokenFunc(authToken)
                        if err != nil </span><span class="cov1" title="1">{
                                return "", err
                        }</span>
                        <span class="cov3" title="2">return newToken, nil</span>
                }
        }
        <span class="cov6" title="4">return "", nil</span>
}

// authenticateAPIKey authenticates a request using an API key.
func authenticateAPIKey(apiKey string, config *AuthInterceptorConfig) (jwt.MapClaims, error) <span class="cov8" title="6">{
        if config.APIKeyValidator == nil </span><span class="cov0" title="0">{
                return nil, status.Errorf(codes.Internal, "APIKeyValidator is not configured")
        }</span>

        <span class="cov8" title="6">valid, err := validateAPIKey(apiKey, config)
        if err != nil || !valid </span><span class="cov1" title="1">{
                config.Logger.Warn("Invalid API key", zap.Error(err))
                return nil, status.Errorf(codes.Unauthenticated, "Invalid API key")
        }</span>

        <span class="cov7" title="5">return jwt.MapClaims{"api_key": apiKey}, nil</span>
}

// logAuthenticatedRequest logs information about an authenticated request.
//
// This function is called after a request has been successfully authenticated.
// It logs the method, peer address, and user claims.
func logAuthenticatedRequest(ctx context.Context, info *grpc.UnaryServerInfo, config *AuthInterceptorConfig, claims jwt.MapClaims) <span class="cov5" title="3">{
        if config == nil || config.Logger == nil </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov5" title="3">peerInfo := "unknown"
        if p, ok := peer.FromContext(ctx); ok &amp;&amp; p != nil </span><span class="cov0" title="0">{
                peerInfo = p.Addr.String()
        }</span>

        <span class="cov5" title="3">methodInfo := "unknown"
        if info != nil </span><span class="cov5" title="3">{
                methodInfo = info.FullMethod
        }</span>

        <span class="cov5" title="3">config.Logger.Info("Authenticated request",
                zap.String("method", methodInfo),
                zap.String("peer", peerInfo),
                zap.Any("claims", claims),
        )</span>
}

// defaultTokenValidator is the default implementation of JWT token validation.
//
// This function parses and validates a JWT token using a secret key.
// In a production environment, you should replace this with your own
// implementation that uses your secret key and includes any additional
// validation logic specific to your application.
func defaultTokenValidator(tokenString string) (jwt.MapClaims, error) <span class="cov5" title="3">{
        const secretKey = "my-secret"
        token, err := jwt.Parse(tokenString, func(token *jwt.Token) (interface{}, error) </span><span class="cov3" title="2">{
                if _, ok := token.Method.(*jwt.SigningMethodHMAC); !ok </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("unexpected signing method: %v", token.Header["alg"])
                }</span>
                <span class="cov3" title="2">return []byte(secretKey), nil</span>
        })

        <span class="cov5" title="3">if err != nil </span><span class="cov3" title="2">{
                return nil, err
        }</span>

        <span class="cov1" title="1">if claims, ok := token.Claims.(jwt.MapClaims); ok &amp;&amp; token.Valid </span><span class="cov1" title="1">{
                return claims, nil
        }</span>

        <span class="cov0" title="0">return nil, fmt.Errorf("invalid token")</span>
}

// defaultAPIKeyValidator is the default implementation of API key validation.
func defaultAPIKeyValidator(apiKey string) (bool, error) <span class="cov3" title="2">{
        validKeys := map[string]bool{
                "valid-api-key-1": true,
                "key123":          true,
                "myApiKey":        true,
        }

        isValid, exists := validKeys[apiKey]
        if !exists </span><span class="cov1" title="1">{
                return false, nil
        }</span>
        <span class="cov1" title="1">return isValid, nil</span>
}

// validateAPIKey checks the validity of an API key, using caching for performance.
func validateAPIKey(apiKey string, config *AuthInterceptorConfig) (bool, error) <span class="cov10" title="10">{
        // Check cache first
        if cachedValue, found := config.APIKeyCache.Get(apiKey); found </span><span class="cov3" title="2">{
                valid, ok := cachedValue.(bool)
                if !ok </span><span class="cov0" title="0">{
                        return false, fmt.Errorf("cached value is not a bool")
                }</span>
                <span class="cov3" title="2">return valid, nil</span>
        }

        // If not in cache, validate using the provided validator
        <span class="cov9" title="8">valid, err := config.APIKeyValidator(apiKey)
        if err != nil </span><span class="cov0" title="0">{
                return false, err
        }</span>

        // Cache the result
        <span class="cov9" title="8">config.APIKeyCache.Set(apiKey, valid, cache.DefaultExpiration)
        return valid, nil</span>
}

// defaultRefreshTokenFunc is the default implementation of token refresh.
func defaultRefreshTokenFunc(oldToken string) (string, error) <span class="cov1" title="1">{
        return "new-refreshed-token-" + oldToken[len(oldToken)-5:], nil
}</span>

// ExtractBearerToken is a helper function to extract the Bearer token from an authorization header.
//
// Parameters:
//   - authHeader: The full authorization header.
//
// Returns:
//   - The Bearer token and an error if extraction fails.
//
// Usage:
//
//        token, err := ExtractBearerToken(authHeader)
//        if err != nil {
//            return status.Errorf(codes.Unauthenticated, "Invalid authorization header")
//        }
func ExtractBearerToken(authHeader string) (string, error) <span class="cov6" title="4">{
        parts := strings.SplitN(authHeader, " ", 2)
        if len(parts) != 2 || strings.ToLower(parts[0]) != "bearer" </span><span class="cov3" title="2">{
                return "", fmt.Errorf("invalid authorization header format")
        }</span>
        <span class="cov3" title="2">return parts[1], nil</span>
}

// AuthMetadataKey is a helper function to get the metadata key for authentication.
//
// Parameters:
//   - ctx: The context from which to extract the metadata.
//
// Returns:
//   - The authentication metadata key and a boolean indicating if it was found.
//
// Usage:
//
//        key, ok := AuthMetadataKey(ctx)
//        if !ok {
//            return status.Errorf(codes.Unauthenticated, "Missing authentication metadata")
//        }
func AuthMetadataKey(ctx context.Context) (string, bool) <span class="cov6" title="4">{
        md, ok := metadata.FromIncomingContext(ctx)
        if !ok </span><span class="cov1" title="1">{
                return "", false
        }</span>

        <span class="cov5" title="3">values := md.Get("authorization")
        if len(values) == 0 || values[0] == "" </span><span class="cov3" title="2">{
                return "", false
        }</span>

        <span class="cov1" title="1">return values[0], true</span>
}

// GetUserClaims retrieves the user claims from the context.
//
// This function can be used in your gRPC handlers to access the
// authenticated user's claims.
//
// Usage:
//
//        func (s *server) SomeMethod(ctx context.Context, req *pb.Request) (*pb.Response, error) {
//                claims, ok := interceptor.GetUserClaims(ctx)
//                if !ok {
//                        return nil, status.Errorf(codes.Unauthenticated, "No user claims found")
//                }
//                // Use claims...
//        }
func GetUserClaims(ctx context.Context) (jwt.MapClaims, bool) <span class="cov5" title="3">{
        claims, ok := ctx.Value(userClaimsKey).(jwt.MapClaims)
        return claims, ok
}</span>
</pre>
		
		<pre class="file" id="file41" style="display: none">package repository

import (
        "auth/ent"
        "context"
        "time"

        "auth/ent/role"
        "auth/ent/user"
)

// IRoleRepository defines the interface for role-related operations.
type IRoleRepository interface {
        // Create creates a new role in the database.
        //
        // Parameters:
        //   - ctx: Context for the database operation.
        //   - role: Pointer to the ent.Role object containing the role information to be created.
        //
        // Returns:
        //   - *ent.Role: Pointer to the created role object.
        //   - error: An error object that indicates success or failure of the operation.
        //
        // Example:
        //   newRole := &amp;ent.Role{
        //     Name: "admin",
        //     Description: "Administrator role with full access",
        //   }
        //   createdRole, err := repo.Create(ctx, newRole)
        //   if err != nil {
        //     log.Printf("Failed to create role: %v", err)
        //     return
        //   }
        //   fmt.Printf("Created role with ID: %s\n", createdRole.ID)
        Create(ctx context.Context, role *ent.Role) (*ent.Role, error)

        // GetByID retrieves a role by its ID.
        //
        // Parameters:
        //   - ctx: Context for the database operation.
        //   - id: String representing the unique identifier of the role.
        //
        // Returns:
        //   - *ent.Role: Pointer to the retrieved role object.
        //   - error: An error object that indicates success or failure of the operation.
        //
        // Example:
        //   roleID := "123e4567-e89b-12d3-a456-426614174000"
        //   role, err := repo.GetByID(ctx, roleID)
        //   if err != nil {
        //     log.Printf("Failed to get role: %v", err)
        //     return
        //   }
        //   fmt.Printf("Retrieved role: %s\n", role.Name)
        GetByID(ctx context.Context, id string) (*ent.Role, error)

        // GetByName retrieves a role by its name.
        //
        // Parameters:
        //   - ctx: Context for the database operation.
        //   - name: String representing the name of the role.
        //
        // Returns:
        //   - *ent.Role: Pointer to the retrieved role object.
        //   - error: An error object that indicates success or failure of the operation.
        //
        // Example:
        //   roleName := "admin"
        //   role, err := repo.GetByName(ctx, roleName)
        //   if err != nil {
        //     log.Printf("Failed to get role: %v", err)
        //     return
        //   }
        //   fmt.Printf("Retrieved role ID: %s\n", role.ID)
        GetByName(ctx context.Context, name string) (*ent.Role, error)

        // Update updates an existing role's information.
        //
        // Parameters:
        //   - ctx: Context for the database operation.
        //   - role: Pointer to the ent.Role object containing the updated role information.
        //
        // Returns:
        //   - *ent.Role: Pointer to the updated role object.
        //   - error: An error object that indicates success or failure of the operation.
        //
        // Example:
        //   role.Description = "Updated administrator role description"
        //   updatedRole, err := repo.Update(ctx, role)
        //   if err != nil {
        //     log.Printf("Failed to update role: %v", err)
        //     return
        //   }
        //   fmt.Printf("Updated role description: %s\n", updatedRole.Description)
        Update(ctx context.Context, role *ent.Role) (*ent.Role, error)

        // Delete removes a role from the database by its ID.
        //
        // Parameters:
        //   - ctx: Context for the database operation.
        //   - id: String representing the unique identifier of the role to be deleted.
        //
        // Returns:
        //   - error: An error object that indicates success or failure of the operation.
        //
        // Example:
        //   roleID := "123e4567-e89b-12d3-a456-426614174000"
        //   err := repo.Delete(ctx, roleID)
        //   if err != nil {
        //     log.Printf("Failed to delete role: %v", err)
        //     return
        //   }
        //   fmt.Println("Role successfully deleted")
        Delete(ctx context.Context, id string) error

        // List retrieves a paginated list of roles.
        //
        // Parameters:
        //   - ctx: Context for the database operation.
        //   - offset: Integer representing the number of records to skip.
        //   - limit: Integer representing the maximum number of records to return.
        //
        // Returns:
        //   - []*ent.Role: Slice of pointers to role objects.
        //   - error: An error object that indicates success or failure of the operation.
        //
        // Example:
        //   roles, err := repo.List(ctx, 0, 10)
        //   if err != nil {
        //     log.Printf("Failed to list roles: %v", err)
        //     return
        //   }
        //   for _, role := range roles {
        //     fmt.Printf("Role: %s, Description: %s\n", role.Name, role.Description)
        //   }
        List(ctx context.Context, offset, limit int) ([]*ent.Role, error)

        // Count returns the total number of roles in the database.
        //
        // Parameters:
        //   - ctx: Context for the database operation.
        //
        // Returns:
        //   - int: The total number of roles.
        //   - error: An error object that indicates success or failure of the operation.
        //
        // Example:
        //   count, err := repo.Count(ctx)
        //   if err != nil {
        //     log.Printf("Failed to count roles: %v", err)
        //     return
        //   }
        //   fmt.Printf("Total number of roles: %d\n", count)
        Count(ctx context.Context) (int, error)

        // AddPermission adds a permission to a role.
        //
        // Parameters:
        //   - ctx: Context for the database operation.
        //   - roleID: String representing the unique identifier of the role.
        //   - permission: String representing the permission to be added.
        //
        // Returns:
        //   - error: An error object that indicates success or failure of the operation.
        //
        // Example:
        //   roleID := "123e4567-e89b-12d3-a456-426614174000"
        //   permission := "create:user"
        //   err := repo.AddPermission(ctx, roleID, permission)
        //   if err != nil {
        //     log.Printf("Failed to add permission to role: %v", err)
        //     return
        //   }
        //   fmt.Println("Permission successfully added to role")
        AddPermission(ctx context.Context, roleID, permission string) error

        // RemovePermission removes a permission from a role.
        //
        // Parameters:
        //   - ctx: Context for the database operation.
        //   - roleID: String representing the unique identifier of the role.
        //   - permission: String representing the permission to be removed.
        //
        // Returns:
        //   - error: An error object that indicates success or failure of the operation.
        //
        // Example:
        //   roleID := "123e4567-e89b-12d3-a456-426614174000"
        //   permission := "delete:user"
        //   err := repo.RemovePermission(ctx, roleID, permission)
        //   if err != nil {
        //     log.Printf("Failed to remove permission from role: %v", err)
        //     return
        //   }
        //   fmt.Println("Permission successfully removed from role")
        RemovePermission(ctx context.Context, roleID, permission string) error

        // GetPermissions retrieves all permissions assigned to a role.
        //
        // Parameters:
        //   - ctx: Context for the database operation.
        //   - roleID: String representing the unique identifier of the role.
        //
        // Returns:
        //   - []string: Slice of strings representing the permissions assigned to the role.
        //   - error: An error object that indicates success or failure of the operation.
        //
        // Example:
        //   roleID := "123e4567-e89b-12d3-a456-426614174000"
        //   permissions, err := repo.GetPermissions(ctx, roleID)
        //   if err != nil {
        //     log.Printf("Failed to get role permissions: %v", err)
        //     return
        //   }
        //   for _, perm := range permissions {
        //     fmt.Printf("Permission: %s\n", perm)
        //   }
        GetPermissions(ctx context.Context, roleID string) ([]string, error)

        // AddUserToRole assigns a user to a role.
        //
        // Parameters:
        //   - ctx: Context for the database operation.
        //   - roleID: String representing the unique identifier of the role.
        //   - userID: String representing the unique identifier of the user to be added to the role.
        //
        // Returns:
        //   - error: An error object that indicates success or failure of the operation.
        //
        // Example:
        //   roleID := "123e4567-e89b-12d3-a456-426614174000"
        //   userID := "456e7890-e89b-12d3-a456-426614174000"
        //   err := repo.AddUserToRole(ctx, roleID, userID)
        //   if err != nil {
        //     log.Printf("Failed to add user to role: %v", err)
        //     return
        //   }
        //   fmt.Println("User successfully added to role")
        AddUserToRole(ctx context.Context, roleID, userID string) error

        // RemoveUserFromRole removes a user from a role.
        //
        // Parameters:
        //   - ctx: Context for the database operation.
        //   - roleID: String representing the unique identifier of the role.
        //   - userID: String representing the unique identifier of the user to be removed from the role.
        //
        // Returns:
        //   - error: An error object that indicates success or failure of the operation.
        //
        // Example:
        //   roleID := "123e4567-e89b-12d3-a456-426614174000"
        //   userID := "456e7890-e89b-12d3-a456-426614174000"
        //   err := repo.RemoveUserFromRole(ctx, roleID, userID)
        //   if err != nil {
        //     log.Printf("Failed to remove user from role: %v", err)
        //     return
        //   }
        //   fmt.Println("User successfully removed from role")
        RemoveUserFromRole(ctx context.Context, roleID, userID string) error

        // GetUsersInRole retrieves all users assigned to a specific role.
        //
        // Parameters:
        //   - ctx: Context for the database operation.
        //   - roleID: String representing the unique identifier of the role.
        //
        // Returns:
        //   - []*ent.User: Slice of pointers to user objects assigned to the role.
        //   - error: An error object that indicates success or failure of the operation.
        //
        // Example:
        //   roleID := "123e4567-e89b-12d3-a456-426614174000"
        //   users, err := repo.GetUsersInRole(ctx, roleID)
        //   if err != nil {
        //     log.Printf("Failed to get users in role: %v", err)
        //     return
        //   }
        //   for _, user := range users {
        //     fmt.Printf("User in role: %s, Email: %s\n", user.Username, user.Email)
        //   }
        GetUsersInRole(ctx context.Context, roleID string) ([]*ent.User, error)

        // Search performs a search for roles based on a query string.
        //
        // Parameters:
        //   - ctx: Context for the database operation.
        //   - query: String representing the search query.
        //
        // Returns:
        //   - []*ent.Role: Slice of pointers to role objects matching the search query.
        //   - error: An error object that indicates success or failure of the operation.
        //
        // Example:
        //   query := "admin"
        //   roles, err := repo.Search(ctx, query)
        //   if err != nil {
        //     log.Printf("Failed to search roles: %v", err)
        //     return
        //   }
        //   for _, role := range roles {
        //     fmt.Printf("Matching role: %s, Description: %s\n", role.Name, role.Description)
        //   }
        Search(ctx context.Context, query string) ([]*ent.Role, error)

        // GetRolesByUserID retrieves all roles assigned to a specific user.
        //
        // Parameters:
        //   - ctx: Context for the database operation.
        //   - userID: String representing the unique identifier of the user.
        //
        // Returns:
        //   - []*ent.Role: Slice of pointers to role objects assigned to the user.
        //   - error: An error object that indicates success or failure of the operation.
        //
        // Example:
        //   userID := "456e7890-e89b-12d3-a456-426614174000"
        //   roles, err := repo.GetRolesByUserID(ctx, userID)
        //   if err != nil {
        //     log.Printf("Failed to get roles for user: %v", err)
        //     return
        //   }
        //   for _, role := range roles {
        //     fmt.Printf("User's role: %s, Description: %s\n", role.Name, role.Description)
        //   }
        GetRolesByUserID(ctx context.Context, userID string) ([]*ent.Role, error)

        // AssignRoleToUser assigns a role to a user.
        //
        // Parameters:
        //   - ctx: Context for the database operation.
        //   - userID: String representing the unique identifier of the user.
        //   - roleID: String representing the unique identifier of the role to be assigned.
        //
        // Returns:
        //   - error: An error object that indicates success or failure of the operation.
        //
        // Example:
        //   userID := "456e7890-e89b-12d3-a456-426614174000"
        //   roleID := "123e4567-e89b-12d3-a456-426614174000"
        //   err := repo.AssignRoleToUser(ctx, userID, roleID)
        //   if err != nil {
        //     log.Printf("Failed to assign role to user: %v", err)
        //     return
        //   }
        //   fmt.Println("Role successfully assigned to user")
        AssignRoleToUser(ctx context.Context, userID, roleID string) error

        // RemoveRoleFromUser removes a role from a user.
        //
        // Parameters:
        //   - ctx: Context for the database operation.
        //   - userID: String representing the unique identifier of the user.
        //   - roleID: String representing the unique identifier of the role to be removed.
        //
        // Returns:
        //   - error: An error object that indicates success or failure of the operation.
        //
        // Example:
        //   userID := "456e7890-e89b-12d3-a456-426614174000"
        //   roleID := "123e4567-e89b-12d3-a456-426614174000"
        //   err := repo.RemoveRoleFromUser(ctx, userID, roleID)
        //   if err != nil {
        //     log.Printf("Failed to remove role from user: %v", err)
        //     return
        //   }
        //   fmt.Println("Role successfully removed from user")
        RemoveRoleFromUser(ctx context.Context, userID, roleID string) error
}

type RoleRepository struct {
        client *ent.Client
}

func NewRoleRepository(client *ent.Client) *RoleRepository <span class="cov1" title="1">{
        return &amp;RoleRepository{client: client}
}</span>

func (r *RoleRepository) Create(ctx context.Context, role *ent.Role) (*ent.Role, error) <span class="cov10" title="27">{
        return r.client.Role.
                Create().
                SetName(role.Name).
                SetPermissions(role.Permissions).
                Save(ctx)
}</span>

func (r *RoleRepository) GetByID(ctx context.Context, id string) (*ent.Role, error) <span class="cov5" title="5">{
        return r.client.Role.Query().Where(role.ID(id)).Only(ctx)
}</span>

func (r *RoleRepository) GetByName(ctx context.Context, name string) (*ent.Role, error) <span class="cov1" title="1">{
        return r.client.Role.Query().Where(role.Name(name)).Only(ctx)
}</span>

func (r *RoleRepository) Update(ctx context.Context, role *ent.Role) (*ent.Role, error) <span class="cov1" title="1">{
        return r.client.Role.UpdateOne(role).
                SetName(role.Name).
                SetPermissions(role.Permissions).
                SetUpdatedAt(time.Now()).
                Save(ctx)
}</span>

func (r *RoleRepository) Delete(ctx context.Context, id string) error <span class="cov1" title="1">{
        return r.client.Role.DeleteOneID(id).Exec(ctx)
}</span>

func (r *RoleRepository) List(ctx context.Context, offset, limit int) ([]*ent.Role, error) <span class="cov1" title="1">{
        return r.client.Role.Query().
                Offset(offset).
                Limit(limit).
                All(ctx)
}</span>

func (r *RoleRepository) Count(ctx context.Context) (int, error) <span class="cov2" title="2">{
        return r.client.Role.Query().Count(ctx)
}</span>

func (r *RoleRepository) AddPermission(ctx context.Context, roleID, permission string) error <span class="cov1" title="1">{
        return r.client.Role.UpdateOneID(roleID).
                AppendPermissions([]string{permission}).
                Exec(ctx)
}</span>

func (r *RoleRepository) RemovePermission(ctx context.Context, roleID, permission string) error <span class="cov1" title="1">{
        roleData, err := r.GetByID(ctx, roleID)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov1" title="1">updatedPermissions := make([]string, 0)
        for _, p := range roleData.Permissions </span><span class="cov2" title="2">{
                if p != permission </span><span class="cov1" title="1">{
                        updatedPermissions = append(updatedPermissions, p)
                }</span>
        }

        <span class="cov1" title="1">var newName = updatedPermissions

        println(newName)

        return r.client.Role.UpdateOneID(roleID).
                SetPermissions(updatedPermissions).
                Exec(ctx)</span>
}

func (r *RoleRepository) GetPermissions(ctx context.Context, roleID string) ([]string, error) <span class="cov0" title="0">{
        roleData, err := r.GetByID(ctx, roleID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return roleData.Permissions, nil</span>
}

func (r *RoleRepository) AddUserToRole(ctx context.Context, roleID, userID string) error <span class="cov1" title="1">{
        return r.client.Role.UpdateOneID(roleID).
                AddUserIDs(userID).
                Exec(ctx)
}</span>

func (r *RoleRepository) RemoveUserFromRole(ctx context.Context, roleID, userID string) error <span class="cov0" title="0">{
        return r.client.Role.UpdateOneID(roleID).
                RemoveUserIDs(userID).
                Exec(ctx)
}</span>

func (r *RoleRepository) GetUsersInRole(ctx context.Context, roleID string) ([]*ent.User, error) <span class="cov1" title="1">{
        roleData, err := r.client.Role.Query().
                Where(role.ID(roleID)).
                WithUsers().
                Only(ctx)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov1" title="1">return roleData.Edges.Users, nil</span>
}

func (r *RoleRepository) Search(ctx context.Context, query string) ([]*ent.Role, error) <span class="cov1" title="1">{
        return r.client.Role.Query().
                Where(role.NameHasPrefix(query)).
                All(ctx)
}</span>

func (r *RoleRepository) GetRolesByUserID(ctx context.Context, userID string) ([]*ent.Role, error) <span class="cov4" title="3">{
        return r.client.Role.Query().
                Where(role.HasUsersWith(user.ID(userID))).
                All(ctx)
}</span>

func (r *RoleRepository) AssignRoleToUser(ctx context.Context, userID, roleID string) error <span class="cov4" title="3">{
        return r.client.User.UpdateOneID(userID).
                AddRoleIDs(roleID).
                Exec(ctx)
}</span>

func (r *RoleRepository) RemoveRoleFromUser(ctx context.Context, userID, roleID string) error <span class="cov1" title="1">{
        return r.client.User.UpdateOneID(userID).
                RemoveRoleIDs(roleID).
                Exec(ctx)
}</span>

// func (r *RoleRepository) GetRolesByPermission(ctx context.Context, permission string) ([]*ent.Role, error) {
//     return r.client.Role.Query().
//         Where(role.HasPermissionsWith(permission)).
//         All(ctx)
// }
</pre>
		
		<pre class="file" id="file42" style="display: none">// Package repository provides interfaces and implementations for token management.
package repository

import (
        "auth/ent"
        "auth/ent/token"
        "auth/ent/user"
        "context"
        "fmt"
        "time"
)

// ITokenRepository defines the interface for token-related operations.
type ITokenRepository interface {
        // Create creates a new token.
        //
        // Parameters:
        //   - ctx: The context for the database operation.
        //   - userID: The ID of the user associated with the token.
        //   - tokenString: The unique string representation of the token.
        //   - tokenType: The type of the token (e.g., "access", "refresh").
        //   - expiresAt: The expiration time of the token.
        //
        // Returns:
        //   - *ent.Token: The created token entity.
        //   - error: An error if the creation fails, nil otherwise.
        Create(ctx context.Context, userID, tokenString string, tokenType string, expiresAt time.Time) (*ent.Token, error)

        // GetByToken retrieves a token by its string representation.
        //
        // Parameters:
        //   - ctx: The context for the database operation.
        //   - tokenString: The unique string representation of the token to retrieve.
        //
        // Returns:
        //   - *ent.Token: The retrieved token entity.
        //   - error: An error if the token is not found or if the retrieval fails, nil otherwise.
        GetByToken(ctx context.Context, tokenString string) (*ent.Token, error)

        // RevokeToken marks a token as revoked.
        //
        // Parameters:
        //   - ctx: The context for the database operation.
        //   - tokenString: The unique string representation of the token to revoke.
        //
        // Returns:
        //   - error: An error if the revocation fails, nil otherwise.
        RevokeToken(ctx context.Context, tokenString string) error

        // DeleteExpiredTokens removes all expired or revoked tokens from the database.
        //
        // Parameters:
        //   - ctx: The context for the database operation.
        //
        // Returns:
        //   - error: An error if the deletion fails, nil otherwise.
        DeleteExpiredTokens(ctx context.Context) error

        // GetValidTokensByUserID retrieves all valid tokens for a specific user.
        //
        // Parameters:
        //   - ctx: The context for the database operation.
        //   - userID: The ID of the user whose tokens to retrieve.
        //
        // Returns:
        //   - []*ent.Token: A slice of valid token entities.
        //   - error: An error if the retrieval fails, nil otherwise.
        GetValidTokensByUserID(ctx context.Context, userID string) ([]*ent.Token, error)

        // RevokeAllUserTokens revokes all tokens belonging to a specific user.
        //
        // Parameters:
        //   - ctx: The context for the database operation.
        //   - userID: The ID of the user whose tokens to revoke.
        //
        // Returns:
        //   - error: An error if the revocation fails, nil otherwise.
        RevokeAllUserTokens(ctx context.Context, userID string) error
}

// TokenRepository implements the ITokenRepository interface.
type TokenRepository struct {
        client *ent.Client
}

// NewTokenRepository creates a new instance of TokenRepository.
//
// Parameters:
//   - client: The Ent ORM client for database operations.
//
// Returns:
//   - *TokenRepository: A new instance of TokenRepository.
func NewTokenRepository(client *ent.Client) *TokenRepository <span class="cov1" title="1">{
        return &amp;TokenRepository{client: client}
}</span>

// Create implements ITokenRepository.Create.
func (r *TokenRepository) Create(ctx context.Context, userID, tokenString string, tokenType string, expiresAt time.Time) (*ent.Token, error) <span class="cov10" title="9">{
        return r.client.Token.
                Create().
                SetToken(tokenString).
                SetType(token.Type(tokenType)).
                SetExpiresAt(expiresAt).
                SetUserID(userID).
                Save(ctx)
}</span>

// GetByToken implements ITokenRepository.GetByToken.
func (r *TokenRepository) GetByToken(ctx context.Context, tokenString string) (*ent.Token, error) <span class="cov5" title="3">{
        return r.client.Token.
                Query().
                Where(token.Token(tokenString)).
                Only(ctx)
}</span>

// RevokeToken implements ITokenRepository.RevokeToken.
func (r *TokenRepository) RevokeToken(ctx context.Context, tokenString string) error <span class="cov5" title="3">{
        affected, err := r.client.Token.
                Update().
                Where(
                        token.Token(tokenString),
                        token.RevokedEQ(false),
                ).
                SetRevoked(true).
                Save(ctx)

        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to revoke token: %w", err)
        }</span>

        <span class="cov5" title="3">if affected == 0 </span><span class="cov3" title="2">{
                return fmt.Errorf("token not found or already revoked")
        }</span>

        <span class="cov1" title="1">return nil</span>
}

// DeleteExpiredTokens implements ITokenRepository.DeleteExpiredTokens.
func (r *TokenRepository) DeleteExpiredTokens(ctx context.Context) error <span class="cov1" title="1">{
        _, err := r.client.Token.
                Delete().
                Where(
                        token.Or(
                                token.ExpiresAtLT(time.Now()),
                                token.Revoked(true),
                        ),
                ).
                Exec(ctx)
        return err
}</span>

// GetValidTokensByUserID implements ITokenRepository.GetValidTokensByUserID.
func (r *TokenRepository) GetValidTokensByUserID(ctx context.Context, userID string) ([]*ent.Token, error) <span class="cov3" title="2">{
        return r.client.Token.
                Query().
                Where(
                        token.HasUserWith(user.ID(userID)),
                        token.ExpiresAtGT(time.Now()),
                        token.Revoked(false),
                ).
                All(ctx)
}</span>

// RevokeAllUserTokens implements ITokenRepository.RevokeAllUserTokens.
func (r *TokenRepository) RevokeAllUserTokens(ctx context.Context, userID string) error <span class="cov1" title="1">{
        _, err := r.client.Token.
                Update().
                Where(
                        token.HasUserWith(user.ID(userID)),
                        token.Revoked(false),
                ).
                SetRevoked(true).
                Save(ctx)
        return err
}</span>
</pre>
		
		<pre class="file" id="file43" style="display: none">// Package repository provides interfaces and implementations for user management.
package repository

import (
        "auth/ent"
        "auth/ent/role"
        "auth/ent/user"
        "auth/pkg"
        "context"
        "pkg/common/errors"
        "time"
)

// IUserRepository defines the interface for user-related operations.
type IUserRepository interface {
        // Create creates a new user in the database.
        //
        // Parameters:
        //   - ctx: Context for the database operation.
        //   - u: Pointer to the ent.User object containing the user information to be created.
        //
        // Returns:
        //   - *ent.User: Pointer to the created user object.
        //   - error: An error object that indicates success or failure of the operation.
        //
        // Example:
        //   newUser := &amp;ent.User{
        //     Username: "johndoe",
        //     Email:    "john@example.com",
        //     Password: "securepassword",
        //   }
        //   createdUser, err := repo.Create(ctx, newUser)
        //   if err != nil {
        //     log.Printf("Failed to create user: %v", err)
        //     return
        //   }
        //   fmt.Printf("Created user with ID: %s\n", createdUser.ID)
        Create(ctx context.Context, u *ent.User) (*ent.User, error)

        // GetByID retrieves a user by their ID.
        //
        // Parameters:
        //   - ctx: Context for the database operation.
        //   - id: String representing the unique identifier of the user.
        //
        // Returns:
        //   - *ent.User: Pointer to the retrieved user object.
        //   - error: An error object that indicates success or failure of the operation.
        //
        // Example:
        //   userID := "123e4567-e89b-12d3-a456-426614174000"
        //   user, err := repo.GetByID(ctx, userID)
        //   if err != nil {
        //     log.Printf("Failed to get user: %v", err)
        //     return
        //   }
        //   fmt.Printf("Retrieved user: %s\n", user.Username)
        GetByID(ctx context.Context, id string) (*ent.User, error)

        // GetByUsername retrieves a user by their username.
        //
        // Parameters:
        //   - ctx: Context for the database operation.
        //   - username: String representing the username of the user.
        //
        // Returns:
        //   - *ent.User: Pointer to the retrieved user object.
        //   - error: An error object that indicates success or failure of the operation.
        //
        // Example:
        //   username := "johndoe"
        //   user, err := repo.GetByUsername(ctx, username)
        //   if err != nil {
        //     log.Printf("Failed to get user: %v", err)
        //     return
        //   }
        //   fmt.Printf("Retrieved user: %s\n", user.Email)
        GetByUsername(ctx context.Context, username string) (*ent.User, error)

        // GetByEmail retrieves a user by their email address.
        //
        // Parameters:
        //   - ctx: Context for the database operation.
        //   - email: String representing the email address of the user.
        //
        // Returns:
        //   - *ent.User: Pointer to the retrieved user object.
        //   - error: An error object that indicates success or failure of the operation.
        //
        // Example:
        //   email := "john@example.com"
        //   user, err := repo.GetByEmail(ctx, email)
        //   if err != nil {
        //     log.Printf("Failed to get user: %v", err)
        //     return
        //   }
        //   fmt.Printf("Retrieved user: %s\n", user.Username)
        GetByEmail(ctx context.Context, email string) (*ent.User, error)

        // Update updates an existing user's information.
        //
        // Parameters:
        //   - ctx: Context for the database operation.
        //   - u: Pointer to the ent.User object containing the updated user information.
        //
        // Returns:
        //   - *ent.User: Pointer to the updated user object.
        //   - error: An error object that indicates success or failure of the operation.
        //
        // Example:
        //   user.Email = "newemail@example.com"
        //   updatedUser, err := repo.Update(ctx, user)
        //   if err != nil {
        //     log.Printf("Failed to update user: %v", err)
        //     return
        //   }
        //   fmt.Printf("Updated user email: %s\n", updatedUser.Email)
        Update(ctx context.Context, u *ent.User) (*ent.User, error)

        // Delete removes a user from the database by their ID.
        //
        // Parameters:
        //   - ctx: Context for the database operation.
        //   - id: String representing the unique identifier of the user to be deleted.
        //
        // Returns:
        //   - error: An error object that indicates success or failure of the operation.
        //
        // Example:
        //   userID := "123e4567-e89b-12d3-a456-426614174000"
        //   err := repo.Delete(ctx, userID)
        //   if err != nil {
        //     log.Printf("Failed to delete user: %v", err)
        //     return
        //   }
        //   fmt.Println("User successfully deleted")
        Delete(ctx context.Context, id string) error

        // List retrieves a paginated list of users.
        //
        // Parameters:
        //   - ctx: Context for the database operation.
        //   - offset: Integer representing the number of records to skip.
        //   - limit: Integer representing the maximum number of records to return.
        //
        // Returns:
        //   - []*ent.User: Slice of pointers to user objects.
        //   - error: An error object that indicates success or failure of the operation.
        //
        // Example:
        //   users, err := repo.List(ctx, 0, 10)
        //   if err != nil {
        //     log.Printf("Failed to list users: %v", err)
        //     return
        //   }
        //   for _, user := range users {
        //     fmt.Printf("User: %s, Email: %s\n", user.Username, user.Email)
        //   }
        List(ctx context.Context, offset, limit int) ([]*ent.User, error)

        // Count returns the total number of users in the database.
        //
        // Parameters:
        //   - ctx: Context for the database operation.
        //
        // Returns:
        //   - int: The total number of users.
        //   - error: An error object that indicates success or failure of the operation.
        //
        // Example:
        //   count, err := repo.Count(ctx)
        //   if err != nil {
        //     log.Printf("Failed to count users: %v", err)
        //     return
        //   }
        //   fmt.Printf("Total number of users: %d\n", count)
        Count(ctx context.Context) (int, error)

        // AddRole assigns a role to a user.
        //
        // Parameters:
        //   - ctx: Context for the database operation.
        //   - userID: String representing the unique identifier of the user.
        //   - roleID: String representing the unique identifier of the role to be assigned.
        //
        // Returns:
        //   - error: An error object that indicates success or failure of the operation.
        //
        // Example:
        //   userID := "123e4567-e89b-12d3-a456-426614174000"
        //   roleID := "789e0123-e89b-12d3-a456-426614174000"
        //   err := repo.AddRole(ctx, userID, roleID)
        //   if err != nil {
        //     log.Printf("Failed to add role to user: %v", err)
        //     return
        //   }
        //   fmt.Println("Role successfully added to user")
        AddRole(ctx context.Context, userID, roleID string) error

        // RemoveRole removes a role from a user.
        //
        // Parameters:
        //   - ctx: Context for the database operation.
        //   - userID: String representing the unique identifier of the user.
        //   - roleID: String representing the unique identifier of the role to be removed.
        //
        // Returns:
        //   - error: An error object that indicates success or failure of the operation.
        //
        // Example:
        //   userID := "123e4567-e89b-12d3-a456-426614174000"
        //   roleID := "789e0123-e89b-12d3-a456-426614174000"
        //   err := repo.RemoveRole(ctx, userID, roleID)
        //   if err != nil {
        //     log.Printf("Failed to remove role from user: %v", err)
        //     return
        //   }
        //   fmt.Println("Role successfully removed from user")
        RemoveRole(ctx context.Context, userID, roleID string) error

        // GetRoles retrieves all roles assigned to a user.
        //
        // Parameters:
        //   - ctx: Context for the database operation.
        //   - userID: String representing the unique identifier of the user.
        //
        // Returns:
        //   - []*ent.Role: Slice of pointers to role objects assigned to the user.
        //   - error: An error object that indicates success or failure of the operation.
        //
        // Example:
        //   userID := "123e4567-e89b-12d3-a456-426614174000"
        //   roles, err := repo.GetRoles(ctx, userID)
        //   if err != nil {
        //     log.Printf("Failed to get user roles: %v", err)
        //     return
        //   }
        //   for _, role := range roles {
        //     fmt.Printf("Role: %s\n", role.Name)
        //   }
        GetRoles(ctx context.Context, userID string) ([]*ent.Role, error)

        // Search performs a search for users based on a query string.
        //
        // Parameters:
        //   - ctx: Context for the database operation.
        //   - query: String representing the search query.
        //
        // Returns:
        //   - []*ent.User: Slice of pointers to user objects matching the search query.
        //   - error: An error object that indicates success or failure of the operation.
        //
        // Example:
        //   query := "john"
        //   users, err := repo.Search(ctx, query)
        //   if err != nil {
        //     log.Printf("Failed to search users: %v", err)
        //     return
        //   }
        //   for _, user := range users {
        //     fmt.Printf("Matching user: %s, Email: %s\n", user.Username, user.Email)
        //   }
        Search(ctx context.Context, query string) ([]*ent.User, error)

        // ChangePassword updates a user's password.
        //
        // Parameters:
        //   - ctx: Context for the database operation.
        //   - userID: String representing the unique identifier of the user.
        //   - newPassword: String representing the new password.
        //
        // Returns:
        //   - error: An error object that indicates success or failure of the operation.
        //
        // Example:
        //   userID := "123e4567-e89b-12d3-a456-426614174000"
        //   newPassword := "newSecurePassword123"
        //   err := repo.ChangePassword(ctx, userID, newPassword)
        //   if err != nil {
        //     log.Printf("Failed to change password: %v", err)
        //     return
        //   }
        //   fmt.Println("Password successfully changed")
        ChangePassword(ctx context.Context, userID, newPassword string) error

        // GetUsersByRole retrieves all users with a specific role.
        //
        // Parameters:
        //   - ctx: Context for the database operation.
        //   - roleID: String representing the unique identifier of the role.
        //
        // Returns:
        //   - []*ent.User: Slice of pointers to user objects with the specified role.
        //   - error: An error object that indicates success or failure of the operation.
        //
        // Example:
        //   roleID := "789e0123-e89b-12d3-a456-426614174000"
        //   users, err := repo.GetUsersByRole(ctx, roleID)
        //   if err != nil {
        //     log.Printf("Failed to get users by role: %v", err)
        //     return
        //   }
        //   for _, user := range users {
        //     fmt.Printf("User with role: %s, Email: %s\n", user.Username, user.Email)
        //   }
        GetUsersByRole(ctx context.Context, roleID string) ([]*ent.User, error)

        // CheckPassword verifies if the provided password is correct for a user.
        //
        // Parameters:
        //   - ctx: Context for the database operation.
        //   - username: String representing the username of the user.
        //   - password: String representing the password to check.
        //
        // Returns:
        //   - bool: True if the password is correct, false otherwise.
        //
        // Example:
        //   password := "userPassword123"
        //   isCorrect := repo.CheckPassword(ctx, password)
        //   if isCorrect {
        //     fmt.Println("Password is correct")
        //   } else {
        //     fmt.Println("Password is incorrect")
        //   }
        CheckPassword(ctx context.Context, username, password string) bool

        // SetPassword sets a new password for a user.
        //
        // Parameters:
        //   - ctx: Context for the database operation.
        //   - username: String representing the username of the user.
        //   - password: String representing the new password to set.
        //
        // Returns:
        //   - error: An error object that indicates success or failure of the operation.
        //
        // Example:
        //   newPassword := "newSecurePassword123"
        //   err := repo.SetPassword(ctx, newPassword)
        //   if err != nil {
        //     log.Printf("Failed to set new password: %v", err)
        //     return
        //   }
        //   fmt.Println("New password successfully set")
        SetPassword(ctx context.Context, username, password string) error
}

type UserRepository struct {
        client *ent.Client
}

// NewUserRepository creates a new instance of UserRepository with the given ent.Client.
func NewUserRepository(client *ent.Client) *UserRepository <span class="cov1" title="1">{
        return &amp;UserRepository{client: client}
}</span>

// Create creates a new user in the database.
func (r *UserRepository) Create(ctx context.Context, u *ent.User) (*ent.User, error) <span class="cov10" title="24">{
        return r.client.User.
                Create().
                SetUsername(u.Username).
                SetEmail(u.Email).
                SetPassword(u.Password).
                Save(ctx)
}</span>

// GetByID retrieves a user by their ID.
func (r *UserRepository) GetByID(ctx context.Context, id string) (*ent.User, error) <span class="cov5" title="5">{
        return r.client.User.Query().Where(user.ID(id)).Only(ctx)
}</span>

// GetByUsername retrieves a user by their username.
func (r *UserRepository) GetByUsername(ctx context.Context, username string) (*ent.User, error) <span class="cov2" title="2">{
        return r.client.User.Query().Where(user.Username(username)).Only(ctx)
}</span>

// GetByEmail retrieves a user by their email address.
func (r *UserRepository) GetByEmail(ctx context.Context, email string) (*ent.User, error) <span class="cov2" title="2">{
        return r.client.User.Query().Where(user.Email(email)).Only(ctx)
}</span>

// Update updates an existing user's information.
func (r *UserRepository) Update(ctx context.Context, u *ent.User) (*ent.User, error) <span class="cov1" title="1">{
        return r.client.User.UpdateOne(u).
                SetUsername(u.Username).
                SetEmail(u.Email).
                SetPassword(u.Password).
                SetUpdatedAt(time.Now()).
                Save(ctx)
}</span>

// Delete removes a user from the database by their ID.
func (r *UserRepository) Delete(ctx context.Context, id string) error <span class="cov2" title="2">{
        return r.client.User.DeleteOneID(id).Exec(ctx)
}</span>

func (r *UserRepository) List(ctx context.Context, offset, limit int) ([]*ent.User, error) <span class="cov2" title="2">{
        return r.client.User.Query().
                Offset(offset).
                Limit(limit).
                All(ctx)
}</span>

// Count returns the total number of users in the database.
func (r *UserRepository) Count(ctx context.Context) (int, error) <span class="cov2" title="2">{
        return r.client.User.Query().Count(ctx)
}</span>

// AddRole assigns a role to a user.
func (r *UserRepository) AddRole(ctx context.Context, userID, roleID string) error <span class="cov5" title="5">{
        return r.client.User.UpdateOneID(userID).
                AddRoleIDs(roleID).
                Exec(ctx)
}</span>

// RemoveRole removes a role from a user.
func (r *UserRepository) RemoveRole(ctx context.Context, userID, roleID string) error <span class="cov1" title="1">{
        return r.client.User.UpdateOneID(userID).
                RemoveRoleIDs(roleID).
                Exec(ctx)
}</span>

// GetRoles retrieves all roles assigned to a user.
func (r *UserRepository) GetRoles(ctx context.Context, userID string) ([]*ent.Role, error) <span class="cov4" title="3">{
        u, err := r.client.User.Query().
                Where(user.ID(userID)).
                WithRoles().
                Only(ctx)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov4" title="3">return u.Edges.Roles, nil</span>
}

// Search performs a search for users based on a query string.
func (r *UserRepository) Search(ctx context.Context, query string) ([]*ent.User, error) <span class="cov1" title="1">{
        return r.client.User.Query().
                Where(
                        user.Or(
                                user.UsernameContains(query),
                                user.EmailContains(query),
                        ),
                ).
                All(ctx)
}</span>

// ChangePassword updates a user's password.
func (r *UserRepository) ChangePassword(ctx context.Context, userID, newPassword string) error <span class="cov1" title="1">{
        u, err := r.client.User.Query().Where(user.ID(userID)).Only(ctx)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov1" title="1">return r.client.User.UpdateOne(u).
                SetPassword(newPassword).
                SetUpdatedAt(time.Now()).
                Exec(ctx)</span>

}

// GetUsersByRole retrieves all users with a specific role.
func (r *UserRepository) GetUsersByRole(ctx context.Context, roleID string) ([]*ent.User, error) <span class="cov1" title="1">{
        return r.client.User.Query().
                Where(user.HasRolesWith(role.ID(roleID))).
                All(ctx)
}</span>

// CheckPassword verifies if the provided password is correct for a user.
func (r *UserRepository) CheckPassword(ctx context.Context, username, password string) bool <span class="cov5" title="5">{
        user, err := r.client.User.Query().Where(user.Username(username)).Only(ctx)
        if err != nil </span><span class="cov0" title="0">{
                return false
        }</span>
        <span class="cov5" title="5">valid, err := pkg.NewPasswordHasher(12).VerifyPassword(user.Password, password)

        return err == nil &amp;&amp; valid</span>
}

// SetPassword sets a new password for a user.
func (r *UserRepository) SetPassword(ctx context.Context, username, password string) error <span class="cov2" title="2">{
        user, err := r.client.User.Query().Where(user.Username(username)).Only(ctx)
        if err != nil </span><span class="cov1" title="1">{
                if ent.IsNotFound(err) </span><span class="cov1" title="1">{
                        return errors.NewError(errors.ErrorTypeNotFound, "User not found", err)
                }</span>
                <span class="cov0" title="0">return err</span>
        }

        <span class="cov1" title="1">return r.client.User.UpdateOne(user).SetPassword(password).Exec(ctx)</span>
}
</pre>
		
		<pre class="file" id="file44" style="display: none">// Code generated by protoc-gen-go. DO NOT EDIT.
// versions:
//         protoc-gen-go v1.34.2
//         protoc        v3.21.12
// source: auth.proto

package grpc

import (
        reflect "reflect"
        sync "sync"

        protoreflect "google.golang.org/protobuf/reflect/protoreflect"
        protoimpl "google.golang.org/protobuf/runtime/protoimpl"
        emptypb "google.golang.org/protobuf/types/known/emptypb"
)

const (
        // Verify that this generated code is sufficiently up-to-date.
        _ = protoimpl.EnforceVersion(20 - protoimpl.MinVersion)
        // Verify that runtime/protoimpl is sufficiently up-to-date.
        _ = protoimpl.EnforceVersion(protoimpl.MaxVersion - 20)
)

type LoginRequest struct {
        state         protoimpl.MessageState
        sizeCache     protoimpl.SizeCache
        unknownFields protoimpl.UnknownFields

        Username string `protobuf:"bytes,1,opt,name=username,proto3" json:"username,omitempty"`
        Password string `protobuf:"bytes,2,opt,name=password,proto3" json:"password,omitempty"`
}

func (x *LoginRequest) Reset() <span class="cov0" title="0">{
        *x = LoginRequest{}
        if protoimpl.UnsafeEnabled </span><span class="cov0" title="0">{
                mi := &amp;file_auth_proto_msgTypes[0]
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                ms.StoreMessageInfo(mi)
        }</span>
}

func (x *LoginRequest) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*LoginRequest) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *LoginRequest) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_auth_proto_msgTypes[0]
        if protoimpl.UnsafeEnabled &amp;&amp; x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use LoginRequest.ProtoReflect.Descriptor instead.
func (*LoginRequest) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_auth_proto_rawDescGZIP(), []int{0}
}</span>

func (x *LoginRequest) GetUsername() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Username
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *LoginRequest) GetPassword() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Password
        }</span>
        <span class="cov0" title="0">return ""</span>
}

type LoginResponse struct {
        state         protoimpl.MessageState
        sizeCache     protoimpl.SizeCache
        unknownFields protoimpl.UnknownFields

        AccessToken  string `protobuf:"bytes,1,opt,name=access_token,json=accessToken,proto3" json:"access_token,omitempty"`
        RefreshToken string `protobuf:"bytes,2,opt,name=refresh_token,json=refreshToken,proto3" json:"refresh_token,omitempty"`
        ExpiresIn    int64  `protobuf:"varint,3,opt,name=expires_in,json=expiresIn,proto3" json:"expires_in,omitempty"`
}

func (x *LoginResponse) Reset() <span class="cov0" title="0">{
        *x = LoginResponse{}
        if protoimpl.UnsafeEnabled </span><span class="cov0" title="0">{
                mi := &amp;file_auth_proto_msgTypes[1]
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                ms.StoreMessageInfo(mi)
        }</span>
}

func (x *LoginResponse) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*LoginResponse) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *LoginResponse) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_auth_proto_msgTypes[1]
        if protoimpl.UnsafeEnabled &amp;&amp; x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use LoginResponse.ProtoReflect.Descriptor instead.
func (*LoginResponse) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_auth_proto_rawDescGZIP(), []int{1}
}</span>

func (x *LoginResponse) GetAccessToken() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.AccessToken
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *LoginResponse) GetRefreshToken() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.RefreshToken
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *LoginResponse) GetExpiresIn() int64 <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.ExpiresIn
        }</span>
        <span class="cov0" title="0">return 0</span>
}

type LogoutRequest struct {
        state         protoimpl.MessageState
        sizeCache     protoimpl.SizeCache
        unknownFields protoimpl.UnknownFields

        AccessToken string `protobuf:"bytes,1,opt,name=access_token,json=accessToken,proto3" json:"access_token,omitempty"`
}

func (x *LogoutRequest) Reset() <span class="cov0" title="0">{
        *x = LogoutRequest{}
        if protoimpl.UnsafeEnabled </span><span class="cov0" title="0">{
                mi := &amp;file_auth_proto_msgTypes[2]
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                ms.StoreMessageInfo(mi)
        }</span>
}

func (x *LogoutRequest) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*LogoutRequest) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *LogoutRequest) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_auth_proto_msgTypes[2]
        if protoimpl.UnsafeEnabled &amp;&amp; x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use LogoutRequest.ProtoReflect.Descriptor instead.
func (*LogoutRequest) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_auth_proto_rawDescGZIP(), []int{2}
}</span>

func (x *LogoutRequest) GetAccessToken() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.AccessToken
        }</span>
        <span class="cov0" title="0">return ""</span>
}

type RefreshTokenRequest struct {
        state         protoimpl.MessageState
        sizeCache     protoimpl.SizeCache
        unknownFields protoimpl.UnknownFields

        RefreshToken string `protobuf:"bytes,1,opt,name=refresh_token,json=refreshToken,proto3" json:"refresh_token,omitempty"`
}

func (x *RefreshTokenRequest) Reset() <span class="cov0" title="0">{
        *x = RefreshTokenRequest{}
        if protoimpl.UnsafeEnabled </span><span class="cov0" title="0">{
                mi := &amp;file_auth_proto_msgTypes[3]
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                ms.StoreMessageInfo(mi)
        }</span>
}

func (x *RefreshTokenRequest) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*RefreshTokenRequest) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *RefreshTokenRequest) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_auth_proto_msgTypes[3]
        if protoimpl.UnsafeEnabled &amp;&amp; x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use RefreshTokenRequest.ProtoReflect.Descriptor instead.
func (*RefreshTokenRequest) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_auth_proto_rawDescGZIP(), []int{3}
}</span>

func (x *RefreshTokenRequest) GetRefreshToken() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.RefreshToken
        }</span>
        <span class="cov0" title="0">return ""</span>
}

type RefreshTokenResponse struct {
        state         protoimpl.MessageState
        sizeCache     protoimpl.SizeCache
        unknownFields protoimpl.UnknownFields

        AccessToken  string `protobuf:"bytes,1,opt,name=access_token,json=accessToken,proto3" json:"access_token,omitempty"`
        RefreshToken string `protobuf:"bytes,2,opt,name=refresh_token,json=refreshToken,proto3" json:"refresh_token,omitempty"`
        ExpiresIn    int64  `protobuf:"varint,3,opt,name=expires_in,json=expiresIn,proto3" json:"expires_in,omitempty"`
}

func (x *RefreshTokenResponse) Reset() <span class="cov0" title="0">{
        *x = RefreshTokenResponse{}
        if protoimpl.UnsafeEnabled </span><span class="cov0" title="0">{
                mi := &amp;file_auth_proto_msgTypes[4]
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                ms.StoreMessageInfo(mi)
        }</span>
}

func (x *RefreshTokenResponse) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*RefreshTokenResponse) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *RefreshTokenResponse) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_auth_proto_msgTypes[4]
        if protoimpl.UnsafeEnabled &amp;&amp; x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use RefreshTokenResponse.ProtoReflect.Descriptor instead.
func (*RefreshTokenResponse) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_auth_proto_rawDescGZIP(), []int{4}
}</span>

func (x *RefreshTokenResponse) GetAccessToken() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.AccessToken
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *RefreshTokenResponse) GetRefreshToken() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.RefreshToken
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *RefreshTokenResponse) GetExpiresIn() int64 <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.ExpiresIn
        }</span>
        <span class="cov0" title="0">return 0</span>
}

type ValidateTokenRequest struct {
        state         protoimpl.MessageState
        sizeCache     protoimpl.SizeCache
        unknownFields protoimpl.UnknownFields

        Token string `protobuf:"bytes,1,opt,name=token,proto3" json:"token,omitempty"`
}

func (x *ValidateTokenRequest) Reset() <span class="cov0" title="0">{
        *x = ValidateTokenRequest{}
        if protoimpl.UnsafeEnabled </span><span class="cov0" title="0">{
                mi := &amp;file_auth_proto_msgTypes[5]
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                ms.StoreMessageInfo(mi)
        }</span>
}

func (x *ValidateTokenRequest) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*ValidateTokenRequest) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *ValidateTokenRequest) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_auth_proto_msgTypes[5]
        if protoimpl.UnsafeEnabled &amp;&amp; x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use ValidateTokenRequest.ProtoReflect.Descriptor instead.
func (*ValidateTokenRequest) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_auth_proto_rawDescGZIP(), []int{5}
}</span>

func (x *ValidateTokenRequest) GetToken() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Token
        }</span>
        <span class="cov0" title="0">return ""</span>
}

type ValidateTokenResponse struct {
        state         protoimpl.MessageState
        sizeCache     protoimpl.SizeCache
        unknownFields protoimpl.UnknownFields

        User *User `protobuf:"bytes,1,opt,name=user,proto3" json:"user,omitempty"`
}

func (x *ValidateTokenResponse) Reset() <span class="cov0" title="0">{
        *x = ValidateTokenResponse{}
        if protoimpl.UnsafeEnabled </span><span class="cov0" title="0">{
                mi := &amp;file_auth_proto_msgTypes[6]
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                ms.StoreMessageInfo(mi)
        }</span>
}

func (x *ValidateTokenResponse) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*ValidateTokenResponse) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *ValidateTokenResponse) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_auth_proto_msgTypes[6]
        if protoimpl.UnsafeEnabled &amp;&amp; x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use ValidateTokenResponse.ProtoReflect.Descriptor instead.
func (*ValidateTokenResponse) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_auth_proto_rawDescGZIP(), []int{6}
}</span>

func (x *ValidateTokenResponse) GetUser() *User <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.User
        }</span>
        <span class="cov0" title="0">return nil</span>
}

type RegisterUserRequest struct {
        state         protoimpl.MessageState
        sizeCache     protoimpl.SizeCache
        unknownFields protoimpl.UnknownFields

        Username string `protobuf:"bytes,1,opt,name=username,proto3" json:"username,omitempty"`
        Email    string `protobuf:"bytes,2,opt,name=email,proto3" json:"email,omitempty"`
        Password string `protobuf:"bytes,3,opt,name=password,proto3" json:"password,omitempty"`
}

func (x *RegisterUserRequest) Reset() <span class="cov0" title="0">{
        *x = RegisterUserRequest{}
        if protoimpl.UnsafeEnabled </span><span class="cov0" title="0">{
                mi := &amp;file_auth_proto_msgTypes[7]
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                ms.StoreMessageInfo(mi)
        }</span>
}

func (x *RegisterUserRequest) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*RegisterUserRequest) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *RegisterUserRequest) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_auth_proto_msgTypes[7]
        if protoimpl.UnsafeEnabled &amp;&amp; x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use RegisterUserRequest.ProtoReflect.Descriptor instead.
func (*RegisterUserRequest) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_auth_proto_rawDescGZIP(), []int{7}
}</span>

func (x *RegisterUserRequest) GetUsername() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Username
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *RegisterUserRequest) GetEmail() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Email
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *RegisterUserRequest) GetPassword() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Password
        }</span>
        <span class="cov0" title="0">return ""</span>
}

type RegisterUserResponse struct {
        state         protoimpl.MessageState
        sizeCache     protoimpl.SizeCache
        unknownFields protoimpl.UnknownFields

        User *User `protobuf:"bytes,1,opt,name=user,proto3" json:"user,omitempty"`
}

func (x *RegisterUserResponse) Reset() <span class="cov0" title="0">{
        *x = RegisterUserResponse{}
        if protoimpl.UnsafeEnabled </span><span class="cov0" title="0">{
                mi := &amp;file_auth_proto_msgTypes[8]
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                ms.StoreMessageInfo(mi)
        }</span>
}

func (x *RegisterUserResponse) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*RegisterUserResponse) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *RegisterUserResponse) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_auth_proto_msgTypes[8]
        if protoimpl.UnsafeEnabled &amp;&amp; x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use RegisterUserResponse.ProtoReflect.Descriptor instead.
func (*RegisterUserResponse) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_auth_proto_rawDescGZIP(), []int{8}
}</span>

func (x *RegisterUserResponse) GetUser() *User <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.User
        }</span>
        <span class="cov0" title="0">return nil</span>
}

type UpdateUserRequest struct {
        state         protoimpl.MessageState
        sizeCache     protoimpl.SizeCache
        unknownFields protoimpl.UnknownFields

        UserId   string  `protobuf:"bytes,1,opt,name=user_id,json=userId,proto3" json:"user_id,omitempty"`
        Username *string `protobuf:"bytes,2,opt,name=username,proto3,oneof" json:"username,omitempty"`
        Email    *string `protobuf:"bytes,3,opt,name=email,proto3,oneof" json:"email,omitempty"`
        Password *string `protobuf:"bytes,4,opt,name=password,proto3,oneof" json:"password,omitempty"`
}

func (x *UpdateUserRequest) Reset() <span class="cov0" title="0">{
        *x = UpdateUserRequest{}
        if protoimpl.UnsafeEnabled </span><span class="cov0" title="0">{
                mi := &amp;file_auth_proto_msgTypes[9]
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                ms.StoreMessageInfo(mi)
        }</span>
}

func (x *UpdateUserRequest) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*UpdateUserRequest) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *UpdateUserRequest) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_auth_proto_msgTypes[9]
        if protoimpl.UnsafeEnabled &amp;&amp; x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use UpdateUserRequest.ProtoReflect.Descriptor instead.
func (*UpdateUserRequest) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_auth_proto_rawDescGZIP(), []int{9}
}</span>

func (x *UpdateUserRequest) GetUserId() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.UserId
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *UpdateUserRequest) GetUsername() string <span class="cov0" title="0">{
        if x != nil &amp;&amp; x.Username != nil </span><span class="cov0" title="0">{
                return *x.Username
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *UpdateUserRequest) GetEmail() string <span class="cov0" title="0">{
        if x != nil &amp;&amp; x.Email != nil </span><span class="cov0" title="0">{
                return *x.Email
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *UpdateUserRequest) GetPassword() string <span class="cov0" title="0">{
        if x != nil &amp;&amp; x.Password != nil </span><span class="cov0" title="0">{
                return *x.Password
        }</span>
        <span class="cov0" title="0">return ""</span>
}

type UpdateUserResponse struct {
        state         protoimpl.MessageState
        sizeCache     protoimpl.SizeCache
        unknownFields protoimpl.UnknownFields

        User *User `protobuf:"bytes,1,opt,name=user,proto3" json:"user,omitempty"`
}

func (x *UpdateUserResponse) Reset() <span class="cov0" title="0">{
        *x = UpdateUserResponse{}
        if protoimpl.UnsafeEnabled </span><span class="cov0" title="0">{
                mi := &amp;file_auth_proto_msgTypes[10]
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                ms.StoreMessageInfo(mi)
        }</span>
}

func (x *UpdateUserResponse) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*UpdateUserResponse) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *UpdateUserResponse) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_auth_proto_msgTypes[10]
        if protoimpl.UnsafeEnabled &amp;&amp; x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use UpdateUserResponse.ProtoReflect.Descriptor instead.
func (*UpdateUserResponse) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_auth_proto_rawDescGZIP(), []int{10}
}</span>

func (x *UpdateUserResponse) GetUser() *User <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.User
        }</span>
        <span class="cov0" title="0">return nil</span>
}

type DeleteUserRequest struct {
        state         protoimpl.MessageState
        sizeCache     protoimpl.SizeCache
        unknownFields protoimpl.UnknownFields

        UserId string `protobuf:"bytes,1,opt,name=user_id,json=userId,proto3" json:"user_id,omitempty"`
}

func (x *DeleteUserRequest) Reset() <span class="cov0" title="0">{
        *x = DeleteUserRequest{}
        if protoimpl.UnsafeEnabled </span><span class="cov0" title="0">{
                mi := &amp;file_auth_proto_msgTypes[11]
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                ms.StoreMessageInfo(mi)
        }</span>
}

func (x *DeleteUserRequest) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*DeleteUserRequest) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *DeleteUserRequest) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_auth_proto_msgTypes[11]
        if protoimpl.UnsafeEnabled &amp;&amp; x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use DeleteUserRequest.ProtoReflect.Descriptor instead.
func (*DeleteUserRequest) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_auth_proto_rawDescGZIP(), []int{11}
}</span>

func (x *DeleteUserRequest) GetUserId() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.UserId
        }</span>
        <span class="cov0" title="0">return ""</span>
}

type GetUserRequest struct {
        state         protoimpl.MessageState
        sizeCache     protoimpl.SizeCache
        unknownFields protoimpl.UnknownFields

        UserId string `protobuf:"bytes,1,opt,name=user_id,json=userId,proto3" json:"user_id,omitempty"`
}

func (x *GetUserRequest) Reset() <span class="cov0" title="0">{
        *x = GetUserRequest{}
        if protoimpl.UnsafeEnabled </span><span class="cov0" title="0">{
                mi := &amp;file_auth_proto_msgTypes[12]
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                ms.StoreMessageInfo(mi)
        }</span>
}

func (x *GetUserRequest) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*GetUserRequest) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *GetUserRequest) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_auth_proto_msgTypes[12]
        if protoimpl.UnsafeEnabled &amp;&amp; x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use GetUserRequest.ProtoReflect.Descriptor instead.
func (*GetUserRequest) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_auth_proto_rawDescGZIP(), []int{12}
}</span>

func (x *GetUserRequest) GetUserId() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.UserId
        }</span>
        <span class="cov0" title="0">return ""</span>
}

type GetUserResponse struct {
        state         protoimpl.MessageState
        sizeCache     protoimpl.SizeCache
        unknownFields protoimpl.UnknownFields

        User *User `protobuf:"bytes,1,opt,name=user,proto3" json:"user,omitempty"`
}

func (x *GetUserResponse) Reset() <span class="cov0" title="0">{
        *x = GetUserResponse{}
        if protoimpl.UnsafeEnabled </span><span class="cov0" title="0">{
                mi := &amp;file_auth_proto_msgTypes[13]
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                ms.StoreMessageInfo(mi)
        }</span>
}

func (x *GetUserResponse) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*GetUserResponse) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *GetUserResponse) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_auth_proto_msgTypes[13]
        if protoimpl.UnsafeEnabled &amp;&amp; x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use GetUserResponse.ProtoReflect.Descriptor instead.
func (*GetUserResponse) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_auth_proto_rawDescGZIP(), []int{13}
}</span>

func (x *GetUserResponse) GetUser() *User <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.User
        }</span>
        <span class="cov0" title="0">return nil</span>
}

var File_auth_proto protoreflect.FileDescriptor

var file_auth_proto_rawDesc = []byte{
        0x0a, 0x0a, 0x61, 0x75, 0x74, 0x68, 0x2e, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x12, 0x0e, 0x64, 0x61,
        0x74, 0x61, 0x76, 0x69, 0x6e, 0x63, 0x69, 0x2e, 0x61, 0x75, 0x74, 0x68, 0x1a, 0x1b, 0x67, 0x6f,
        0x6f, 0x67, 0x6c, 0x65, 0x2f, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x62, 0x75, 0x66, 0x2f, 0x65, 0x6d,
        0x70, 0x74, 0x79, 0x2e, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x1a, 0x0c, 0x63, 0x6f, 0x6d, 0x6d, 0x6f,
        0x6e, 0x2e, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x22, 0x46, 0x0a, 0x0c, 0x4c, 0x6f, 0x67, 0x69, 0x6e,
        0x52, 0x65, 0x71, 0x75, 0x65, 0x73, 0x74, 0x12, 0x1a, 0x0a, 0x08, 0x75, 0x73, 0x65, 0x72, 0x6e,
        0x61, 0x6d, 0x65, 0x18, 0x01, 0x20, 0x01, 0x28, 0x09, 0x52, 0x08, 0x75, 0x73, 0x65, 0x72, 0x6e,
        0x61, 0x6d, 0x65, 0x12, 0x1a, 0x0a, 0x08, 0x70, 0x61, 0x73, 0x73, 0x77, 0x6f, 0x72, 0x64, 0x18,
        0x02, 0x20, 0x01, 0x28, 0x09, 0x52, 0x08, 0x70, 0x61, 0x73, 0x73, 0x77, 0x6f, 0x72, 0x64, 0x22,
        0x76, 0x0a, 0x0d, 0x4c, 0x6f, 0x67, 0x69, 0x6e, 0x52, 0x65, 0x73, 0x70, 0x6f, 0x6e, 0x73, 0x65,
        0x12, 0x21, 0x0a, 0x0c, 0x61, 0x63, 0x63, 0x65, 0x73, 0x73, 0x5f, 0x74, 0x6f, 0x6b, 0x65, 0x6e,
        0x18, 0x01, 0x20, 0x01, 0x28, 0x09, 0x52, 0x0b, 0x61, 0x63, 0x63, 0x65, 0x73, 0x73, 0x54, 0x6f,
        0x6b, 0x65, 0x6e, 0x12, 0x23, 0x0a, 0x0d, 0x72, 0x65, 0x66, 0x72, 0x65, 0x73, 0x68, 0x5f, 0x74,
        0x6f, 0x6b, 0x65, 0x6e, 0x18, 0x02, 0x20, 0x01, 0x28, 0x09, 0x52, 0x0c, 0x72, 0x65, 0x66, 0x72,
        0x65, 0x73, 0x68, 0x54, 0x6f, 0x6b, 0x65, 0x6e, 0x12, 0x1d, 0x0a, 0x0a, 0x65, 0x78, 0x70, 0x69,
        0x72, 0x65, 0x73, 0x5f, 0x69, 0x6e, 0x18, 0x03, 0x20, 0x01, 0x28, 0x03, 0x52, 0x09, 0x65, 0x78,
        0x70, 0x69, 0x72, 0x65, 0x73, 0x49, 0x6e, 0x22, 0x32, 0x0a, 0x0d, 0x4c, 0x6f, 0x67, 0x6f, 0x75,
        0x74, 0x52, 0x65, 0x71, 0x75, 0x65, 0x73, 0x74, 0x12, 0x21, 0x0a, 0x0c, 0x61, 0x63, 0x63, 0x65,
        0x73, 0x73, 0x5f, 0x74, 0x6f, 0x6b, 0x65, 0x6e, 0x18, 0x01, 0x20, 0x01, 0x28, 0x09, 0x52, 0x0b,
        0x61, 0x63, 0x63, 0x65, 0x73, 0x73, 0x54, 0x6f, 0x6b, 0x65, 0x6e, 0x22, 0x3a, 0x0a, 0x13, 0x52,
        0x65, 0x66, 0x72, 0x65, 0x73, 0x68, 0x54, 0x6f, 0x6b, 0x65, 0x6e, 0x52, 0x65, 0x71, 0x75, 0x65,
        0x73, 0x74, 0x12, 0x23, 0x0a, 0x0d, 0x72, 0x65, 0x66, 0x72, 0x65, 0x73, 0x68, 0x5f, 0x74, 0x6f,
        0x6b, 0x65, 0x6e, 0x18, 0x01, 0x20, 0x01, 0x28, 0x09, 0x52, 0x0c, 0x72, 0x65, 0x66, 0x72, 0x65,
        0x73, 0x68, 0x54, 0x6f, 0x6b, 0x65, 0x6e, 0x22, 0x7d, 0x0a, 0x14, 0x52, 0x65, 0x66, 0x72, 0x65,
        0x73, 0x68, 0x54, 0x6f, 0x6b, 0x65, 0x6e, 0x52, 0x65, 0x73, 0x70, 0x6f, 0x6e, 0x73, 0x65, 0x12,
        0x21, 0x0a, 0x0c, 0x61, 0x63, 0x63, 0x65, 0x73, 0x73, 0x5f, 0x74, 0x6f, 0x6b, 0x65, 0x6e, 0x18,
        0x01, 0x20, 0x01, 0x28, 0x09, 0x52, 0x0b, 0x61, 0x63, 0x63, 0x65, 0x73, 0x73, 0x54, 0x6f, 0x6b,
        0x65, 0x6e, 0x12, 0x23, 0x0a, 0x0d, 0x72, 0x65, 0x66, 0x72, 0x65, 0x73, 0x68, 0x5f, 0x74, 0x6f,
        0x6b, 0x65, 0x6e, 0x18, 0x02, 0x20, 0x01, 0x28, 0x09, 0x52, 0x0c, 0x72, 0x65, 0x66, 0x72, 0x65,
        0x73, 0x68, 0x54, 0x6f, 0x6b, 0x65, 0x6e, 0x12, 0x1d, 0x0a, 0x0a, 0x65, 0x78, 0x70, 0x69, 0x72,
        0x65, 0x73, 0x5f, 0x69, 0x6e, 0x18, 0x03, 0x20, 0x01, 0x28, 0x03, 0x52, 0x09, 0x65, 0x78, 0x70,
        0x69, 0x72, 0x65, 0x73, 0x49, 0x6e, 0x22, 0x2c, 0x0a, 0x14, 0x56, 0x61, 0x6c, 0x69, 0x64, 0x61,
        0x74, 0x65, 0x54, 0x6f, 0x6b, 0x65, 0x6e, 0x52, 0x65, 0x71, 0x75, 0x65, 0x73, 0x74, 0x12, 0x14,
        0x0a, 0x05, 0x74, 0x6f, 0x6b, 0x65, 0x6e, 0x18, 0x01, 0x20, 0x01, 0x28, 0x09, 0x52, 0x05, 0x74,
        0x6f, 0x6b, 0x65, 0x6e, 0x22, 0x41, 0x0a, 0x15, 0x56, 0x61, 0x6c, 0x69, 0x64, 0x61, 0x74, 0x65,
        0x54, 0x6f, 0x6b, 0x65, 0x6e, 0x52, 0x65, 0x73, 0x70, 0x6f, 0x6e, 0x73, 0x65, 0x12, 0x28, 0x0a,
        0x04, 0x75, 0x73, 0x65, 0x72, 0x18, 0x01, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x14, 0x2e, 0x64, 0x61,
        0x74, 0x61, 0x76, 0x69, 0x6e, 0x63, 0x69, 0x2e, 0x61, 0x75, 0x74, 0x68, 0x2e, 0x55, 0x73, 0x65,
        0x72, 0x52, 0x04, 0x75, 0x73, 0x65, 0x72, 0x22, 0x63, 0x0a, 0x13, 0x52, 0x65, 0x67, 0x69, 0x73,
        0x74, 0x65, 0x72, 0x55, 0x73, 0x65, 0x72, 0x52, 0x65, 0x71, 0x75, 0x65, 0x73, 0x74, 0x12, 0x1a,
        0x0a, 0x08, 0x75, 0x73, 0x65, 0x72, 0x6e, 0x61, 0x6d, 0x65, 0x18, 0x01, 0x20, 0x01, 0x28, 0x09,
        0x52, 0x08, 0x75, 0x73, 0x65, 0x72, 0x6e, 0x61, 0x6d, 0x65, 0x12, 0x14, 0x0a, 0x05, 0x65, 0x6d,
        0x61, 0x69, 0x6c, 0x18, 0x02, 0x20, 0x01, 0x28, 0x09, 0x52, 0x05, 0x65, 0x6d, 0x61, 0x69, 0x6c,
        0x12, 0x1a, 0x0a, 0x08, 0x70, 0x61, 0x73, 0x73, 0x77, 0x6f, 0x72, 0x64, 0x18, 0x03, 0x20, 0x01,
        0x28, 0x09, 0x52, 0x08, 0x70, 0x61, 0x73, 0x73, 0x77, 0x6f, 0x72, 0x64, 0x22, 0x40, 0x0a, 0x14,
        0x52, 0x65, 0x67, 0x69, 0x73, 0x74, 0x65, 0x72, 0x55, 0x73, 0x65, 0x72, 0x52, 0x65, 0x73, 0x70,
        0x6f, 0x6e, 0x73, 0x65, 0x12, 0x28, 0x0a, 0x04, 0x75, 0x73, 0x65, 0x72, 0x18, 0x01, 0x20, 0x01,
        0x28, 0x0b, 0x32, 0x14, 0x2e, 0x64, 0x61, 0x74, 0x61, 0x76, 0x69, 0x6e, 0x63, 0x69, 0x2e, 0x61,
        0x75, 0x74, 0x68, 0x2e, 0x55, 0x73, 0x65, 0x72, 0x52, 0x04, 0x75, 0x73, 0x65, 0x72, 0x22, 0xad,
        0x01, 0x0a, 0x11, 0x55, 0x70, 0x64, 0x61, 0x74, 0x65, 0x55, 0x73, 0x65, 0x72, 0x52, 0x65, 0x71,
        0x75, 0x65, 0x73, 0x74, 0x12, 0x17, 0x0a, 0x07, 0x75, 0x73, 0x65, 0x72, 0x5f, 0x69, 0x64, 0x18,
        0x01, 0x20, 0x01, 0x28, 0x09, 0x52, 0x06, 0x75, 0x73, 0x65, 0x72, 0x49, 0x64, 0x12, 0x1f, 0x0a,
        0x08, 0x75, 0x73, 0x65, 0x72, 0x6e, 0x61, 0x6d, 0x65, 0x18, 0x02, 0x20, 0x01, 0x28, 0x09, 0x48,
        0x00, 0x52, 0x08, 0x75, 0x73, 0x65, 0x72, 0x6e, 0x61, 0x6d, 0x65, 0x88, 0x01, 0x01, 0x12, 0x19,
        0x0a, 0x05, 0x65, 0x6d, 0x61, 0x69, 0x6c, 0x18, 0x03, 0x20, 0x01, 0x28, 0x09, 0x48, 0x01, 0x52,
        0x05, 0x65, 0x6d, 0x61, 0x69, 0x6c, 0x88, 0x01, 0x01, 0x12, 0x1f, 0x0a, 0x08, 0x70, 0x61, 0x73,
        0x73, 0x77, 0x6f, 0x72, 0x64, 0x18, 0x04, 0x20, 0x01, 0x28, 0x09, 0x48, 0x02, 0x52, 0x08, 0x70,
        0x61, 0x73, 0x73, 0x77, 0x6f, 0x72, 0x64, 0x88, 0x01, 0x01, 0x42, 0x0b, 0x0a, 0x09, 0x5f, 0x75,
        0x73, 0x65, 0x72, 0x6e, 0x61, 0x6d, 0x65, 0x42, 0x08, 0x0a, 0x06, 0x5f, 0x65, 0x6d, 0x61, 0x69,
        0x6c, 0x42, 0x0b, 0x0a, 0x09, 0x5f, 0x70, 0x61, 0x73, 0x73, 0x77, 0x6f, 0x72, 0x64, 0x22, 0x3e,
        0x0a, 0x12, 0x55, 0x70, 0x64, 0x61, 0x74, 0x65, 0x55, 0x73, 0x65, 0x72, 0x52, 0x65, 0x73, 0x70,
        0x6f, 0x6e, 0x73, 0x65, 0x12, 0x28, 0x0a, 0x04, 0x75, 0x73, 0x65, 0x72, 0x18, 0x01, 0x20, 0x01,
        0x28, 0x0b, 0x32, 0x14, 0x2e, 0x64, 0x61, 0x74, 0x61, 0x76, 0x69, 0x6e, 0x63, 0x69, 0x2e, 0x61,
        0x75, 0x74, 0x68, 0x2e, 0x55, 0x73, 0x65, 0x72, 0x52, 0x04, 0x75, 0x73, 0x65, 0x72, 0x22, 0x2c,
        0x0a, 0x11, 0x44, 0x65, 0x6c, 0x65, 0x74, 0x65, 0x55, 0x73, 0x65, 0x72, 0x52, 0x65, 0x71, 0x75,
        0x65, 0x73, 0x74, 0x12, 0x17, 0x0a, 0x07, 0x75, 0x73, 0x65, 0x72, 0x5f, 0x69, 0x64, 0x18, 0x01,
        0x20, 0x01, 0x28, 0x09, 0x52, 0x06, 0x75, 0x73, 0x65, 0x72, 0x49, 0x64, 0x22, 0x29, 0x0a, 0x0e,
        0x47, 0x65, 0x74, 0x55, 0x73, 0x65, 0x72, 0x52, 0x65, 0x71, 0x75, 0x65, 0x73, 0x74, 0x12, 0x17,
        0x0a, 0x07, 0x75, 0x73, 0x65, 0x72, 0x5f, 0x69, 0x64, 0x18, 0x01, 0x20, 0x01, 0x28, 0x09, 0x52,
        0x06, 0x75, 0x73, 0x65, 0x72, 0x49, 0x64, 0x22, 0x3b, 0x0a, 0x0f, 0x47, 0x65, 0x74, 0x55, 0x73,
        0x65, 0x72, 0x52, 0x65, 0x73, 0x70, 0x6f, 0x6e, 0x73, 0x65, 0x12, 0x28, 0x0a, 0x04, 0x75, 0x73,
        0x65, 0x72, 0x18, 0x01, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x14, 0x2e, 0x64, 0x61, 0x74, 0x61, 0x76,
        0x69, 0x6e, 0x63, 0x69, 0x2e, 0x61, 0x75, 0x74, 0x68, 0x2e, 0x55, 0x73, 0x65, 0x72, 0x52, 0x04,
        0x75, 0x73, 0x65, 0x72, 0x32, 0xa2, 0x05, 0x0a, 0x0b, 0x41, 0x75, 0x74, 0x68, 0x53, 0x65, 0x72,
        0x76, 0x69, 0x63, 0x65, 0x12, 0x46, 0x0a, 0x05, 0x4c, 0x6f, 0x67, 0x69, 0x6e, 0x12, 0x1c, 0x2e,
        0x64, 0x61, 0x74, 0x61, 0x76, 0x69, 0x6e, 0x63, 0x69, 0x2e, 0x61, 0x75, 0x74, 0x68, 0x2e, 0x4c,
        0x6f, 0x67, 0x69, 0x6e, 0x52, 0x65, 0x71, 0x75, 0x65, 0x73, 0x74, 0x1a, 0x1d, 0x2e, 0x64, 0x61,
        0x74, 0x61, 0x76, 0x69, 0x6e, 0x63, 0x69, 0x2e, 0x61, 0x75, 0x74, 0x68, 0x2e, 0x4c, 0x6f, 0x67,
        0x69, 0x6e, 0x52, 0x65, 0x73, 0x70, 0x6f, 0x6e, 0x73, 0x65, 0x22, 0x00, 0x12, 0x41, 0x0a, 0x06,
        0x4c, 0x6f, 0x67, 0x6f, 0x75, 0x74, 0x12, 0x1d, 0x2e, 0x64, 0x61, 0x74, 0x61, 0x76, 0x69, 0x6e,
        0x63, 0x69, 0x2e, 0x61, 0x75, 0x74, 0x68, 0x2e, 0x4c, 0x6f, 0x67, 0x6f, 0x75, 0x74, 0x52, 0x65,
        0x71, 0x75, 0x65, 0x73, 0x74, 0x1a, 0x16, 0x2e, 0x67, 0x6f, 0x6f, 0x67, 0x6c, 0x65, 0x2e, 0x70,
        0x72, 0x6f, 0x74, 0x6f, 0x62, 0x75, 0x66, 0x2e, 0x45, 0x6d, 0x70, 0x74, 0x79, 0x22, 0x00, 0x12,
        0x5b, 0x0a, 0x0c, 0x52, 0x65, 0x66, 0x72, 0x65, 0x73, 0x68, 0x54, 0x6f, 0x6b, 0x65, 0x6e, 0x12,
        0x23, 0x2e, 0x64, 0x61, 0x74, 0x61, 0x76, 0x69, 0x6e, 0x63, 0x69, 0x2e, 0x61, 0x75, 0x74, 0x68,
        0x2e, 0x52, 0x65, 0x66, 0x72, 0x65, 0x73, 0x68, 0x54, 0x6f, 0x6b, 0x65, 0x6e, 0x52, 0x65, 0x71,
        0x75, 0x65, 0x73, 0x74, 0x1a, 0x24, 0x2e, 0x64, 0x61, 0x74, 0x61, 0x76, 0x69, 0x6e, 0x63, 0x69,
        0x2e, 0x61, 0x75, 0x74, 0x68, 0x2e, 0x52, 0x65, 0x66, 0x72, 0x65, 0x73, 0x68, 0x54, 0x6f, 0x6b,
        0x65, 0x6e, 0x52, 0x65, 0x73, 0x70, 0x6f, 0x6e, 0x73, 0x65, 0x22, 0x00, 0x12, 0x5e, 0x0a, 0x0d,
        0x56, 0x61, 0x6c, 0x69, 0x64, 0x61, 0x74, 0x65, 0x54, 0x6f, 0x6b, 0x65, 0x6e, 0x12, 0x24, 0x2e,
        0x64, 0x61, 0x74, 0x61, 0x76, 0x69, 0x6e, 0x63, 0x69, 0x2e, 0x61, 0x75, 0x74, 0x68, 0x2e, 0x56,
        0x61, 0x6c, 0x69, 0x64, 0x61, 0x74, 0x65, 0x54, 0x6f, 0x6b, 0x65, 0x6e, 0x52, 0x65, 0x71, 0x75,
        0x65, 0x73, 0x74, 0x1a, 0x25, 0x2e, 0x64, 0x61, 0x74, 0x61, 0x76, 0x69, 0x6e, 0x63, 0x69, 0x2e,
        0x61, 0x75, 0x74, 0x68, 0x2e, 0x56, 0x61, 0x6c, 0x69, 0x64, 0x61, 0x74, 0x65, 0x54, 0x6f, 0x6b,
        0x65, 0x6e, 0x52, 0x65, 0x73, 0x70, 0x6f, 0x6e, 0x73, 0x65, 0x22, 0x00, 0x12, 0x5b, 0x0a, 0x0c,
        0x52, 0x65, 0x67, 0x69, 0x73, 0x74, 0x65, 0x72, 0x55, 0x73, 0x65, 0x72, 0x12, 0x23, 0x2e, 0x64,
        0x61, 0x74, 0x61, 0x76, 0x69, 0x6e, 0x63, 0x69, 0x2e, 0x61, 0x75, 0x74, 0x68, 0x2e, 0x52, 0x65,
        0x67, 0x69, 0x73, 0x74, 0x65, 0x72, 0x55, 0x73, 0x65, 0x72, 0x52, 0x65, 0x71, 0x75, 0x65, 0x73,
        0x74, 0x1a, 0x24, 0x2e, 0x64, 0x61, 0x74, 0x61, 0x76, 0x69, 0x6e, 0x63, 0x69, 0x2e, 0x61, 0x75,
        0x74, 0x68, 0x2e, 0x52, 0x65, 0x67, 0x69, 0x73, 0x74, 0x65, 0x72, 0x55, 0x73, 0x65, 0x72, 0x52,
        0x65, 0x73, 0x70, 0x6f, 0x6e, 0x73, 0x65, 0x22, 0x00, 0x12, 0x55, 0x0a, 0x0a, 0x55, 0x70, 0x64,
        0x61, 0x74, 0x65, 0x55, 0x73, 0x65, 0x72, 0x12, 0x21, 0x2e, 0x64, 0x61, 0x74, 0x61, 0x76, 0x69,
        0x6e, 0x63, 0x69, 0x2e, 0x61, 0x75, 0x74, 0x68, 0x2e, 0x55, 0x70, 0x64, 0x61, 0x74, 0x65, 0x55,
        0x73, 0x65, 0x72, 0x52, 0x65, 0x71, 0x75, 0x65, 0x73, 0x74, 0x1a, 0x22, 0x2e, 0x64, 0x61, 0x74,
        0x61, 0x76, 0x69, 0x6e, 0x63, 0x69, 0x2e, 0x61, 0x75, 0x74, 0x68, 0x2e, 0x55, 0x70, 0x64, 0x61,
        0x74, 0x65, 0x55, 0x73, 0x65, 0x72, 0x52, 0x65, 0x73, 0x70, 0x6f, 0x6e, 0x73, 0x65, 0x22, 0x00,
        0x12, 0x49, 0x0a, 0x0a, 0x44, 0x65, 0x6c, 0x65, 0x74, 0x65, 0x55, 0x73, 0x65, 0x72, 0x12, 0x21,
        0x2e, 0x64, 0x61, 0x74, 0x61, 0x76, 0x69, 0x6e, 0x63, 0x69, 0x2e, 0x61, 0x75, 0x74, 0x68, 0x2e,
        0x44, 0x65, 0x6c, 0x65, 0x74, 0x65, 0x55, 0x73, 0x65, 0x72, 0x52, 0x65, 0x71, 0x75, 0x65, 0x73,
        0x74, 0x1a, 0x16, 0x2e, 0x67, 0x6f, 0x6f, 0x67, 0x6c, 0x65, 0x2e, 0x70, 0x72, 0x6f, 0x74, 0x6f,
        0x62, 0x75, 0x66, 0x2e, 0x45, 0x6d, 0x70, 0x74, 0x79, 0x22, 0x00, 0x12, 0x4c, 0x0a, 0x07, 0x47,
        0x65, 0x74, 0x55, 0x73, 0x65, 0x72, 0x12, 0x1e, 0x2e, 0x64, 0x61, 0x74, 0x61, 0x76, 0x69, 0x6e,
        0x63, 0x69, 0x2e, 0x61, 0x75, 0x74, 0x68, 0x2e, 0x47, 0x65, 0x74, 0x55, 0x73, 0x65, 0x72, 0x52,
        0x65, 0x71, 0x75, 0x65, 0x73, 0x74, 0x1a, 0x1f, 0x2e, 0x64, 0x61, 0x74, 0x61, 0x76, 0x69, 0x6e,
        0x63, 0x69, 0x2e, 0x61, 0x75, 0x74, 0x68, 0x2e, 0x47, 0x65, 0x74, 0x55, 0x73, 0x65, 0x72, 0x52,
        0x65, 0x73, 0x70, 0x6f, 0x6e, 0x73, 0x65, 0x22, 0x00, 0x42, 0x1e, 0x5a, 0x1c, 0x64, 0x61, 0x74,
        0x61, 0x76, 0x69, 0x6e, 0x63, 0x69, 0x2f, 0x69, 0x6e, 0x74, 0x65, 0x72, 0x6e, 0x61, 0x6c, 0x2f,
        0x61, 0x75, 0x74, 0x68, 0x2f, 0x67, 0x72, 0x70, 0x63, 0x62, 0x06, 0x70, 0x72, 0x6f, 0x74, 0x6f,
        0x33,
}

var (
        file_auth_proto_rawDescOnce sync.Once
        file_auth_proto_rawDescData = file_auth_proto_rawDesc
)

func file_auth_proto_rawDescGZIP() []byte <span class="cov0" title="0">{
        file_auth_proto_rawDescOnce.Do(func() </span><span class="cov0" title="0">{
                file_auth_proto_rawDescData = protoimpl.X.CompressGZIP(file_auth_proto_rawDescData)
        }</span>)
        <span class="cov0" title="0">return file_auth_proto_rawDescData</span>
}

var file_auth_proto_msgTypes = make([]protoimpl.MessageInfo, 14)
var file_auth_proto_goTypes = []any{
        (*LoginRequest)(nil),          // 0: datavinci.auth.LoginRequest
        (*LoginResponse)(nil),         // 1: datavinci.auth.LoginResponse
        (*LogoutRequest)(nil),         // 2: datavinci.auth.LogoutRequest
        (*RefreshTokenRequest)(nil),   // 3: datavinci.auth.RefreshTokenRequest
        (*RefreshTokenResponse)(nil),  // 4: datavinci.auth.RefreshTokenResponse
        (*ValidateTokenRequest)(nil),  // 5: datavinci.auth.ValidateTokenRequest
        (*ValidateTokenResponse)(nil), // 6: datavinci.auth.ValidateTokenResponse
        (*RegisterUserRequest)(nil),   // 7: datavinci.auth.RegisterUserRequest
        (*RegisterUserResponse)(nil),  // 8: datavinci.auth.RegisterUserResponse
        (*UpdateUserRequest)(nil),     // 9: datavinci.auth.UpdateUserRequest
        (*UpdateUserResponse)(nil),    // 10: datavinci.auth.UpdateUserResponse
        (*DeleteUserRequest)(nil),     // 11: datavinci.auth.DeleteUserRequest
        (*GetUserRequest)(nil),        // 12: datavinci.auth.GetUserRequest
        (*GetUserResponse)(nil),       // 13: datavinci.auth.GetUserResponse
        (*User)(nil),                  // 14: datavinci.auth.User
        (*emptypb.Empty)(nil),         // 15: google.protobuf.Empty
}
var file_auth_proto_depIdxs = []int32{
        14, // 0: datavinci.auth.ValidateTokenResponse.user:type_name -&gt; datavinci.auth.User
        14, // 1: datavinci.auth.RegisterUserResponse.user:type_name -&gt; datavinci.auth.User
        14, // 2: datavinci.auth.UpdateUserResponse.user:type_name -&gt; datavinci.auth.User
        14, // 3: datavinci.auth.GetUserResponse.user:type_name -&gt; datavinci.auth.User
        0,  // 4: datavinci.auth.AuthService.Login:input_type -&gt; datavinci.auth.LoginRequest
        2,  // 5: datavinci.auth.AuthService.Logout:input_type -&gt; datavinci.auth.LogoutRequest
        3,  // 6: datavinci.auth.AuthService.RefreshToken:input_type -&gt; datavinci.auth.RefreshTokenRequest
        5,  // 7: datavinci.auth.AuthService.ValidateToken:input_type -&gt; datavinci.auth.ValidateTokenRequest
        7,  // 8: datavinci.auth.AuthService.RegisterUser:input_type -&gt; datavinci.auth.RegisterUserRequest
        9,  // 9: datavinci.auth.AuthService.UpdateUser:input_type -&gt; datavinci.auth.UpdateUserRequest
        11, // 10: datavinci.auth.AuthService.DeleteUser:input_type -&gt; datavinci.auth.DeleteUserRequest
        12, // 11: datavinci.auth.AuthService.GetUser:input_type -&gt; datavinci.auth.GetUserRequest
        1,  // 12: datavinci.auth.AuthService.Login:output_type -&gt; datavinci.auth.LoginResponse
        15, // 13: datavinci.auth.AuthService.Logout:output_type -&gt; google.protobuf.Empty
        4,  // 14: datavinci.auth.AuthService.RefreshToken:output_type -&gt; datavinci.auth.RefreshTokenResponse
        6,  // 15: datavinci.auth.AuthService.ValidateToken:output_type -&gt; datavinci.auth.ValidateTokenResponse
        8,  // 16: datavinci.auth.AuthService.RegisterUser:output_type -&gt; datavinci.auth.RegisterUserResponse
        10, // 17: datavinci.auth.AuthService.UpdateUser:output_type -&gt; datavinci.auth.UpdateUserResponse
        15, // 18: datavinci.auth.AuthService.DeleteUser:output_type -&gt; google.protobuf.Empty
        13, // 19: datavinci.auth.AuthService.GetUser:output_type -&gt; datavinci.auth.GetUserResponse
        12, // [12:20] is the sub-list for method output_type
        4,  // [4:12] is the sub-list for method input_type
        4,  // [4:4] is the sub-list for extension type_name
        4,  // [4:4] is the sub-list for extension extendee
        0,  // [0:4] is the sub-list for field type_name
}

func init() <span class="cov0" title="0">{ file_auth_proto_init() }</span>
func file_auth_proto_init() <span class="cov0" title="0">{
        if File_auth_proto != nil </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov0" title="0">file_common_proto_init()
        if !protoimpl.UnsafeEnabled </span><span class="cov0" title="0">{
                file_auth_proto_msgTypes[0].Exporter = func(v any, i int) any </span><span class="cov0" title="0">{
                        switch v := v.(*LoginRequest); i </span>{
                        case 0:<span class="cov0" title="0">
                                return &amp;v.state</span>
                        case 1:<span class="cov0" title="0">
                                return &amp;v.sizeCache</span>
                        case 2:<span class="cov0" title="0">
                                return &amp;v.unknownFields</span>
                        default:<span class="cov0" title="0">
                                return nil</span>
                        }
                }
                <span class="cov0" title="0">file_auth_proto_msgTypes[1].Exporter = func(v any, i int) any </span><span class="cov0" title="0">{
                        switch v := v.(*LoginResponse); i </span>{
                        case 0:<span class="cov0" title="0">
                                return &amp;v.state</span>
                        case 1:<span class="cov0" title="0">
                                return &amp;v.sizeCache</span>
                        case 2:<span class="cov0" title="0">
                                return &amp;v.unknownFields</span>
                        default:<span class="cov0" title="0">
                                return nil</span>
                        }
                }
                <span class="cov0" title="0">file_auth_proto_msgTypes[2].Exporter = func(v any, i int) any </span><span class="cov0" title="0">{
                        switch v := v.(*LogoutRequest); i </span>{
                        case 0:<span class="cov0" title="0">
                                return &amp;v.state</span>
                        case 1:<span class="cov0" title="0">
                                return &amp;v.sizeCache</span>
                        case 2:<span class="cov0" title="0">
                                return &amp;v.unknownFields</span>
                        default:<span class="cov0" title="0">
                                return nil</span>
                        }
                }
                <span class="cov0" title="0">file_auth_proto_msgTypes[3].Exporter = func(v any, i int) any </span><span class="cov0" title="0">{
                        switch v := v.(*RefreshTokenRequest); i </span>{
                        case 0:<span class="cov0" title="0">
                                return &amp;v.state</span>
                        case 1:<span class="cov0" title="0">
                                return &amp;v.sizeCache</span>
                        case 2:<span class="cov0" title="0">
                                return &amp;v.unknownFields</span>
                        default:<span class="cov0" title="0">
                                return nil</span>
                        }
                }
                <span class="cov0" title="0">file_auth_proto_msgTypes[4].Exporter = func(v any, i int) any </span><span class="cov0" title="0">{
                        switch v := v.(*RefreshTokenResponse); i </span>{
                        case 0:<span class="cov0" title="0">
                                return &amp;v.state</span>
                        case 1:<span class="cov0" title="0">
                                return &amp;v.sizeCache</span>
                        case 2:<span class="cov0" title="0">
                                return &amp;v.unknownFields</span>
                        default:<span class="cov0" title="0">
                                return nil</span>
                        }
                }
                <span class="cov0" title="0">file_auth_proto_msgTypes[5].Exporter = func(v any, i int) any </span><span class="cov0" title="0">{
                        switch v := v.(*ValidateTokenRequest); i </span>{
                        case 0:<span class="cov0" title="0">
                                return &amp;v.state</span>
                        case 1:<span class="cov0" title="0">
                                return &amp;v.sizeCache</span>
                        case 2:<span class="cov0" title="0">
                                return &amp;v.unknownFields</span>
                        default:<span class="cov0" title="0">
                                return nil</span>
                        }
                }
                <span class="cov0" title="0">file_auth_proto_msgTypes[6].Exporter = func(v any, i int) any </span><span class="cov0" title="0">{
                        switch v := v.(*ValidateTokenResponse); i </span>{
                        case 0:<span class="cov0" title="0">
                                return &amp;v.state</span>
                        case 1:<span class="cov0" title="0">
                                return &amp;v.sizeCache</span>
                        case 2:<span class="cov0" title="0">
                                return &amp;v.unknownFields</span>
                        default:<span class="cov0" title="0">
                                return nil</span>
                        }
                }
                <span class="cov0" title="0">file_auth_proto_msgTypes[7].Exporter = func(v any, i int) any </span><span class="cov0" title="0">{
                        switch v := v.(*RegisterUserRequest); i </span>{
                        case 0:<span class="cov0" title="0">
                                return &amp;v.state</span>
                        case 1:<span class="cov0" title="0">
                                return &amp;v.sizeCache</span>
                        case 2:<span class="cov0" title="0">
                                return &amp;v.unknownFields</span>
                        default:<span class="cov0" title="0">
                                return nil</span>
                        }
                }
                <span class="cov0" title="0">file_auth_proto_msgTypes[8].Exporter = func(v any, i int) any </span><span class="cov0" title="0">{
                        switch v := v.(*RegisterUserResponse); i </span>{
                        case 0:<span class="cov0" title="0">
                                return &amp;v.state</span>
                        case 1:<span class="cov0" title="0">
                                return &amp;v.sizeCache</span>
                        case 2:<span class="cov0" title="0">
                                return &amp;v.unknownFields</span>
                        default:<span class="cov0" title="0">
                                return nil</span>
                        }
                }
                <span class="cov0" title="0">file_auth_proto_msgTypes[9].Exporter = func(v any, i int) any </span><span class="cov0" title="0">{
                        switch v := v.(*UpdateUserRequest); i </span>{
                        case 0:<span class="cov0" title="0">
                                return &amp;v.state</span>
                        case 1:<span class="cov0" title="0">
                                return &amp;v.sizeCache</span>
                        case 2:<span class="cov0" title="0">
                                return &amp;v.unknownFields</span>
                        default:<span class="cov0" title="0">
                                return nil</span>
                        }
                }
                <span class="cov0" title="0">file_auth_proto_msgTypes[10].Exporter = func(v any, i int) any </span><span class="cov0" title="0">{
                        switch v := v.(*UpdateUserResponse); i </span>{
                        case 0:<span class="cov0" title="0">
                                return &amp;v.state</span>
                        case 1:<span class="cov0" title="0">
                                return &amp;v.sizeCache</span>
                        case 2:<span class="cov0" title="0">
                                return &amp;v.unknownFields</span>
                        default:<span class="cov0" title="0">
                                return nil</span>
                        }
                }
                <span class="cov0" title="0">file_auth_proto_msgTypes[11].Exporter = func(v any, i int) any </span><span class="cov0" title="0">{
                        switch v := v.(*DeleteUserRequest); i </span>{
                        case 0:<span class="cov0" title="0">
                                return &amp;v.state</span>
                        case 1:<span class="cov0" title="0">
                                return &amp;v.sizeCache</span>
                        case 2:<span class="cov0" title="0">
                                return &amp;v.unknownFields</span>
                        default:<span class="cov0" title="0">
                                return nil</span>
                        }
                }
                <span class="cov0" title="0">file_auth_proto_msgTypes[12].Exporter = func(v any, i int) any </span><span class="cov0" title="0">{
                        switch v := v.(*GetUserRequest); i </span>{
                        case 0:<span class="cov0" title="0">
                                return &amp;v.state</span>
                        case 1:<span class="cov0" title="0">
                                return &amp;v.sizeCache</span>
                        case 2:<span class="cov0" title="0">
                                return &amp;v.unknownFields</span>
                        default:<span class="cov0" title="0">
                                return nil</span>
                        }
                }
                <span class="cov0" title="0">file_auth_proto_msgTypes[13].Exporter = func(v any, i int) any </span><span class="cov0" title="0">{
                        switch v := v.(*GetUserResponse); i </span>{
                        case 0:<span class="cov0" title="0">
                                return &amp;v.state</span>
                        case 1:<span class="cov0" title="0">
                                return &amp;v.sizeCache</span>
                        case 2:<span class="cov0" title="0">
                                return &amp;v.unknownFields</span>
                        default:<span class="cov0" title="0">
                                return nil</span>
                        }
                }
        }
        <span class="cov0" title="0">file_auth_proto_msgTypes[9].OneofWrappers = []any{}
        type x struct{}
        out := protoimpl.TypeBuilder{
                File: protoimpl.DescBuilder{
                        GoPackagePath: reflect.TypeOf(x{}).PkgPath(),
                        RawDescriptor: file_auth_proto_rawDesc,
                        NumEnums:      0,
                        NumMessages:   14,
                        NumExtensions: 0,
                        NumServices:   1,
                },
                GoTypes:           file_auth_proto_goTypes,
                DependencyIndexes: file_auth_proto_depIdxs,
                MessageInfos:      file_auth_proto_msgTypes,
        }.Build()
        File_auth_proto = out.File
        file_auth_proto_rawDesc = nil
        file_auth_proto_goTypes = nil
        file_auth_proto_depIdxs = nil</span>
}
</pre>
		
		<pre class="file" id="file45" style="display: none">// Code generated by protoc-gen-go-grpc. DO NOT EDIT.
// versions:
// - protoc-gen-go-grpc v1.4.0
// - protoc             v3.21.12
// source: auth.proto

package grpc

import (
        context "context"

        grpc "google.golang.org/grpc"
        codes "google.golang.org/grpc/codes"
        status "google.golang.org/grpc/status"
        emptypb "google.golang.org/protobuf/types/known/emptypb"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
// Requires gRPC-Go v1.62.0 or later.
const _ = grpc.SupportPackageIsVersion8

const (
        AuthService_Login_FullMethodName         = "/datavinci.auth.AuthService/Login"
        AuthService_Logout_FullMethodName        = "/datavinci.auth.AuthService/Logout"
        AuthService_RefreshToken_FullMethodName  = "/datavinci.auth.AuthService/RefreshToken"
        AuthService_ValidateToken_FullMethodName = "/datavinci.auth.AuthService/ValidateToken"
        AuthService_RegisterUser_FullMethodName  = "/datavinci.auth.AuthService/RegisterUser"
        AuthService_UpdateUser_FullMethodName    = "/datavinci.auth.AuthService/UpdateUser"
        AuthService_DeleteUser_FullMethodName    = "/datavinci.auth.AuthService/DeleteUser"
        AuthService_GetUser_FullMethodName       = "/datavinci.auth.AuthService/GetUser"
)

// AuthServiceClient is the client API for AuthService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type AuthServiceClient interface {
        // Login authenticates a user and returns a JWT token
        Login(ctx context.Context, in *LoginRequest, opts ...grpc.CallOption) (*LoginResponse, error)
        // Logout invalidates the user's current session
        Logout(ctx context.Context, in *LogoutRequest, opts ...grpc.CallOption) (*emptypb.Empty, error)
        // RefreshToken refreshes an existing JWT token
        RefreshToken(ctx context.Context, in *RefreshTokenRequest, opts ...grpc.CallOption) (*RefreshTokenResponse, error)
        // ValidateToken validates a JWT token and returns the associated user
        ValidateToken(ctx context.Context, in *ValidateTokenRequest, opts ...grpc.CallOption) (*ValidateTokenResponse, error)
        // RegisterUser registers a new user
        RegisterUser(ctx context.Context, in *RegisterUserRequest, opts ...grpc.CallOption) (*RegisterUserResponse, error)
        // UpdateUser updates an existing user's information
        UpdateUser(ctx context.Context, in *UpdateUserRequest, opts ...grpc.CallOption) (*UpdateUserResponse, error)
        // DeleteUser deletes a user from the system
        DeleteUser(ctx context.Context, in *DeleteUserRequest, opts ...grpc.CallOption) (*emptypb.Empty, error)
        // GetUser retrieves a user's information
        GetUser(ctx context.Context, in *GetUserRequest, opts ...grpc.CallOption) (*GetUserResponse, error)
}

type authServiceClient struct {
        cc grpc.ClientConnInterface
}

func NewAuthServiceClient(cc grpc.ClientConnInterface) AuthServiceClient <span class="cov0" title="0">{
        return &amp;authServiceClient{cc}
}</span>

func (c *authServiceClient) Login(ctx context.Context, in *LoginRequest, opts ...grpc.CallOption) (*LoginResponse, error) <span class="cov0" title="0">{
        cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
        out := new(LoginResponse)
        err := c.cc.Invoke(ctx, AuthService_Login_FullMethodName, in, out, cOpts...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return out, nil</span>
}

func (c *authServiceClient) Logout(ctx context.Context, in *LogoutRequest, opts ...grpc.CallOption) (*emptypb.Empty, error) <span class="cov0" title="0">{
        cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
        out := new(emptypb.Empty)
        err := c.cc.Invoke(ctx, AuthService_Logout_FullMethodName, in, out, cOpts...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return out, nil</span>
}

func (c *authServiceClient) RefreshToken(ctx context.Context, in *RefreshTokenRequest, opts ...grpc.CallOption) (*RefreshTokenResponse, error) <span class="cov0" title="0">{
        cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
        out := new(RefreshTokenResponse)
        err := c.cc.Invoke(ctx, AuthService_RefreshToken_FullMethodName, in, out, cOpts...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return out, nil</span>
}

func (c *authServiceClient) ValidateToken(ctx context.Context, in *ValidateTokenRequest, opts ...grpc.CallOption) (*ValidateTokenResponse, error) <span class="cov0" title="0">{
        cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
        out := new(ValidateTokenResponse)
        err := c.cc.Invoke(ctx, AuthService_ValidateToken_FullMethodName, in, out, cOpts...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return out, nil</span>
}

func (c *authServiceClient) RegisterUser(ctx context.Context, in *RegisterUserRequest, opts ...grpc.CallOption) (*RegisterUserResponse, error) <span class="cov0" title="0">{
        cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
        out := new(RegisterUserResponse)
        err := c.cc.Invoke(ctx, AuthService_RegisterUser_FullMethodName, in, out, cOpts...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return out, nil</span>
}

func (c *authServiceClient) UpdateUser(ctx context.Context, in *UpdateUserRequest, opts ...grpc.CallOption) (*UpdateUserResponse, error) <span class="cov0" title="0">{
        cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
        out := new(UpdateUserResponse)
        err := c.cc.Invoke(ctx, AuthService_UpdateUser_FullMethodName, in, out, cOpts...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return out, nil</span>
}

func (c *authServiceClient) DeleteUser(ctx context.Context, in *DeleteUserRequest, opts ...grpc.CallOption) (*emptypb.Empty, error) <span class="cov0" title="0">{
        cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
        out := new(emptypb.Empty)
        err := c.cc.Invoke(ctx, AuthService_DeleteUser_FullMethodName, in, out, cOpts...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return out, nil</span>
}

func (c *authServiceClient) GetUser(ctx context.Context, in *GetUserRequest, opts ...grpc.CallOption) (*GetUserResponse, error) <span class="cov0" title="0">{
        cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
        out := new(GetUserResponse)
        err := c.cc.Invoke(ctx, AuthService_GetUser_FullMethodName, in, out, cOpts...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return out, nil</span>
}

// AuthServiceServer is the server API for AuthService service.
// All implementations must embed UnimplementedAuthServiceServer
// for forward compatibility
type AuthServiceServer interface {
        // Login authenticates a user and returns a JWT token
        Login(context.Context, *LoginRequest) (*LoginResponse, error)
        // Logout invalidates the user's current session
        Logout(context.Context, *LogoutRequest) (*emptypb.Empty, error)
        // RefreshToken refreshes an existing JWT token
        RefreshToken(context.Context, *RefreshTokenRequest) (*RefreshTokenResponse, error)
        // ValidateToken validates a JWT token and returns the associated user
        ValidateToken(context.Context, *ValidateTokenRequest) (*ValidateTokenResponse, error)
        // RegisterUser registers a new user
        RegisterUser(context.Context, *RegisterUserRequest) (*RegisterUserResponse, error)
        // UpdateUser updates an existing user's information
        UpdateUser(context.Context, *UpdateUserRequest) (*UpdateUserResponse, error)
        // DeleteUser deletes a user from the system
        DeleteUser(context.Context, *DeleteUserRequest) (*emptypb.Empty, error)
        // GetUser retrieves a user's information
        GetUser(context.Context, *GetUserRequest) (*GetUserResponse, error)
        mustEmbedUnimplementedAuthServiceServer()
}

// UnimplementedAuthServiceServer must be embedded to have forward compatible implementations.
type UnimplementedAuthServiceServer struct {
}

func (UnimplementedAuthServiceServer) Login(context.Context, *LoginRequest) (*LoginResponse, error) <span class="cov0" title="0">{
        return nil, status.Errorf(codes.Unimplemented, "method Login not implemented")
}</span>
func (UnimplementedAuthServiceServer) Logout(context.Context, *LogoutRequest) (*emptypb.Empty, error) <span class="cov0" title="0">{
        return nil, status.Errorf(codes.Unimplemented, "method Logout not implemented")
}</span>
func (UnimplementedAuthServiceServer) RefreshToken(context.Context, *RefreshTokenRequest) (*RefreshTokenResponse, error) <span class="cov0" title="0">{
        return nil, status.Errorf(codes.Unimplemented, "method RefreshToken not implemented")
}</span>
func (UnimplementedAuthServiceServer) ValidateToken(context.Context, *ValidateTokenRequest) (*ValidateTokenResponse, error) <span class="cov0" title="0">{
        return nil, status.Errorf(codes.Unimplemented, "method ValidateToken not implemented")
}</span>
func (UnimplementedAuthServiceServer) RegisterUser(context.Context, *RegisterUserRequest) (*RegisterUserResponse, error) <span class="cov0" title="0">{
        return nil, status.Errorf(codes.Unimplemented, "method RegisterUser not implemented")
}</span>
func (UnimplementedAuthServiceServer) UpdateUser(context.Context, *UpdateUserRequest) (*UpdateUserResponse, error) <span class="cov0" title="0">{
        return nil, status.Errorf(codes.Unimplemented, "method UpdateUser not implemented")
}</span>
func (UnimplementedAuthServiceServer) DeleteUser(context.Context, *DeleteUserRequest) (*emptypb.Empty, error) <span class="cov0" title="0">{
        return nil, status.Errorf(codes.Unimplemented, "method DeleteUser not implemented")
}</span>
func (UnimplementedAuthServiceServer) GetUser(context.Context, *GetUserRequest) (*GetUserResponse, error) <span class="cov0" title="0">{
        return nil, status.Errorf(codes.Unimplemented, "method GetUser not implemented")
}</span>
func (UnimplementedAuthServiceServer) mustEmbedUnimplementedAuthServiceServer() {<span class="cov0" title="0">}</span>

// UnsafeAuthServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to AuthServiceServer will
// result in compilation errors.
type UnsafeAuthServiceServer interface {
        mustEmbedUnimplementedAuthServiceServer()
}

func RegisterAuthServiceServer(s grpc.ServiceRegistrar, srv AuthServiceServer) <span class="cov0" title="0">{
        s.RegisterService(&amp;AuthService_ServiceDesc, srv)
}</span>

func _AuthService_Login_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) <span class="cov0" title="0">{
        in := new(LoginRequest)
        if err := dec(in); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">if interceptor == nil </span><span class="cov0" title="0">{
                return srv.(AuthServiceServer).Login(ctx, in)
        }</span>
        <span class="cov0" title="0">info := &amp;grpc.UnaryServerInfo{
                Server:     srv,
                FullMethod: AuthService_Login_FullMethodName,
        }
        handler := func(ctx context.Context, req interface{}) (interface{}, error) </span><span class="cov0" title="0">{
                return srv.(AuthServiceServer).Login(ctx, req.(*LoginRequest))
        }</span>
        <span class="cov0" title="0">return interceptor(ctx, in, info, handler)</span>
}

func _AuthService_Logout_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) <span class="cov0" title="0">{
        in := new(LogoutRequest)
        if err := dec(in); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">if interceptor == nil </span><span class="cov0" title="0">{
                return srv.(AuthServiceServer).Logout(ctx, in)
        }</span>
        <span class="cov0" title="0">info := &amp;grpc.UnaryServerInfo{
                Server:     srv,
                FullMethod: AuthService_Logout_FullMethodName,
        }
        handler := func(ctx context.Context, req interface{}) (interface{}, error) </span><span class="cov0" title="0">{
                return srv.(AuthServiceServer).Logout(ctx, req.(*LogoutRequest))
        }</span>
        <span class="cov0" title="0">return interceptor(ctx, in, info, handler)</span>
}

func _AuthService_RefreshToken_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) <span class="cov0" title="0">{
        in := new(RefreshTokenRequest)
        if err := dec(in); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">if interceptor == nil </span><span class="cov0" title="0">{
                return srv.(AuthServiceServer).RefreshToken(ctx, in)
        }</span>
        <span class="cov0" title="0">info := &amp;grpc.UnaryServerInfo{
                Server:     srv,
                FullMethod: AuthService_RefreshToken_FullMethodName,
        }
        handler := func(ctx context.Context, req interface{}) (interface{}, error) </span><span class="cov0" title="0">{
                return srv.(AuthServiceServer).RefreshToken(ctx, req.(*RefreshTokenRequest))
        }</span>
        <span class="cov0" title="0">return interceptor(ctx, in, info, handler)</span>
}

func _AuthService_ValidateToken_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) <span class="cov0" title="0">{
        in := new(ValidateTokenRequest)
        if err := dec(in); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">if interceptor == nil </span><span class="cov0" title="0">{
                return srv.(AuthServiceServer).ValidateToken(ctx, in)
        }</span>
        <span class="cov0" title="0">info := &amp;grpc.UnaryServerInfo{
                Server:     srv,
                FullMethod: AuthService_ValidateToken_FullMethodName,
        }
        handler := func(ctx context.Context, req interface{}) (interface{}, error) </span><span class="cov0" title="0">{
                return srv.(AuthServiceServer).ValidateToken(ctx, req.(*ValidateTokenRequest))
        }</span>
        <span class="cov0" title="0">return interceptor(ctx, in, info, handler)</span>
}

func _AuthService_RegisterUser_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) <span class="cov0" title="0">{
        in := new(RegisterUserRequest)
        if err := dec(in); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">if interceptor == nil </span><span class="cov0" title="0">{
                return srv.(AuthServiceServer).RegisterUser(ctx, in)
        }</span>
        <span class="cov0" title="0">info := &amp;grpc.UnaryServerInfo{
                Server:     srv,
                FullMethod: AuthService_RegisterUser_FullMethodName,
        }
        handler := func(ctx context.Context, req interface{}) (interface{}, error) </span><span class="cov0" title="0">{
                return srv.(AuthServiceServer).RegisterUser(ctx, req.(*RegisterUserRequest))
        }</span>
        <span class="cov0" title="0">return interceptor(ctx, in, info, handler)</span>
}

func _AuthService_UpdateUser_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) <span class="cov0" title="0">{
        in := new(UpdateUserRequest)
        if err := dec(in); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">if interceptor == nil </span><span class="cov0" title="0">{
                return srv.(AuthServiceServer).UpdateUser(ctx, in)
        }</span>
        <span class="cov0" title="0">info := &amp;grpc.UnaryServerInfo{
                Server:     srv,
                FullMethod: AuthService_UpdateUser_FullMethodName,
        }
        handler := func(ctx context.Context, req interface{}) (interface{}, error) </span><span class="cov0" title="0">{
                return srv.(AuthServiceServer).UpdateUser(ctx, req.(*UpdateUserRequest))
        }</span>
        <span class="cov0" title="0">return interceptor(ctx, in, info, handler)</span>
}

func _AuthService_DeleteUser_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) <span class="cov0" title="0">{
        in := new(DeleteUserRequest)
        if err := dec(in); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">if interceptor == nil </span><span class="cov0" title="0">{
                return srv.(AuthServiceServer).DeleteUser(ctx, in)
        }</span>
        <span class="cov0" title="0">info := &amp;grpc.UnaryServerInfo{
                Server:     srv,
                FullMethod: AuthService_DeleteUser_FullMethodName,
        }
        handler := func(ctx context.Context, req interface{}) (interface{}, error) </span><span class="cov0" title="0">{
                return srv.(AuthServiceServer).DeleteUser(ctx, req.(*DeleteUserRequest))
        }</span>
        <span class="cov0" title="0">return interceptor(ctx, in, info, handler)</span>
}

func _AuthService_GetUser_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) <span class="cov0" title="0">{
        in := new(GetUserRequest)
        if err := dec(in); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">if interceptor == nil </span><span class="cov0" title="0">{
                return srv.(AuthServiceServer).GetUser(ctx, in)
        }</span>
        <span class="cov0" title="0">info := &amp;grpc.UnaryServerInfo{
                Server:     srv,
                FullMethod: AuthService_GetUser_FullMethodName,
        }
        handler := func(ctx context.Context, req interface{}) (interface{}, error) </span><span class="cov0" title="0">{
                return srv.(AuthServiceServer).GetUser(ctx, req.(*GetUserRequest))
        }</span>
        <span class="cov0" title="0">return interceptor(ctx, in, info, handler)</span>
}

// AuthService_ServiceDesc is the grpc.ServiceDesc for AuthService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var AuthService_ServiceDesc = grpc.ServiceDesc{
        ServiceName: "datavinci.auth.AuthService",
        HandlerType: (*AuthServiceServer)(nil),
        Methods: []grpc.MethodDesc{
                {
                        MethodName: "Login",
                        Handler:    _AuthService_Login_Handler,
                },
                {
                        MethodName: "Logout",
                        Handler:    _AuthService_Logout_Handler,
                },
                {
                        MethodName: "RefreshToken",
                        Handler:    _AuthService_RefreshToken_Handler,
                },
                {
                        MethodName: "ValidateToken",
                        Handler:    _AuthService_ValidateToken_Handler,
                },
                {
                        MethodName: "RegisterUser",
                        Handler:    _AuthService_RegisterUser_Handler,
                },
                {
                        MethodName: "UpdateUser",
                        Handler:    _AuthService_UpdateUser_Handler,
                },
                {
                        MethodName: "DeleteUser",
                        Handler:    _AuthService_DeleteUser_Handler,
                },
                {
                        MethodName: "GetUser",
                        Handler:    _AuthService_GetUser_Handler,
                },
        },
        Streams:  []grpc.StreamDesc{},
        Metadata: "auth.proto",
}
</pre>
		
		<pre class="file" id="file46" style="display: none">// Code generated by protoc-gen-go. DO NOT EDIT.
// versions:
//         protoc-gen-go v1.34.2
//         protoc        v3.21.12
// source: authorization.proto

package grpc

import (
        reflect "reflect"
        sync "sync"

        protoreflect "google.golang.org/protobuf/reflect/protoreflect"
        protoimpl "google.golang.org/protobuf/runtime/protoimpl"
        emptypb "google.golang.org/protobuf/types/known/emptypb"
)

const (
        // Verify that this generated code is sufficiently up-to-date.
        _ = protoimpl.EnforceVersion(20 - protoimpl.MinVersion)
        // Verify that runtime/protoimpl is sufficiently up-to-date.
        _ = protoimpl.EnforceVersion(protoimpl.MaxVersion - 20)
)

type CheckPermissionRequest struct {
        state         protoimpl.MessageState
        sizeCache     protoimpl.SizeCache
        unknownFields protoimpl.UnknownFields

        UserId     string      `protobuf:"bytes,1,opt,name=user_id,json=userId,proto3" json:"user_id,omitempty"`
        Permission *Permission `protobuf:"bytes,2,opt,name=permission,proto3" json:"permission,omitempty"`
}

func (x *CheckPermissionRequest) Reset() <span class="cov0" title="0">{
        *x = CheckPermissionRequest{}
        if protoimpl.UnsafeEnabled </span><span class="cov0" title="0">{
                mi := &amp;file_authorization_proto_msgTypes[0]
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                ms.StoreMessageInfo(mi)
        }</span>
}

func (x *CheckPermissionRequest) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*CheckPermissionRequest) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *CheckPermissionRequest) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_authorization_proto_msgTypes[0]
        if protoimpl.UnsafeEnabled &amp;&amp; x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use CheckPermissionRequest.ProtoReflect.Descriptor instead.
func (*CheckPermissionRequest) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_authorization_proto_rawDescGZIP(), []int{0}
}</span>

func (x *CheckPermissionRequest) GetUserId() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.UserId
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *CheckPermissionRequest) GetPermission() *Permission <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Permission
        }</span>
        <span class="cov0" title="0">return nil</span>
}

type CheckPermissionResponse struct {
        state         protoimpl.MessageState
        sizeCache     protoimpl.SizeCache
        unknownFields protoimpl.UnknownFields

        HasPermission bool `protobuf:"varint,1,opt,name=has_permission,json=hasPermission,proto3" json:"has_permission,omitempty"`
}

func (x *CheckPermissionResponse) Reset() <span class="cov0" title="0">{
        *x = CheckPermissionResponse{}
        if protoimpl.UnsafeEnabled </span><span class="cov0" title="0">{
                mi := &amp;file_authorization_proto_msgTypes[1]
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                ms.StoreMessageInfo(mi)
        }</span>
}

func (x *CheckPermissionResponse) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*CheckPermissionResponse) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *CheckPermissionResponse) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_authorization_proto_msgTypes[1]
        if protoimpl.UnsafeEnabled &amp;&amp; x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use CheckPermissionResponse.ProtoReflect.Descriptor instead.
func (*CheckPermissionResponse) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_authorization_proto_rawDescGZIP(), []int{1}
}</span>

func (x *CheckPermissionResponse) GetHasPermission() bool <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.HasPermission
        }</span>
        <span class="cov0" title="0">return false</span>
}

type GetUserRolesRequest struct {
        state         protoimpl.MessageState
        sizeCache     protoimpl.SizeCache
        unknownFields protoimpl.UnknownFields

        UserId string `protobuf:"bytes,1,opt,name=user_id,json=userId,proto3" json:"user_id,omitempty"`
}

func (x *GetUserRolesRequest) Reset() <span class="cov0" title="0">{
        *x = GetUserRolesRequest{}
        if protoimpl.UnsafeEnabled </span><span class="cov0" title="0">{
                mi := &amp;file_authorization_proto_msgTypes[2]
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                ms.StoreMessageInfo(mi)
        }</span>
}

func (x *GetUserRolesRequest) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*GetUserRolesRequest) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *GetUserRolesRequest) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_authorization_proto_msgTypes[2]
        if protoimpl.UnsafeEnabled &amp;&amp; x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use GetUserRolesRequest.ProtoReflect.Descriptor instead.
func (*GetUserRolesRequest) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_authorization_proto_rawDescGZIP(), []int{2}
}</span>

func (x *GetUserRolesRequest) GetUserId() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.UserId
        }</span>
        <span class="cov0" title="0">return ""</span>
}

type GetUserRolesResponse struct {
        state         protoimpl.MessageState
        sizeCache     protoimpl.SizeCache
        unknownFields protoimpl.UnknownFields

        Roles []*Role `protobuf:"bytes,1,rep,name=roles,proto3" json:"roles,omitempty"`
}

func (x *GetUserRolesResponse) Reset() <span class="cov0" title="0">{
        *x = GetUserRolesResponse{}
        if protoimpl.UnsafeEnabled </span><span class="cov0" title="0">{
                mi := &amp;file_authorization_proto_msgTypes[3]
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                ms.StoreMessageInfo(mi)
        }</span>
}

func (x *GetUserRolesResponse) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*GetUserRolesResponse) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *GetUserRolesResponse) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_authorization_proto_msgTypes[3]
        if protoimpl.UnsafeEnabled &amp;&amp; x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use GetUserRolesResponse.ProtoReflect.Descriptor instead.
func (*GetUserRolesResponse) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_authorization_proto_rawDescGZIP(), []int{3}
}</span>

func (x *GetUserRolesResponse) GetRoles() []*Role <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Roles
        }</span>
        <span class="cov0" title="0">return nil</span>
}

type AssignRoleToUserRequest struct {
        state         protoimpl.MessageState
        sizeCache     protoimpl.SizeCache
        unknownFields protoimpl.UnknownFields

        UserId string `protobuf:"bytes,1,opt,name=user_id,json=userId,proto3" json:"user_id,omitempty"`
        RoleId string `protobuf:"bytes,2,opt,name=role_id,json=roleId,proto3" json:"role_id,omitempty"`
}

func (x *AssignRoleToUserRequest) Reset() <span class="cov0" title="0">{
        *x = AssignRoleToUserRequest{}
        if protoimpl.UnsafeEnabled </span><span class="cov0" title="0">{
                mi := &amp;file_authorization_proto_msgTypes[4]
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                ms.StoreMessageInfo(mi)
        }</span>
}

func (x *AssignRoleToUserRequest) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*AssignRoleToUserRequest) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *AssignRoleToUserRequest) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_authorization_proto_msgTypes[4]
        if protoimpl.UnsafeEnabled &amp;&amp; x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use AssignRoleToUserRequest.ProtoReflect.Descriptor instead.
func (*AssignRoleToUserRequest) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_authorization_proto_rawDescGZIP(), []int{4}
}</span>

func (x *AssignRoleToUserRequest) GetUserId() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.UserId
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *AssignRoleToUserRequest) GetRoleId() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.RoleId
        }</span>
        <span class="cov0" title="0">return ""</span>
}

type RemoveRoleFromUserRequest struct {
        state         protoimpl.MessageState
        sizeCache     protoimpl.SizeCache
        unknownFields protoimpl.UnknownFields

        UserId string `protobuf:"bytes,1,opt,name=user_id,json=userId,proto3" json:"user_id,omitempty"`
        RoleId string `protobuf:"bytes,2,opt,name=role_id,json=roleId,proto3" json:"role_id,omitempty"`
}

func (x *RemoveRoleFromUserRequest) Reset() <span class="cov0" title="0">{
        *x = RemoveRoleFromUserRequest{}
        if protoimpl.UnsafeEnabled </span><span class="cov0" title="0">{
                mi := &amp;file_authorization_proto_msgTypes[5]
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                ms.StoreMessageInfo(mi)
        }</span>
}

func (x *RemoveRoleFromUserRequest) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*RemoveRoleFromUserRequest) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *RemoveRoleFromUserRequest) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_authorization_proto_msgTypes[5]
        if protoimpl.UnsafeEnabled &amp;&amp; x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use RemoveRoleFromUserRequest.ProtoReflect.Descriptor instead.
func (*RemoveRoleFromUserRequest) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_authorization_proto_rawDescGZIP(), []int{5}
}</span>

func (x *RemoveRoleFromUserRequest) GetUserId() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.UserId
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *RemoveRoleFromUserRequest) GetRoleId() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.RoleId
        }</span>
        <span class="cov0" title="0">return ""</span>
}

type CreateRoleRequest struct {
        state         protoimpl.MessageState
        sizeCache     protoimpl.SizeCache
        unknownFields protoimpl.UnknownFields

        Name        string        `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
        Permissions []*Permission `protobuf:"bytes,2,rep,name=permissions,proto3" json:"permissions,omitempty"`
}

func (x *CreateRoleRequest) Reset() <span class="cov0" title="0">{
        *x = CreateRoleRequest{}
        if protoimpl.UnsafeEnabled </span><span class="cov0" title="0">{
                mi := &amp;file_authorization_proto_msgTypes[6]
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                ms.StoreMessageInfo(mi)
        }</span>
}

func (x *CreateRoleRequest) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*CreateRoleRequest) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *CreateRoleRequest) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_authorization_proto_msgTypes[6]
        if protoimpl.UnsafeEnabled &amp;&amp; x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use CreateRoleRequest.ProtoReflect.Descriptor instead.
func (*CreateRoleRequest) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_authorization_proto_rawDescGZIP(), []int{6}
}</span>

func (x *CreateRoleRequest) GetName() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Name
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *CreateRoleRequest) GetPermissions() []*Permission <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Permissions
        }</span>
        <span class="cov0" title="0">return nil</span>
}

type CreateRoleResponse struct {
        state         protoimpl.MessageState
        sizeCache     protoimpl.SizeCache
        unknownFields protoimpl.UnknownFields

        Role *Role `protobuf:"bytes,1,opt,name=role,proto3" json:"role,omitempty"`
}

func (x *CreateRoleResponse) Reset() <span class="cov0" title="0">{
        *x = CreateRoleResponse{}
        if protoimpl.UnsafeEnabled </span><span class="cov0" title="0">{
                mi := &amp;file_authorization_proto_msgTypes[7]
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                ms.StoreMessageInfo(mi)
        }</span>
}

func (x *CreateRoleResponse) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*CreateRoleResponse) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *CreateRoleResponse) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_authorization_proto_msgTypes[7]
        if protoimpl.UnsafeEnabled &amp;&amp; x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use CreateRoleResponse.ProtoReflect.Descriptor instead.
func (*CreateRoleResponse) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_authorization_proto_rawDescGZIP(), []int{7}
}</span>

func (x *CreateRoleResponse) GetRole() *Role <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Role
        }</span>
        <span class="cov0" title="0">return nil</span>
}

type UpdateRoleRequest struct {
        state         protoimpl.MessageState
        sizeCache     protoimpl.SizeCache
        unknownFields protoimpl.UnknownFields

        RoleId      string        `protobuf:"bytes,1,opt,name=role_id,json=roleId,proto3" json:"role_id,omitempty"`
        Name        *string       `protobuf:"bytes,2,opt,name=name,proto3,oneof" json:"name,omitempty"`
        Permissions []*Permission `protobuf:"bytes,3,rep,name=permissions,proto3" json:"permissions,omitempty"`
}

func (x *UpdateRoleRequest) Reset() <span class="cov0" title="0">{
        *x = UpdateRoleRequest{}
        if protoimpl.UnsafeEnabled </span><span class="cov0" title="0">{
                mi := &amp;file_authorization_proto_msgTypes[8]
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                ms.StoreMessageInfo(mi)
        }</span>
}

func (x *UpdateRoleRequest) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*UpdateRoleRequest) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *UpdateRoleRequest) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_authorization_proto_msgTypes[8]
        if protoimpl.UnsafeEnabled &amp;&amp; x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use UpdateRoleRequest.ProtoReflect.Descriptor instead.
func (*UpdateRoleRequest) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_authorization_proto_rawDescGZIP(), []int{8}
}</span>

func (x *UpdateRoleRequest) GetRoleId() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.RoleId
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *UpdateRoleRequest) GetName() string <span class="cov0" title="0">{
        if x != nil &amp;&amp; x.Name != nil </span><span class="cov0" title="0">{
                return *x.Name
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *UpdateRoleRequest) GetPermissions() []*Permission <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Permissions
        }</span>
        <span class="cov0" title="0">return nil</span>
}

type UpdateRoleResponse struct {
        state         protoimpl.MessageState
        sizeCache     protoimpl.SizeCache
        unknownFields protoimpl.UnknownFields

        Role *Role `protobuf:"bytes,1,opt,name=role,proto3" json:"role,omitempty"`
}

func (x *UpdateRoleResponse) Reset() <span class="cov0" title="0">{
        *x = UpdateRoleResponse{}
        if protoimpl.UnsafeEnabled </span><span class="cov0" title="0">{
                mi := &amp;file_authorization_proto_msgTypes[9]
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                ms.StoreMessageInfo(mi)
        }</span>
}

func (x *UpdateRoleResponse) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*UpdateRoleResponse) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *UpdateRoleResponse) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_authorization_proto_msgTypes[9]
        if protoimpl.UnsafeEnabled &amp;&amp; x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use UpdateRoleResponse.ProtoReflect.Descriptor instead.
func (*UpdateRoleResponse) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_authorization_proto_rawDescGZIP(), []int{9}
}</span>

func (x *UpdateRoleResponse) GetRole() *Role <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Role
        }</span>
        <span class="cov0" title="0">return nil</span>
}

type DeleteRoleRequest struct {
        state         protoimpl.MessageState
        sizeCache     protoimpl.SizeCache
        unknownFields protoimpl.UnknownFields

        RoleId string `protobuf:"bytes,1,opt,name=role_id,json=roleId,proto3" json:"role_id,omitempty"`
}

func (x *DeleteRoleRequest) Reset() <span class="cov0" title="0">{
        *x = DeleteRoleRequest{}
        if protoimpl.UnsafeEnabled </span><span class="cov0" title="0">{
                mi := &amp;file_authorization_proto_msgTypes[10]
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                ms.StoreMessageInfo(mi)
        }</span>
}

func (x *DeleteRoleRequest) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*DeleteRoleRequest) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *DeleteRoleRequest) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_authorization_proto_msgTypes[10]
        if protoimpl.UnsafeEnabled &amp;&amp; x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use DeleteRoleRequest.ProtoReflect.Descriptor instead.
func (*DeleteRoleRequest) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_authorization_proto_rawDescGZIP(), []int{10}
}</span>

func (x *DeleteRoleRequest) GetRoleId() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.RoleId
        }</span>
        <span class="cov0" title="0">return ""</span>
}

type GetRoleRequest struct {
        state         protoimpl.MessageState
        sizeCache     protoimpl.SizeCache
        unknownFields protoimpl.UnknownFields

        RoleId string `protobuf:"bytes,1,opt,name=role_id,json=roleId,proto3" json:"role_id,omitempty"`
}

func (x *GetRoleRequest) Reset() <span class="cov0" title="0">{
        *x = GetRoleRequest{}
        if protoimpl.UnsafeEnabled </span><span class="cov0" title="0">{
                mi := &amp;file_authorization_proto_msgTypes[11]
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                ms.StoreMessageInfo(mi)
        }</span>
}

func (x *GetRoleRequest) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*GetRoleRequest) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *GetRoleRequest) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_authorization_proto_msgTypes[11]
        if protoimpl.UnsafeEnabled &amp;&amp; x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use GetRoleRequest.ProtoReflect.Descriptor instead.
func (*GetRoleRequest) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_authorization_proto_rawDescGZIP(), []int{11}
}</span>

func (x *GetRoleRequest) GetRoleId() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.RoleId
        }</span>
        <span class="cov0" title="0">return ""</span>
}

type GetRoleResponse struct {
        state         protoimpl.MessageState
        sizeCache     protoimpl.SizeCache
        unknownFields protoimpl.UnknownFields

        Role *Role `protobuf:"bytes,1,opt,name=role,proto3" json:"role,omitempty"`
}

func (x *GetRoleResponse) Reset() <span class="cov0" title="0">{
        *x = GetRoleResponse{}
        if protoimpl.UnsafeEnabled </span><span class="cov0" title="0">{
                mi := &amp;file_authorization_proto_msgTypes[12]
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                ms.StoreMessageInfo(mi)
        }</span>
}

func (x *GetRoleResponse) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*GetRoleResponse) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *GetRoleResponse) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_authorization_proto_msgTypes[12]
        if protoimpl.UnsafeEnabled &amp;&amp; x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use GetRoleResponse.ProtoReflect.Descriptor instead.
func (*GetRoleResponse) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_authorization_proto_rawDescGZIP(), []int{12}
}</span>

func (x *GetRoleResponse) GetRole() *Role <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Role
        }</span>
        <span class="cov0" title="0">return nil</span>
}

type ListRolesRequest struct {
        state         protoimpl.MessageState
        sizeCache     protoimpl.SizeCache
        unknownFields protoimpl.UnknownFields

        PageSize  int32  `protobuf:"varint,1,opt,name=page_size,json=pageSize,proto3" json:"page_size,omitempty"`
        PageToken string `protobuf:"bytes,2,opt,name=page_token,json=pageToken,proto3" json:"page_token,omitempty"`
}

func (x *ListRolesRequest) Reset() <span class="cov0" title="0">{
        *x = ListRolesRequest{}
        if protoimpl.UnsafeEnabled </span><span class="cov0" title="0">{
                mi := &amp;file_authorization_proto_msgTypes[13]
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                ms.StoreMessageInfo(mi)
        }</span>
}

func (x *ListRolesRequest) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*ListRolesRequest) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *ListRolesRequest) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_authorization_proto_msgTypes[13]
        if protoimpl.UnsafeEnabled &amp;&amp; x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use ListRolesRequest.ProtoReflect.Descriptor instead.
func (*ListRolesRequest) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_authorization_proto_rawDescGZIP(), []int{13}
}</span>

func (x *ListRolesRequest) GetPageSize() int32 <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.PageSize
        }</span>
        <span class="cov0" title="0">return 0</span>
}

func (x *ListRolesRequest) GetPageToken() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.PageToken
        }</span>
        <span class="cov0" title="0">return ""</span>
}

type ListRolesResponse struct {
        state         protoimpl.MessageState
        sizeCache     protoimpl.SizeCache
        unknownFields protoimpl.UnknownFields

        Roles         []*Role `protobuf:"bytes,1,rep,name=roles,proto3" json:"roles,omitempty"`
        NextPageToken string  `protobuf:"bytes,2,opt,name=next_page_token,json=nextPageToken,proto3" json:"next_page_token,omitempty"`
}

func (x *ListRolesResponse) Reset() <span class="cov0" title="0">{
        *x = ListRolesResponse{}
        if protoimpl.UnsafeEnabled </span><span class="cov0" title="0">{
                mi := &amp;file_authorization_proto_msgTypes[14]
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                ms.StoreMessageInfo(mi)
        }</span>
}

func (x *ListRolesResponse) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*ListRolesResponse) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *ListRolesResponse) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_authorization_proto_msgTypes[14]
        if protoimpl.UnsafeEnabled &amp;&amp; x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use ListRolesResponse.ProtoReflect.Descriptor instead.
func (*ListRolesResponse) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_authorization_proto_rawDescGZIP(), []int{14}
}</span>

func (x *ListRolesResponse) GetRoles() []*Role <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Roles
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (x *ListRolesResponse) GetNextPageToken() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.NextPageToken
        }</span>
        <span class="cov0" title="0">return ""</span>
}

type AddPermissionToRoleRequest struct {
        state         protoimpl.MessageState
        sizeCache     protoimpl.SizeCache
        unknownFields protoimpl.UnknownFields

        RoleId     string      `protobuf:"bytes,1,opt,name=role_id,json=roleId,proto3" json:"role_id,omitempty"`
        Permission *Permission `protobuf:"bytes,2,opt,name=permission,proto3" json:"permission,omitempty"`
}

func (x *AddPermissionToRoleRequest) Reset() <span class="cov0" title="0">{
        *x = AddPermissionToRoleRequest{}
        if protoimpl.UnsafeEnabled </span><span class="cov0" title="0">{
                mi := &amp;file_authorization_proto_msgTypes[15]
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                ms.StoreMessageInfo(mi)
        }</span>
}

func (x *AddPermissionToRoleRequest) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*AddPermissionToRoleRequest) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *AddPermissionToRoleRequest) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_authorization_proto_msgTypes[15]
        if protoimpl.UnsafeEnabled &amp;&amp; x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use AddPermissionToRoleRequest.ProtoReflect.Descriptor instead.
func (*AddPermissionToRoleRequest) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_authorization_proto_rawDescGZIP(), []int{15}
}</span>

func (x *AddPermissionToRoleRequest) GetRoleId() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.RoleId
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *AddPermissionToRoleRequest) GetPermission() *Permission <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Permission
        }</span>
        <span class="cov0" title="0">return nil</span>
}

type RemovePermissionFromRoleRequest struct {
        state         protoimpl.MessageState
        sizeCache     protoimpl.SizeCache
        unknownFields protoimpl.UnknownFields

        RoleId     string      `protobuf:"bytes,1,opt,name=role_id,json=roleId,proto3" json:"role_id,omitempty"`
        Permission *Permission `protobuf:"bytes,2,opt,name=permission,proto3" json:"permission,omitempty"`
}

func (x *RemovePermissionFromRoleRequest) Reset() <span class="cov0" title="0">{
        *x = RemovePermissionFromRoleRequest{}
        if protoimpl.UnsafeEnabled </span><span class="cov0" title="0">{
                mi := &amp;file_authorization_proto_msgTypes[16]
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                ms.StoreMessageInfo(mi)
        }</span>
}

func (x *RemovePermissionFromRoleRequest) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*RemovePermissionFromRoleRequest) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *RemovePermissionFromRoleRequest) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_authorization_proto_msgTypes[16]
        if protoimpl.UnsafeEnabled &amp;&amp; x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use RemovePermissionFromRoleRequest.ProtoReflect.Descriptor instead.
func (*RemovePermissionFromRoleRequest) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_authorization_proto_rawDescGZIP(), []int{16}
}</span>

func (x *RemovePermissionFromRoleRequest) GetRoleId() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.RoleId
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *RemovePermissionFromRoleRequest) GetPermission() *Permission <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Permission
        }</span>
        <span class="cov0" title="0">return nil</span>
}

var File_authorization_proto protoreflect.FileDescriptor

var file_authorization_proto_rawDesc = []byte{
        0x0a, 0x13, 0x61, 0x75, 0x74, 0x68, 0x6f, 0x72, 0x69, 0x7a, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x2e,
        0x70, 0x72, 0x6f, 0x74, 0x6f, 0x12, 0x0e, 0x64, 0x61, 0x74, 0x61, 0x76, 0x69, 0x6e, 0x63, 0x69,
        0x2e, 0x61, 0x75, 0x74, 0x68, 0x1a, 0x1b, 0x67, 0x6f, 0x6f, 0x67, 0x6c, 0x65, 0x2f, 0x70, 0x72,
        0x6f, 0x74, 0x6f, 0x62, 0x75, 0x66, 0x2f, 0x65, 0x6d, 0x70, 0x74, 0x79, 0x2e, 0x70, 0x72, 0x6f,
        0x74, 0x6f, 0x1a, 0x0c, 0x63, 0x6f, 0x6d, 0x6d, 0x6f, 0x6e, 0x2e, 0x70, 0x72, 0x6f, 0x74, 0x6f,
        0x22, 0x6d, 0x0a, 0x16, 0x43, 0x68, 0x65, 0x63, 0x6b, 0x50, 0x65, 0x72, 0x6d, 0x69, 0x73, 0x73,
        0x69, 0x6f, 0x6e, 0x52, 0x65, 0x71, 0x75, 0x65, 0x73, 0x74, 0x12, 0x17, 0x0a, 0x07, 0x75, 0x73,
        0x65, 0x72, 0x5f, 0x69, 0x64, 0x18, 0x01, 0x20, 0x01, 0x28, 0x09, 0x52, 0x06, 0x75, 0x73, 0x65,
        0x72, 0x49, 0x64, 0x12, 0x3a, 0x0a, 0x0a, 0x70, 0x65, 0x72, 0x6d, 0x69, 0x73, 0x73, 0x69, 0x6f,
        0x6e, 0x18, 0x02, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x1a, 0x2e, 0x64, 0x61, 0x74, 0x61, 0x76, 0x69,
        0x6e, 0x63, 0x69, 0x2e, 0x61, 0x75, 0x74, 0x68, 0x2e, 0x50, 0x65, 0x72, 0x6d, 0x69, 0x73, 0x73,
        0x69, 0x6f, 0x6e, 0x52, 0x0a, 0x70, 0x65, 0x72, 0x6d, 0x69, 0x73, 0x73, 0x69, 0x6f, 0x6e, 0x22,
        0x40, 0x0a, 0x17, 0x43, 0x68, 0x65, 0x63, 0x6b, 0x50, 0x65, 0x72, 0x6d, 0x69, 0x73, 0x73, 0x69,
        0x6f, 0x6e, 0x52, 0x65, 0x73, 0x70, 0x6f, 0x6e, 0x73, 0x65, 0x12, 0x25, 0x0a, 0x0e, 0x68, 0x61,
        0x73, 0x5f, 0x70, 0x65, 0x72, 0x6d, 0x69, 0x73, 0x73, 0x69, 0x6f, 0x6e, 0x18, 0x01, 0x20, 0x01,
        0x28, 0x08, 0x52, 0x0d, 0x68, 0x61, 0x73, 0x50, 0x65, 0x72, 0x6d, 0x69, 0x73, 0x73, 0x69, 0x6f,
        0x6e, 0x22, 0x2e, 0x0a, 0x13, 0x47, 0x65, 0x74, 0x55, 0x73, 0x65, 0x72, 0x52, 0x6f, 0x6c, 0x65,
        0x73, 0x52, 0x65, 0x71, 0x75, 0x65, 0x73, 0x74, 0x12, 0x17, 0x0a, 0x07, 0x75, 0x73, 0x65, 0x72,
        0x5f, 0x69, 0x64, 0x18, 0x01, 0x20, 0x01, 0x28, 0x09, 0x52, 0x06, 0x75, 0x73, 0x65, 0x72, 0x49,
        0x64, 0x22, 0x42, 0x0a, 0x14, 0x47, 0x65, 0x74, 0x55, 0x73, 0x65, 0x72, 0x52, 0x6f, 0x6c, 0x65,
        0x73, 0x52, 0x65, 0x73, 0x70, 0x6f, 0x6e, 0x73, 0x65, 0x12, 0x2a, 0x0a, 0x05, 0x72, 0x6f, 0x6c,
        0x65, 0x73, 0x18, 0x01, 0x20, 0x03, 0x28, 0x0b, 0x32, 0x14, 0x2e, 0x64, 0x61, 0x74, 0x61, 0x76,
        0x69, 0x6e, 0x63, 0x69, 0x2e, 0x61, 0x75, 0x74, 0x68, 0x2e, 0x52, 0x6f, 0x6c, 0x65, 0x52, 0x05,
        0x72, 0x6f, 0x6c, 0x65, 0x73, 0x22, 0x4b, 0x0a, 0x17, 0x41, 0x73, 0x73, 0x69, 0x67, 0x6e, 0x52,
        0x6f, 0x6c, 0x65, 0x54, 0x6f, 0x55, 0x73, 0x65, 0x72, 0x52, 0x65, 0x71, 0x75, 0x65, 0x73, 0x74,
        0x12, 0x17, 0x0a, 0x07, 0x75, 0x73, 0x65, 0x72, 0x5f, 0x69, 0x64, 0x18, 0x01, 0x20, 0x01, 0x28,
        0x09, 0x52, 0x06, 0x75, 0x73, 0x65, 0x72, 0x49, 0x64, 0x12, 0x17, 0x0a, 0x07, 0x72, 0x6f, 0x6c,
        0x65, 0x5f, 0x69, 0x64, 0x18, 0x02, 0x20, 0x01, 0x28, 0x09, 0x52, 0x06, 0x72, 0x6f, 0x6c, 0x65,
        0x49, 0x64, 0x22, 0x4d, 0x0a, 0x19, 0x52, 0x65, 0x6d, 0x6f, 0x76, 0x65, 0x52, 0x6f, 0x6c, 0x65,
        0x46, 0x72, 0x6f, 0x6d, 0x55, 0x73, 0x65, 0x72, 0x52, 0x65, 0x71, 0x75, 0x65, 0x73, 0x74, 0x12,
        0x17, 0x0a, 0x07, 0x75, 0x73, 0x65, 0x72, 0x5f, 0x69, 0x64, 0x18, 0x01, 0x20, 0x01, 0x28, 0x09,
        0x52, 0x06, 0x75, 0x73, 0x65, 0x72, 0x49, 0x64, 0x12, 0x17, 0x0a, 0x07, 0x72, 0x6f, 0x6c, 0x65,
        0x5f, 0x69, 0x64, 0x18, 0x02, 0x20, 0x01, 0x28, 0x09, 0x52, 0x06, 0x72, 0x6f, 0x6c, 0x65, 0x49,
        0x64, 0x22, 0x65, 0x0a, 0x11, 0x43, 0x72, 0x65, 0x61, 0x74, 0x65, 0x52, 0x6f, 0x6c, 0x65, 0x52,
        0x65, 0x71, 0x75, 0x65, 0x73, 0x74, 0x12, 0x12, 0x0a, 0x04, 0x6e, 0x61, 0x6d, 0x65, 0x18, 0x01,
        0x20, 0x01, 0x28, 0x09, 0x52, 0x04, 0x6e, 0x61, 0x6d, 0x65, 0x12, 0x3c, 0x0a, 0x0b, 0x70, 0x65,
        0x72, 0x6d, 0x69, 0x73, 0x73, 0x69, 0x6f, 0x6e, 0x73, 0x18, 0x02, 0x20, 0x03, 0x28, 0x0b, 0x32,
        0x1a, 0x2e, 0x64, 0x61, 0x74, 0x61, 0x76, 0x69, 0x6e, 0x63, 0x69, 0x2e, 0x61, 0x75, 0x74, 0x68,
        0x2e, 0x50, 0x65, 0x72, 0x6d, 0x69, 0x73, 0x73, 0x69, 0x6f, 0x6e, 0x52, 0x0b, 0x70, 0x65, 0x72,
        0x6d, 0x69, 0x73, 0x73, 0x69, 0x6f, 0x6e, 0x73, 0x22, 0x3e, 0x0a, 0x12, 0x43, 0x72, 0x65, 0x61,
        0x74, 0x65, 0x52, 0x6f, 0x6c, 0x65, 0x52, 0x65, 0x73, 0x70, 0x6f, 0x6e, 0x73, 0x65, 0x12, 0x28,
        0x0a, 0x04, 0x72, 0x6f, 0x6c, 0x65, 0x18, 0x01, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x14, 0x2e, 0x64,
        0x61, 0x74, 0x61, 0x76, 0x69, 0x6e, 0x63, 0x69, 0x2e, 0x61, 0x75, 0x74, 0x68, 0x2e, 0x52, 0x6f,
        0x6c, 0x65, 0x52, 0x04, 0x72, 0x6f, 0x6c, 0x65, 0x22, 0x8c, 0x01, 0x0a, 0x11, 0x55, 0x70, 0x64,
        0x61, 0x74, 0x65, 0x52, 0x6f, 0x6c, 0x65, 0x52, 0x65, 0x71, 0x75, 0x65, 0x73, 0x74, 0x12, 0x17,
        0x0a, 0x07, 0x72, 0x6f, 0x6c, 0x65, 0x5f, 0x69, 0x64, 0x18, 0x01, 0x20, 0x01, 0x28, 0x09, 0x52,
        0x06, 0x72, 0x6f, 0x6c, 0x65, 0x49, 0x64, 0x12, 0x17, 0x0a, 0x04, 0x6e, 0x61, 0x6d, 0x65, 0x18,
        0x02, 0x20, 0x01, 0x28, 0x09, 0x48, 0x00, 0x52, 0x04, 0x6e, 0x61, 0x6d, 0x65, 0x88, 0x01, 0x01,
        0x12, 0x3c, 0x0a, 0x0b, 0x70, 0x65, 0x72, 0x6d, 0x69, 0x73, 0x73, 0x69, 0x6f, 0x6e, 0x73, 0x18,
        0x03, 0x20, 0x03, 0x28, 0x0b, 0x32, 0x1a, 0x2e, 0x64, 0x61, 0x74, 0x61, 0x76, 0x69, 0x6e, 0x63,
        0x69, 0x2e, 0x61, 0x75, 0x74, 0x68, 0x2e, 0x50, 0x65, 0x72, 0x6d, 0x69, 0x73, 0x73, 0x69, 0x6f,
        0x6e, 0x52, 0x0b, 0x70, 0x65, 0x72, 0x6d, 0x69, 0x73, 0x73, 0x69, 0x6f, 0x6e, 0x73, 0x42, 0x07,
        0x0a, 0x05, 0x5f, 0x6e, 0x61, 0x6d, 0x65, 0x22, 0x3e, 0x0a, 0x12, 0x55, 0x70, 0x64, 0x61, 0x74,
        0x65, 0x52, 0x6f, 0x6c, 0x65, 0x52, 0x65, 0x73, 0x70, 0x6f, 0x6e, 0x73, 0x65, 0x12, 0x28, 0x0a,
        0x04, 0x72, 0x6f, 0x6c, 0x65, 0x18, 0x01, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x14, 0x2e, 0x64, 0x61,
        0x74, 0x61, 0x76, 0x69, 0x6e, 0x63, 0x69, 0x2e, 0x61, 0x75, 0x74, 0x68, 0x2e, 0x52, 0x6f, 0x6c,
        0x65, 0x52, 0x04, 0x72, 0x6f, 0x6c, 0x65, 0x22, 0x2c, 0x0a, 0x11, 0x44, 0x65, 0x6c, 0x65, 0x74,
        0x65, 0x52, 0x6f, 0x6c, 0x65, 0x52, 0x65, 0x71, 0x75, 0x65, 0x73, 0x74, 0x12, 0x17, 0x0a, 0x07,
        0x72, 0x6f, 0x6c, 0x65, 0x5f, 0x69, 0x64, 0x18, 0x01, 0x20, 0x01, 0x28, 0x09, 0x52, 0x06, 0x72,
        0x6f, 0x6c, 0x65, 0x49, 0x64, 0x22, 0x29, 0x0a, 0x0e, 0x47, 0x65, 0x74, 0x52, 0x6f, 0x6c, 0x65,
        0x52, 0x65, 0x71, 0x75, 0x65, 0x73, 0x74, 0x12, 0x17, 0x0a, 0x07, 0x72, 0x6f, 0x6c, 0x65, 0x5f,
        0x69, 0x64, 0x18, 0x01, 0x20, 0x01, 0x28, 0x09, 0x52, 0x06, 0x72, 0x6f, 0x6c, 0x65, 0x49, 0x64,
        0x22, 0x3b, 0x0a, 0x0f, 0x47, 0x65, 0x74, 0x52, 0x6f, 0x6c, 0x65, 0x52, 0x65, 0x73, 0x70, 0x6f,
        0x6e, 0x73, 0x65, 0x12, 0x28, 0x0a, 0x04, 0x72, 0x6f, 0x6c, 0x65, 0x18, 0x01, 0x20, 0x01, 0x28,
        0x0b, 0x32, 0x14, 0x2e, 0x64, 0x61, 0x74, 0x61, 0x76, 0x69, 0x6e, 0x63, 0x69, 0x2e, 0x61, 0x75,
        0x74, 0x68, 0x2e, 0x52, 0x6f, 0x6c, 0x65, 0x52, 0x04, 0x72, 0x6f, 0x6c, 0x65, 0x22, 0x4e, 0x0a,
        0x10, 0x4c, 0x69, 0x73, 0x74, 0x52, 0x6f, 0x6c, 0x65, 0x73, 0x52, 0x65, 0x71, 0x75, 0x65, 0x73,
        0x74, 0x12, 0x1b, 0x0a, 0x09, 0x70, 0x61, 0x67, 0x65, 0x5f, 0x73, 0x69, 0x7a, 0x65, 0x18, 0x01,
        0x20, 0x01, 0x28, 0x05, 0x52, 0x08, 0x70, 0x61, 0x67, 0x65, 0x53, 0x69, 0x7a, 0x65, 0x12, 0x1d,
        0x0a, 0x0a, 0x70, 0x61, 0x67, 0x65, 0x5f, 0x74, 0x6f, 0x6b, 0x65, 0x6e, 0x18, 0x02, 0x20, 0x01,
        0x28, 0x09, 0x52, 0x09, 0x70, 0x61, 0x67, 0x65, 0x54, 0x6f, 0x6b, 0x65, 0x6e, 0x22, 0x67, 0x0a,
        0x11, 0x4c, 0x69, 0x73, 0x74, 0x52, 0x6f, 0x6c, 0x65, 0x73, 0x52, 0x65, 0x73, 0x70, 0x6f, 0x6e,
        0x73, 0x65, 0x12, 0x2a, 0x0a, 0x05, 0x72, 0x6f, 0x6c, 0x65, 0x73, 0x18, 0x01, 0x20, 0x03, 0x28,
        0x0b, 0x32, 0x14, 0x2e, 0x64, 0x61, 0x74, 0x61, 0x76, 0x69, 0x6e, 0x63, 0x69, 0x2e, 0x61, 0x75,
        0x74, 0x68, 0x2e, 0x52, 0x6f, 0x6c, 0x65, 0x52, 0x05, 0x72, 0x6f, 0x6c, 0x65, 0x73, 0x12, 0x26,
        0x0a, 0x0f, 0x6e, 0x65, 0x78, 0x74, 0x5f, 0x70, 0x61, 0x67, 0x65, 0x5f, 0x74, 0x6f, 0x6b, 0x65,
        0x6e, 0x18, 0x02, 0x20, 0x01, 0x28, 0x09, 0x52, 0x0d, 0x6e, 0x65, 0x78, 0x74, 0x50, 0x61, 0x67,
        0x65, 0x54, 0x6f, 0x6b, 0x65, 0x6e, 0x22, 0x71, 0x0a, 0x1a, 0x41, 0x64, 0x64, 0x50, 0x65, 0x72,
        0x6d, 0x69, 0x73, 0x73, 0x69, 0x6f, 0x6e, 0x54, 0x6f, 0x52, 0x6f, 0x6c, 0x65, 0x52, 0x65, 0x71,
        0x75, 0x65, 0x73, 0x74, 0x12, 0x17, 0x0a, 0x07, 0x72, 0x6f, 0x6c, 0x65, 0x5f, 0x69, 0x64, 0x18,
        0x01, 0x20, 0x01, 0x28, 0x09, 0x52, 0x06, 0x72, 0x6f, 0x6c, 0x65, 0x49, 0x64, 0x12, 0x3a, 0x0a,
        0x0a, 0x70, 0x65, 0x72, 0x6d, 0x69, 0x73, 0x73, 0x69, 0x6f, 0x6e, 0x18, 0x02, 0x20, 0x01, 0x28,
        0x0b, 0x32, 0x1a, 0x2e, 0x64, 0x61, 0x74, 0x61, 0x76, 0x69, 0x6e, 0x63, 0x69, 0x2e, 0x61, 0x75,
        0x74, 0x68, 0x2e, 0x50, 0x65, 0x72, 0x6d, 0x69, 0x73, 0x73, 0x69, 0x6f, 0x6e, 0x52, 0x0a, 0x70,
        0x65, 0x72, 0x6d, 0x69, 0x73, 0x73, 0x69, 0x6f, 0x6e, 0x22, 0x76, 0x0a, 0x1f, 0x52, 0x65, 0x6d,
        0x6f, 0x76, 0x65, 0x50, 0x65, 0x72, 0x6d, 0x69, 0x73, 0x73, 0x69, 0x6f, 0x6e, 0x46, 0x72, 0x6f,
        0x6d, 0x52, 0x6f, 0x6c, 0x65, 0x52, 0x65, 0x71, 0x75, 0x65, 0x73, 0x74, 0x12, 0x17, 0x0a, 0x07,
        0x72, 0x6f, 0x6c, 0x65, 0x5f, 0x69, 0x64, 0x18, 0x01, 0x20, 0x01, 0x28, 0x09, 0x52, 0x06, 0x72,
        0x6f, 0x6c, 0x65, 0x49, 0x64, 0x12, 0x3a, 0x0a, 0x0a, 0x70, 0x65, 0x72, 0x6d, 0x69, 0x73, 0x73,
        0x69, 0x6f, 0x6e, 0x18, 0x02, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x1a, 0x2e, 0x64, 0x61, 0x74, 0x61,
        0x76, 0x69, 0x6e, 0x63, 0x69, 0x2e, 0x61, 0x75, 0x74, 0x68, 0x2e, 0x50, 0x65, 0x72, 0x6d, 0x69,
        0x73, 0x73, 0x69, 0x6f, 0x6e, 0x52, 0x0a, 0x70, 0x65, 0x72, 0x6d, 0x69, 0x73, 0x73, 0x69, 0x6f,
        0x6e, 0x32, 0xea, 0x07, 0x0a, 0x14, 0x41, 0x75, 0x74, 0x68, 0x6f, 0x72, 0x69, 0x7a, 0x61, 0x74,
        0x69, 0x6f, 0x6e, 0x53, 0x65, 0x72, 0x76, 0x69, 0x63, 0x65, 0x12, 0x64, 0x0a, 0x0f, 0x43, 0x68,
        0x65, 0x63, 0x6b, 0x50, 0x65, 0x72, 0x6d, 0x69, 0x73, 0x73, 0x69, 0x6f, 0x6e, 0x12, 0x26, 0x2e,
        0x64, 0x61, 0x74, 0x61, 0x76, 0x69, 0x6e, 0x63, 0x69, 0x2e, 0x61, 0x75, 0x74, 0x68, 0x2e, 0x43,
        0x68, 0x65, 0x63, 0x6b, 0x50, 0x65, 0x72, 0x6d, 0x69, 0x73, 0x73, 0x69, 0x6f, 0x6e, 0x52, 0x65,
        0x71, 0x75, 0x65, 0x73, 0x74, 0x1a, 0x27, 0x2e, 0x64, 0x61, 0x74, 0x61, 0x76, 0x69, 0x6e, 0x63,
        0x69, 0x2e, 0x61, 0x75, 0x74, 0x68, 0x2e, 0x43, 0x68, 0x65, 0x63, 0x6b, 0x50, 0x65, 0x72, 0x6d,
        0x69, 0x73, 0x73, 0x69, 0x6f, 0x6e, 0x52, 0x65, 0x73, 0x70, 0x6f, 0x6e, 0x73, 0x65, 0x22, 0x00,
        0x12, 0x5b, 0x0a, 0x0c, 0x47, 0x65, 0x74, 0x55, 0x73, 0x65, 0x72, 0x52, 0x6f, 0x6c, 0x65, 0x73,
        0x12, 0x23, 0x2e, 0x64, 0x61, 0x74, 0x61, 0x76, 0x69, 0x6e, 0x63, 0x69, 0x2e, 0x61, 0x75, 0x74,
        0x68, 0x2e, 0x47, 0x65, 0x74, 0x55, 0x73, 0x65, 0x72, 0x52, 0x6f, 0x6c, 0x65, 0x73, 0x52, 0x65,
        0x71, 0x75, 0x65, 0x73, 0x74, 0x1a, 0x24, 0x2e, 0x64, 0x61, 0x74, 0x61, 0x76, 0x69, 0x6e, 0x63,
        0x69, 0x2e, 0x61, 0x75, 0x74, 0x68, 0x2e, 0x47, 0x65, 0x74, 0x55, 0x73, 0x65, 0x72, 0x52, 0x6f,
        0x6c, 0x65, 0x73, 0x52, 0x65, 0x73, 0x70, 0x6f, 0x6e, 0x73, 0x65, 0x22, 0x00, 0x12, 0x55, 0x0a,
        0x10, 0x41, 0x73, 0x73, 0x69, 0x67, 0x6e, 0x52, 0x6f, 0x6c, 0x65, 0x54, 0x6f, 0x55, 0x73, 0x65,
        0x72, 0x12, 0x27, 0x2e, 0x64, 0x61, 0x74, 0x61, 0x76, 0x69, 0x6e, 0x63, 0x69, 0x2e, 0x61, 0x75,
        0x74, 0x68, 0x2e, 0x41, 0x73, 0x73, 0x69, 0x67, 0x6e, 0x52, 0x6f, 0x6c, 0x65, 0x54, 0x6f, 0x55,
        0x73, 0x65, 0x72, 0x52, 0x65, 0x71, 0x75, 0x65, 0x73, 0x74, 0x1a, 0x16, 0x2e, 0x67, 0x6f, 0x6f,
        0x67, 0x6c, 0x65, 0x2e, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x62, 0x75, 0x66, 0x2e, 0x45, 0x6d, 0x70,
        0x74, 0x79, 0x22, 0x00, 0x12, 0x59, 0x0a, 0x12, 0x52, 0x65, 0x6d, 0x6f, 0x76, 0x65, 0x52, 0x6f,
        0x6c, 0x65, 0x46, 0x72, 0x6f, 0x6d, 0x55, 0x73, 0x65, 0x72, 0x12, 0x29, 0x2e, 0x64, 0x61, 0x74,
        0x61, 0x76, 0x69, 0x6e, 0x63, 0x69, 0x2e, 0x61, 0x75, 0x74, 0x68, 0x2e, 0x52, 0x65, 0x6d, 0x6f,
        0x76, 0x65, 0x52, 0x6f, 0x6c, 0x65, 0x46, 0x72, 0x6f, 0x6d, 0x55, 0x73, 0x65, 0x72, 0x52, 0x65,
        0x71, 0x75, 0x65, 0x73, 0x74, 0x1a, 0x16, 0x2e, 0x67, 0x6f, 0x6f, 0x67, 0x6c, 0x65, 0x2e, 0x70,
        0x72, 0x6f, 0x74, 0x6f, 0x62, 0x75, 0x66, 0x2e, 0x45, 0x6d, 0x70, 0x74, 0x79, 0x22, 0x00, 0x12,
        0x55, 0x0a, 0x0a, 0x43, 0x72, 0x65, 0x61, 0x74, 0x65, 0x52, 0x6f, 0x6c, 0x65, 0x12, 0x21, 0x2e,
        0x64, 0x61, 0x74, 0x61, 0x76, 0x69, 0x6e, 0x63, 0x69, 0x2e, 0x61, 0x75, 0x74, 0x68, 0x2e, 0x43,
        0x72, 0x65, 0x61, 0x74, 0x65, 0x52, 0x6f, 0x6c, 0x65, 0x52, 0x65, 0x71, 0x75, 0x65, 0x73, 0x74,
        0x1a, 0x22, 0x2e, 0x64, 0x61, 0x74, 0x61, 0x76, 0x69, 0x6e, 0x63, 0x69, 0x2e, 0x61, 0x75, 0x74,
        0x68, 0x2e, 0x43, 0x72, 0x65, 0x61, 0x74, 0x65, 0x52, 0x6f, 0x6c, 0x65, 0x52, 0x65, 0x73, 0x70,
        0x6f, 0x6e, 0x73, 0x65, 0x22, 0x00, 0x12, 0x55, 0x0a, 0x0a, 0x55, 0x70, 0x64, 0x61, 0x74, 0x65,
        0x52, 0x6f, 0x6c, 0x65, 0x12, 0x21, 0x2e, 0x64, 0x61, 0x74, 0x61, 0x76, 0x69, 0x6e, 0x63, 0x69,
        0x2e, 0x61, 0x75, 0x74, 0x68, 0x2e, 0x55, 0x70, 0x64, 0x61, 0x74, 0x65, 0x52, 0x6f, 0x6c, 0x65,
        0x52, 0x65, 0x71, 0x75, 0x65, 0x73, 0x74, 0x1a, 0x22, 0x2e, 0x64, 0x61, 0x74, 0x61, 0x76, 0x69,
        0x6e, 0x63, 0x69, 0x2e, 0x61, 0x75, 0x74, 0x68, 0x2e, 0x55, 0x70, 0x64, 0x61, 0x74, 0x65, 0x52,
        0x6f, 0x6c, 0x65, 0x52, 0x65, 0x73, 0x70, 0x6f, 0x6e, 0x73, 0x65, 0x22, 0x00, 0x12, 0x49, 0x0a,
        0x0a, 0x44, 0x65, 0x6c, 0x65, 0x74, 0x65, 0x52, 0x6f, 0x6c, 0x65, 0x12, 0x21, 0x2e, 0x64, 0x61,
        0x74, 0x61, 0x76, 0x69, 0x6e, 0x63, 0x69, 0x2e, 0x61, 0x75, 0x74, 0x68, 0x2e, 0x44, 0x65, 0x6c,
        0x65, 0x74, 0x65, 0x52, 0x6f, 0x6c, 0x65, 0x52, 0x65, 0x71, 0x75, 0x65, 0x73, 0x74, 0x1a, 0x16,
        0x2e, 0x67, 0x6f, 0x6f, 0x67, 0x6c, 0x65, 0x2e, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x62, 0x75, 0x66,
        0x2e, 0x45, 0x6d, 0x70, 0x74, 0x79, 0x22, 0x00, 0x12, 0x4c, 0x0a, 0x07, 0x47, 0x65, 0x74, 0x52,
        0x6f, 0x6c, 0x65, 0x12, 0x1e, 0x2e, 0x64, 0x61, 0x74, 0x61, 0x76, 0x69, 0x6e, 0x63, 0x69, 0x2e,
        0x61, 0x75, 0x74, 0x68, 0x2e, 0x47, 0x65, 0x74, 0x52, 0x6f, 0x6c, 0x65, 0x52, 0x65, 0x71, 0x75,
        0x65, 0x73, 0x74, 0x1a, 0x1f, 0x2e, 0x64, 0x61, 0x74, 0x61, 0x76, 0x69, 0x6e, 0x63, 0x69, 0x2e,
        0x61, 0x75, 0x74, 0x68, 0x2e, 0x47, 0x65, 0x74, 0x52, 0x6f, 0x6c, 0x65, 0x52, 0x65, 0x73, 0x70,
        0x6f, 0x6e, 0x73, 0x65, 0x22, 0x00, 0x12, 0x52, 0x0a, 0x09, 0x4c, 0x69, 0x73, 0x74, 0x52, 0x6f,
        0x6c, 0x65, 0x73, 0x12, 0x20, 0x2e, 0x64, 0x61, 0x74, 0x61, 0x76, 0x69, 0x6e, 0x63, 0x69, 0x2e,
        0x61, 0x75, 0x74, 0x68, 0x2e, 0x4c, 0x69, 0x73, 0x74, 0x52, 0x6f, 0x6c, 0x65, 0x73, 0x52, 0x65,
        0x71, 0x75, 0x65, 0x73, 0x74, 0x1a, 0x21, 0x2e, 0x64, 0x61, 0x74, 0x61, 0x76, 0x69, 0x6e, 0x63,
        0x69, 0x2e, 0x61, 0x75, 0x74, 0x68, 0x2e, 0x4c, 0x69, 0x73, 0x74, 0x52, 0x6f, 0x6c, 0x65, 0x73,
        0x52, 0x65, 0x73, 0x70, 0x6f, 0x6e, 0x73, 0x65, 0x22, 0x00, 0x12, 0x5b, 0x0a, 0x13, 0x41, 0x64,
        0x64, 0x50, 0x65, 0x72, 0x6d, 0x69, 0x73, 0x73, 0x69, 0x6f, 0x6e, 0x54, 0x6f, 0x52, 0x6f, 0x6c,
        0x65, 0x12, 0x2a, 0x2e, 0x64, 0x61, 0x74, 0x61, 0x76, 0x69, 0x6e, 0x63, 0x69, 0x2e, 0x61, 0x75,
        0x74, 0x68, 0x2e, 0x41, 0x64, 0x64, 0x50, 0x65, 0x72, 0x6d, 0x69, 0x73, 0x73, 0x69, 0x6f, 0x6e,
        0x54, 0x6f, 0x52, 0x6f, 0x6c, 0x65, 0x52, 0x65, 0x71, 0x75, 0x65, 0x73, 0x74, 0x1a, 0x16, 0x2e,
        0x67, 0x6f, 0x6f, 0x67, 0x6c, 0x65, 0x2e, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x62, 0x75, 0x66, 0x2e,
        0x45, 0x6d, 0x70, 0x74, 0x79, 0x22, 0x00, 0x12, 0x65, 0x0a, 0x18, 0x52, 0x65, 0x6d, 0x6f, 0x76,
        0x65, 0x50, 0x65, 0x72, 0x6d, 0x69, 0x73, 0x73, 0x69, 0x6f, 0x6e, 0x46, 0x72, 0x6f, 0x6d, 0x52,
        0x6f, 0x6c, 0x65, 0x12, 0x2f, 0x2e, 0x64, 0x61, 0x74, 0x61, 0x76, 0x69, 0x6e, 0x63, 0x69, 0x2e,
        0x61, 0x75, 0x74, 0x68, 0x2e, 0x52, 0x65, 0x6d, 0x6f, 0x76, 0x65, 0x50, 0x65, 0x72, 0x6d, 0x69,
        0x73, 0x73, 0x69, 0x6f, 0x6e, 0x46, 0x72, 0x6f, 0x6d, 0x52, 0x6f, 0x6c, 0x65, 0x52, 0x65, 0x71,
        0x75, 0x65, 0x73, 0x74, 0x1a, 0x16, 0x2e, 0x67, 0x6f, 0x6f, 0x67, 0x6c, 0x65, 0x2e, 0x70, 0x72,
        0x6f, 0x74, 0x6f, 0x62, 0x75, 0x66, 0x2e, 0x45, 0x6d, 0x70, 0x74, 0x79, 0x22, 0x00, 0x42, 0x1e,
        0x5a, 0x1c, 0x64, 0x61, 0x74, 0x61, 0x76, 0x69, 0x6e, 0x63, 0x69, 0x2f, 0x69, 0x6e, 0x74, 0x65,
        0x72, 0x6e, 0x61, 0x6c, 0x2f, 0x61, 0x75, 0x74, 0x68, 0x2f, 0x67, 0x72, 0x70, 0x63, 0x62, 0x06,
        0x70, 0x72, 0x6f, 0x74, 0x6f, 0x33,
}

var (
        file_authorization_proto_rawDescOnce sync.Once
        file_authorization_proto_rawDescData = file_authorization_proto_rawDesc
)

func file_authorization_proto_rawDescGZIP() []byte <span class="cov0" title="0">{
        file_authorization_proto_rawDescOnce.Do(func() </span><span class="cov0" title="0">{
                file_authorization_proto_rawDescData = protoimpl.X.CompressGZIP(file_authorization_proto_rawDescData)
        }</span>)
        <span class="cov0" title="0">return file_authorization_proto_rawDescData</span>
}

var file_authorization_proto_msgTypes = make([]protoimpl.MessageInfo, 17)
var file_authorization_proto_goTypes = []any{
        (*CheckPermissionRequest)(nil),          // 0: datavinci.auth.CheckPermissionRequest
        (*CheckPermissionResponse)(nil),         // 1: datavinci.auth.CheckPermissionResponse
        (*GetUserRolesRequest)(nil),             // 2: datavinci.auth.GetUserRolesRequest
        (*GetUserRolesResponse)(nil),            // 3: datavinci.auth.GetUserRolesResponse
        (*AssignRoleToUserRequest)(nil),         // 4: datavinci.auth.AssignRoleToUserRequest
        (*RemoveRoleFromUserRequest)(nil),       // 5: datavinci.auth.RemoveRoleFromUserRequest
        (*CreateRoleRequest)(nil),               // 6: datavinci.auth.CreateRoleRequest
        (*CreateRoleResponse)(nil),              // 7: datavinci.auth.CreateRoleResponse
        (*UpdateRoleRequest)(nil),               // 8: datavinci.auth.UpdateRoleRequest
        (*UpdateRoleResponse)(nil),              // 9: datavinci.auth.UpdateRoleResponse
        (*DeleteRoleRequest)(nil),               // 10: datavinci.auth.DeleteRoleRequest
        (*GetRoleRequest)(nil),                  // 11: datavinci.auth.GetRoleRequest
        (*GetRoleResponse)(nil),                 // 12: datavinci.auth.GetRoleResponse
        (*ListRolesRequest)(nil),                // 13: datavinci.auth.ListRolesRequest
        (*ListRolesResponse)(nil),               // 14: datavinci.auth.ListRolesResponse
        (*AddPermissionToRoleRequest)(nil),      // 15: datavinci.auth.AddPermissionToRoleRequest
        (*RemovePermissionFromRoleRequest)(nil), // 16: datavinci.auth.RemovePermissionFromRoleRequest
        (*Permission)(nil),                      // 17: datavinci.auth.Permission
        (*Role)(nil),                            // 18: datavinci.auth.Role
        (*emptypb.Empty)(nil),                   // 19: google.protobuf.Empty
}
var file_authorization_proto_depIdxs = []int32{
        17, // 0: datavinci.auth.CheckPermissionRequest.permission:type_name -&gt; datavinci.auth.Permission
        18, // 1: datavinci.auth.GetUserRolesResponse.roles:type_name -&gt; datavinci.auth.Role
        17, // 2: datavinci.auth.CreateRoleRequest.permissions:type_name -&gt; datavinci.auth.Permission
        18, // 3: datavinci.auth.CreateRoleResponse.role:type_name -&gt; datavinci.auth.Role
        17, // 4: datavinci.auth.UpdateRoleRequest.permissions:type_name -&gt; datavinci.auth.Permission
        18, // 5: datavinci.auth.UpdateRoleResponse.role:type_name -&gt; datavinci.auth.Role
        18, // 6: datavinci.auth.GetRoleResponse.role:type_name -&gt; datavinci.auth.Role
        18, // 7: datavinci.auth.ListRolesResponse.roles:type_name -&gt; datavinci.auth.Role
        17, // 8: datavinci.auth.AddPermissionToRoleRequest.permission:type_name -&gt; datavinci.auth.Permission
        17, // 9: datavinci.auth.RemovePermissionFromRoleRequest.permission:type_name -&gt; datavinci.auth.Permission
        0,  // 10: datavinci.auth.AuthorizationService.CheckPermission:input_type -&gt; datavinci.auth.CheckPermissionRequest
        2,  // 11: datavinci.auth.AuthorizationService.GetUserRoles:input_type -&gt; datavinci.auth.GetUserRolesRequest
        4,  // 12: datavinci.auth.AuthorizationService.AssignRoleToUser:input_type -&gt; datavinci.auth.AssignRoleToUserRequest
        5,  // 13: datavinci.auth.AuthorizationService.RemoveRoleFromUser:input_type -&gt; datavinci.auth.RemoveRoleFromUserRequest
        6,  // 14: datavinci.auth.AuthorizationService.CreateRole:input_type -&gt; datavinci.auth.CreateRoleRequest
        8,  // 15: datavinci.auth.AuthorizationService.UpdateRole:input_type -&gt; datavinci.auth.UpdateRoleRequest
        10, // 16: datavinci.auth.AuthorizationService.DeleteRole:input_type -&gt; datavinci.auth.DeleteRoleRequest
        11, // 17: datavinci.auth.AuthorizationService.GetRole:input_type -&gt; datavinci.auth.GetRoleRequest
        13, // 18: datavinci.auth.AuthorizationService.ListRoles:input_type -&gt; datavinci.auth.ListRolesRequest
        15, // 19: datavinci.auth.AuthorizationService.AddPermissionToRole:input_type -&gt; datavinci.auth.AddPermissionToRoleRequest
        16, // 20: datavinci.auth.AuthorizationService.RemovePermissionFromRole:input_type -&gt; datavinci.auth.RemovePermissionFromRoleRequest
        1,  // 21: datavinci.auth.AuthorizationService.CheckPermission:output_type -&gt; datavinci.auth.CheckPermissionResponse
        3,  // 22: datavinci.auth.AuthorizationService.GetUserRoles:output_type -&gt; datavinci.auth.GetUserRolesResponse
        19, // 23: datavinci.auth.AuthorizationService.AssignRoleToUser:output_type -&gt; google.protobuf.Empty
        19, // 24: datavinci.auth.AuthorizationService.RemoveRoleFromUser:output_type -&gt; google.protobuf.Empty
        7,  // 25: datavinci.auth.AuthorizationService.CreateRole:output_type -&gt; datavinci.auth.CreateRoleResponse
        9,  // 26: datavinci.auth.AuthorizationService.UpdateRole:output_type -&gt; datavinci.auth.UpdateRoleResponse
        19, // 27: datavinci.auth.AuthorizationService.DeleteRole:output_type -&gt; google.protobuf.Empty
        12, // 28: datavinci.auth.AuthorizationService.GetRole:output_type -&gt; datavinci.auth.GetRoleResponse
        14, // 29: datavinci.auth.AuthorizationService.ListRoles:output_type -&gt; datavinci.auth.ListRolesResponse
        19, // 30: datavinci.auth.AuthorizationService.AddPermissionToRole:output_type -&gt; google.protobuf.Empty
        19, // 31: datavinci.auth.AuthorizationService.RemovePermissionFromRole:output_type -&gt; google.protobuf.Empty
        21, // [21:32] is the sub-list for method output_type
        10, // [10:21] is the sub-list for method input_type
        10, // [10:10] is the sub-list for extension type_name
        10, // [10:10] is the sub-list for extension extendee
        0,  // [0:10] is the sub-list for field type_name
}

func init() <span class="cov0" title="0">{ file_authorization_proto_init() }</span>
func file_authorization_proto_init() <span class="cov0" title="0">{
        if File_authorization_proto != nil </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov0" title="0">file_common_proto_init()
        if !protoimpl.UnsafeEnabled </span><span class="cov0" title="0">{
                file_authorization_proto_msgTypes[0].Exporter = func(v any, i int) any </span><span class="cov0" title="0">{
                        switch v := v.(*CheckPermissionRequest); i </span>{
                        case 0:<span class="cov0" title="0">
                                return &amp;v.state</span>
                        case 1:<span class="cov0" title="0">
                                return &amp;v.sizeCache</span>
                        case 2:<span class="cov0" title="0">
                                return &amp;v.unknownFields</span>
                        default:<span class="cov0" title="0">
                                return nil</span>
                        }
                }
                <span class="cov0" title="0">file_authorization_proto_msgTypes[1].Exporter = func(v any, i int) any </span><span class="cov0" title="0">{
                        switch v := v.(*CheckPermissionResponse); i </span>{
                        case 0:<span class="cov0" title="0">
                                return &amp;v.state</span>
                        case 1:<span class="cov0" title="0">
                                return &amp;v.sizeCache</span>
                        case 2:<span class="cov0" title="0">
                                return &amp;v.unknownFields</span>
                        default:<span class="cov0" title="0">
                                return nil</span>
                        }
                }
                <span class="cov0" title="0">file_authorization_proto_msgTypes[2].Exporter = func(v any, i int) any </span><span class="cov0" title="0">{
                        switch v := v.(*GetUserRolesRequest); i </span>{
                        case 0:<span class="cov0" title="0">
                                return &amp;v.state</span>
                        case 1:<span class="cov0" title="0">
                                return &amp;v.sizeCache</span>
                        case 2:<span class="cov0" title="0">
                                return &amp;v.unknownFields</span>
                        default:<span class="cov0" title="0">
                                return nil</span>
                        }
                }
                <span class="cov0" title="0">file_authorization_proto_msgTypes[3].Exporter = func(v any, i int) any </span><span class="cov0" title="0">{
                        switch v := v.(*GetUserRolesResponse); i </span>{
                        case 0:<span class="cov0" title="0">
                                return &amp;v.state</span>
                        case 1:<span class="cov0" title="0">
                                return &amp;v.sizeCache</span>
                        case 2:<span class="cov0" title="0">
                                return &amp;v.unknownFields</span>
                        default:<span class="cov0" title="0">
                                return nil</span>
                        }
                }
                <span class="cov0" title="0">file_authorization_proto_msgTypes[4].Exporter = func(v any, i int) any </span><span class="cov0" title="0">{
                        switch v := v.(*AssignRoleToUserRequest); i </span>{
                        case 0:<span class="cov0" title="0">
                                return &amp;v.state</span>
                        case 1:<span class="cov0" title="0">
                                return &amp;v.sizeCache</span>
                        case 2:<span class="cov0" title="0">
                                return &amp;v.unknownFields</span>
                        default:<span class="cov0" title="0">
                                return nil</span>
                        }
                }
                <span class="cov0" title="0">file_authorization_proto_msgTypes[5].Exporter = func(v any, i int) any </span><span class="cov0" title="0">{
                        switch v := v.(*RemoveRoleFromUserRequest); i </span>{
                        case 0:<span class="cov0" title="0">
                                return &amp;v.state</span>
                        case 1:<span class="cov0" title="0">
                                return &amp;v.sizeCache</span>
                        case 2:<span class="cov0" title="0">
                                return &amp;v.unknownFields</span>
                        default:<span class="cov0" title="0">
                                return nil</span>
                        }
                }
                <span class="cov0" title="0">file_authorization_proto_msgTypes[6].Exporter = func(v any, i int) any </span><span class="cov0" title="0">{
                        switch v := v.(*CreateRoleRequest); i </span>{
                        case 0:<span class="cov0" title="0">
                                return &amp;v.state</span>
                        case 1:<span class="cov0" title="0">
                                return &amp;v.sizeCache</span>
                        case 2:<span class="cov0" title="0">
                                return &amp;v.unknownFields</span>
                        default:<span class="cov0" title="0">
                                return nil</span>
                        }
                }
                <span class="cov0" title="0">file_authorization_proto_msgTypes[7].Exporter = func(v any, i int) any </span><span class="cov0" title="0">{
                        switch v := v.(*CreateRoleResponse); i </span>{
                        case 0:<span class="cov0" title="0">
                                return &amp;v.state</span>
                        case 1:<span class="cov0" title="0">
                                return &amp;v.sizeCache</span>
                        case 2:<span class="cov0" title="0">
                                return &amp;v.unknownFields</span>
                        default:<span class="cov0" title="0">
                                return nil</span>
                        }
                }
                <span class="cov0" title="0">file_authorization_proto_msgTypes[8].Exporter = func(v any, i int) any </span><span class="cov0" title="0">{
                        switch v := v.(*UpdateRoleRequest); i </span>{
                        case 0:<span class="cov0" title="0">
                                return &amp;v.state</span>
                        case 1:<span class="cov0" title="0">
                                return &amp;v.sizeCache</span>
                        case 2:<span class="cov0" title="0">
                                return &amp;v.unknownFields</span>
                        default:<span class="cov0" title="0">
                                return nil</span>
                        }
                }
                <span class="cov0" title="0">file_authorization_proto_msgTypes[9].Exporter = func(v any, i int) any </span><span class="cov0" title="0">{
                        switch v := v.(*UpdateRoleResponse); i </span>{
                        case 0:<span class="cov0" title="0">
                                return &amp;v.state</span>
                        case 1:<span class="cov0" title="0">
                                return &amp;v.sizeCache</span>
                        case 2:<span class="cov0" title="0">
                                return &amp;v.unknownFields</span>
                        default:<span class="cov0" title="0">
                                return nil</span>
                        }
                }
                <span class="cov0" title="0">file_authorization_proto_msgTypes[10].Exporter = func(v any, i int) any </span><span class="cov0" title="0">{
                        switch v := v.(*DeleteRoleRequest); i </span>{
                        case 0:<span class="cov0" title="0">
                                return &amp;v.state</span>
                        case 1:<span class="cov0" title="0">
                                return &amp;v.sizeCache</span>
                        case 2:<span class="cov0" title="0">
                                return &amp;v.unknownFields</span>
                        default:<span class="cov0" title="0">
                                return nil</span>
                        }
                }
                <span class="cov0" title="0">file_authorization_proto_msgTypes[11].Exporter = func(v any, i int) any </span><span class="cov0" title="0">{
                        switch v := v.(*GetRoleRequest); i </span>{
                        case 0:<span class="cov0" title="0">
                                return &amp;v.state</span>
                        case 1:<span class="cov0" title="0">
                                return &amp;v.sizeCache</span>
                        case 2:<span class="cov0" title="0">
                                return &amp;v.unknownFields</span>
                        default:<span class="cov0" title="0">
                                return nil</span>
                        }
                }
                <span class="cov0" title="0">file_authorization_proto_msgTypes[12].Exporter = func(v any, i int) any </span><span class="cov0" title="0">{
                        switch v := v.(*GetRoleResponse); i </span>{
                        case 0:<span class="cov0" title="0">
                                return &amp;v.state</span>
                        case 1:<span class="cov0" title="0">
                                return &amp;v.sizeCache</span>
                        case 2:<span class="cov0" title="0">
                                return &amp;v.unknownFields</span>
                        default:<span class="cov0" title="0">
                                return nil</span>
                        }
                }
                <span class="cov0" title="0">file_authorization_proto_msgTypes[13].Exporter = func(v any, i int) any </span><span class="cov0" title="0">{
                        switch v := v.(*ListRolesRequest); i </span>{
                        case 0:<span class="cov0" title="0">
                                return &amp;v.state</span>
                        case 1:<span class="cov0" title="0">
                                return &amp;v.sizeCache</span>
                        case 2:<span class="cov0" title="0">
                                return &amp;v.unknownFields</span>
                        default:<span class="cov0" title="0">
                                return nil</span>
                        }
                }
                <span class="cov0" title="0">file_authorization_proto_msgTypes[14].Exporter = func(v any, i int) any </span><span class="cov0" title="0">{
                        switch v := v.(*ListRolesResponse); i </span>{
                        case 0:<span class="cov0" title="0">
                                return &amp;v.state</span>
                        case 1:<span class="cov0" title="0">
                                return &amp;v.sizeCache</span>
                        case 2:<span class="cov0" title="0">
                                return &amp;v.unknownFields</span>
                        default:<span class="cov0" title="0">
                                return nil</span>
                        }
                }
                <span class="cov0" title="0">file_authorization_proto_msgTypes[15].Exporter = func(v any, i int) any </span><span class="cov0" title="0">{
                        switch v := v.(*AddPermissionToRoleRequest); i </span>{
                        case 0:<span class="cov0" title="0">
                                return &amp;v.state</span>
                        case 1:<span class="cov0" title="0">
                                return &amp;v.sizeCache</span>
                        case 2:<span class="cov0" title="0">
                                return &amp;v.unknownFields</span>
                        default:<span class="cov0" title="0">
                                return nil</span>
                        }
                }
                <span class="cov0" title="0">file_authorization_proto_msgTypes[16].Exporter = func(v any, i int) any </span><span class="cov0" title="0">{
                        switch v := v.(*RemovePermissionFromRoleRequest); i </span>{
                        case 0:<span class="cov0" title="0">
                                return &amp;v.state</span>
                        case 1:<span class="cov0" title="0">
                                return &amp;v.sizeCache</span>
                        case 2:<span class="cov0" title="0">
                                return &amp;v.unknownFields</span>
                        default:<span class="cov0" title="0">
                                return nil</span>
                        }
                }
        }
        <span class="cov0" title="0">file_authorization_proto_msgTypes[8].OneofWrappers = []any{}
        type x struct{}
        out := protoimpl.TypeBuilder{
                File: protoimpl.DescBuilder{
                        GoPackagePath: reflect.TypeOf(x{}).PkgPath(),
                        RawDescriptor: file_authorization_proto_rawDesc,
                        NumEnums:      0,
                        NumMessages:   17,
                        NumExtensions: 0,
                        NumServices:   1,
                },
                GoTypes:           file_authorization_proto_goTypes,
                DependencyIndexes: file_authorization_proto_depIdxs,
                MessageInfos:      file_authorization_proto_msgTypes,
        }.Build()
        File_authorization_proto = out.File
        file_authorization_proto_rawDesc = nil
        file_authorization_proto_goTypes = nil
        file_authorization_proto_depIdxs = nil</span>
}
</pre>
		
		<pre class="file" id="file47" style="display: none">// Code generated by protoc-gen-go-grpc. DO NOT EDIT.
// versions:
// - protoc-gen-go-grpc v1.4.0
// - protoc             v3.21.12
// source: authorization.proto

package grpc

import (
        context "context"

        grpc "google.golang.org/grpc"
        codes "google.golang.org/grpc/codes"
        status "google.golang.org/grpc/status"
        emptypb "google.golang.org/protobuf/types/known/emptypb"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
// Requires gRPC-Go v1.62.0 or later.
const _ = grpc.SupportPackageIsVersion8

const (
        AuthorizationService_CheckPermission_FullMethodName          = "/datavinci.auth.AuthorizationService/CheckPermission"
        AuthorizationService_GetUserRoles_FullMethodName             = "/datavinci.auth.AuthorizationService/GetUserRoles"
        AuthorizationService_AssignRoleToUser_FullMethodName         = "/datavinci.auth.AuthorizationService/AssignRoleToUser"
        AuthorizationService_RemoveRoleFromUser_FullMethodName       = "/datavinci.auth.AuthorizationService/RemoveRoleFromUser"
        AuthorizationService_CreateRole_FullMethodName               = "/datavinci.auth.AuthorizationService/CreateRole"
        AuthorizationService_UpdateRole_FullMethodName               = "/datavinci.auth.AuthorizationService/UpdateRole"
        AuthorizationService_DeleteRole_FullMethodName               = "/datavinci.auth.AuthorizationService/DeleteRole"
        AuthorizationService_GetRole_FullMethodName                  = "/datavinci.auth.AuthorizationService/GetRole"
        AuthorizationService_ListRoles_FullMethodName                = "/datavinci.auth.AuthorizationService/ListRoles"
        AuthorizationService_AddPermissionToRole_FullMethodName      = "/datavinci.auth.AuthorizationService/AddPermissionToRole"
        AuthorizationService_RemovePermissionFromRole_FullMethodName = "/datavinci.auth.AuthorizationService/RemovePermissionFromRole"
)

// AuthorizationServiceClient is the client API for AuthorizationService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type AuthorizationServiceClient interface {
        // CheckPermission checks if a user has a specific permission
        CheckPermission(ctx context.Context, in *CheckPermissionRequest, opts ...grpc.CallOption) (*CheckPermissionResponse, error)
        // GetUserRoles retrieves all roles assigned to a user
        GetUserRoles(ctx context.Context, in *GetUserRolesRequest, opts ...grpc.CallOption) (*GetUserRolesResponse, error)
        // AssignRoleToUser assigns a role to a user
        AssignRoleToUser(ctx context.Context, in *AssignRoleToUserRequest, opts ...grpc.CallOption) (*emptypb.Empty, error)
        // RemoveRoleFromUser removes a role from a user
        RemoveRoleFromUser(ctx context.Context, in *RemoveRoleFromUserRequest, opts ...grpc.CallOption) (*emptypb.Empty, error)
        // CreateRole creates a new role
        CreateRole(ctx context.Context, in *CreateRoleRequest, opts ...grpc.CallOption) (*CreateRoleResponse, error)
        // UpdateRole updates an existing role
        UpdateRole(ctx context.Context, in *UpdateRoleRequest, opts ...grpc.CallOption) (*UpdateRoleResponse, error)
        // DeleteRole deletes a role
        DeleteRole(ctx context.Context, in *DeleteRoleRequest, opts ...grpc.CallOption) (*emptypb.Empty, error)
        // GetRole retrieves role information
        GetRole(ctx context.Context, in *GetRoleRequest, opts ...grpc.CallOption) (*GetRoleResponse, error)
        // ListRoles lists all roles in the system
        ListRoles(ctx context.Context, in *ListRolesRequest, opts ...grpc.CallOption) (*ListRolesResponse, error)
        // AddPermissionToRole adds a permission to a role
        AddPermissionToRole(ctx context.Context, in *AddPermissionToRoleRequest, opts ...grpc.CallOption) (*emptypb.Empty, error)
        // RemovePermissionFromRole removes a permission from a role
        RemovePermissionFromRole(ctx context.Context, in *RemovePermissionFromRoleRequest, opts ...grpc.CallOption) (*emptypb.Empty, error)
}

type authorizationServiceClient struct {
        cc grpc.ClientConnInterface
}

func NewAuthorizationServiceClient(cc grpc.ClientConnInterface) AuthorizationServiceClient <span class="cov0" title="0">{
        return &amp;authorizationServiceClient{cc}
}</span>

func (c *authorizationServiceClient) CheckPermission(ctx context.Context, in *CheckPermissionRequest, opts ...grpc.CallOption) (*CheckPermissionResponse, error) <span class="cov0" title="0">{
        cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
        out := new(CheckPermissionResponse)
        err := c.cc.Invoke(ctx, AuthorizationService_CheckPermission_FullMethodName, in, out, cOpts...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return out, nil</span>
}

func (c *authorizationServiceClient) GetUserRoles(ctx context.Context, in *GetUserRolesRequest, opts ...grpc.CallOption) (*GetUserRolesResponse, error) <span class="cov0" title="0">{
        cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
        out := new(GetUserRolesResponse)
        err := c.cc.Invoke(ctx, AuthorizationService_GetUserRoles_FullMethodName, in, out, cOpts...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return out, nil</span>
}

func (c *authorizationServiceClient) AssignRoleToUser(ctx context.Context, in *AssignRoleToUserRequest, opts ...grpc.CallOption) (*emptypb.Empty, error) <span class="cov0" title="0">{
        cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
        out := new(emptypb.Empty)
        err := c.cc.Invoke(ctx, AuthorizationService_AssignRoleToUser_FullMethodName, in, out, cOpts...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return out, nil</span>
}

func (c *authorizationServiceClient) RemoveRoleFromUser(ctx context.Context, in *RemoveRoleFromUserRequest, opts ...grpc.CallOption) (*emptypb.Empty, error) <span class="cov0" title="0">{
        cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
        out := new(emptypb.Empty)
        err := c.cc.Invoke(ctx, AuthorizationService_RemoveRoleFromUser_FullMethodName, in, out, cOpts...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return out, nil</span>
}

func (c *authorizationServiceClient) CreateRole(ctx context.Context, in *CreateRoleRequest, opts ...grpc.CallOption) (*CreateRoleResponse, error) <span class="cov0" title="0">{
        cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
        out := new(CreateRoleResponse)
        err := c.cc.Invoke(ctx, AuthorizationService_CreateRole_FullMethodName, in, out, cOpts...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return out, nil</span>
}

func (c *authorizationServiceClient) UpdateRole(ctx context.Context, in *UpdateRoleRequest, opts ...grpc.CallOption) (*UpdateRoleResponse, error) <span class="cov0" title="0">{
        cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
        out := new(UpdateRoleResponse)
        err := c.cc.Invoke(ctx, AuthorizationService_UpdateRole_FullMethodName, in, out, cOpts...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return out, nil</span>
}

func (c *authorizationServiceClient) DeleteRole(ctx context.Context, in *DeleteRoleRequest, opts ...grpc.CallOption) (*emptypb.Empty, error) <span class="cov0" title="0">{
        cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
        out := new(emptypb.Empty)
        err := c.cc.Invoke(ctx, AuthorizationService_DeleteRole_FullMethodName, in, out, cOpts...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return out, nil</span>
}

func (c *authorizationServiceClient) GetRole(ctx context.Context, in *GetRoleRequest, opts ...grpc.CallOption) (*GetRoleResponse, error) <span class="cov0" title="0">{
        cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
        out := new(GetRoleResponse)
        err := c.cc.Invoke(ctx, AuthorizationService_GetRole_FullMethodName, in, out, cOpts...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return out, nil</span>
}

func (c *authorizationServiceClient) ListRoles(ctx context.Context, in *ListRolesRequest, opts ...grpc.CallOption) (*ListRolesResponse, error) <span class="cov0" title="0">{
        cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
        out := new(ListRolesResponse)
        err := c.cc.Invoke(ctx, AuthorizationService_ListRoles_FullMethodName, in, out, cOpts...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return out, nil</span>
}

func (c *authorizationServiceClient) AddPermissionToRole(ctx context.Context, in *AddPermissionToRoleRequest, opts ...grpc.CallOption) (*emptypb.Empty, error) <span class="cov0" title="0">{
        cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
        out := new(emptypb.Empty)
        err := c.cc.Invoke(ctx, AuthorizationService_AddPermissionToRole_FullMethodName, in, out, cOpts...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return out, nil</span>
}

func (c *authorizationServiceClient) RemovePermissionFromRole(ctx context.Context, in *RemovePermissionFromRoleRequest, opts ...grpc.CallOption) (*emptypb.Empty, error) <span class="cov0" title="0">{
        cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
        out := new(emptypb.Empty)
        err := c.cc.Invoke(ctx, AuthorizationService_RemovePermissionFromRole_FullMethodName, in, out, cOpts...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return out, nil</span>
}

// AuthorizationServiceServer is the server API for AuthorizationService service.
// All implementations must embed UnimplementedAuthorizationServiceServer
// for forward compatibility
type AuthorizationServiceServer interface {
        // CheckPermission checks if a user has a specific permission
        CheckPermission(context.Context, *CheckPermissionRequest) (*CheckPermissionResponse, error)
        // GetUserRoles retrieves all roles assigned to a user
        GetUserRoles(context.Context, *GetUserRolesRequest) (*GetUserRolesResponse, error)
        // AssignRoleToUser assigns a role to a user
        AssignRoleToUser(context.Context, *AssignRoleToUserRequest) (*emptypb.Empty, error)
        // RemoveRoleFromUser removes a role from a user
        RemoveRoleFromUser(context.Context, *RemoveRoleFromUserRequest) (*emptypb.Empty, error)
        // CreateRole creates a new role
        CreateRole(context.Context, *CreateRoleRequest) (*CreateRoleResponse, error)
        // UpdateRole updates an existing role
        UpdateRole(context.Context, *UpdateRoleRequest) (*UpdateRoleResponse, error)
        // DeleteRole deletes a role
        DeleteRole(context.Context, *DeleteRoleRequest) (*emptypb.Empty, error)
        // GetRole retrieves role information
        GetRole(context.Context, *GetRoleRequest) (*GetRoleResponse, error)
        // ListRoles lists all roles in the system
        ListRoles(context.Context, *ListRolesRequest) (*ListRolesResponse, error)
        // AddPermissionToRole adds a permission to a role
        AddPermissionToRole(context.Context, *AddPermissionToRoleRequest) (*emptypb.Empty, error)
        // RemovePermissionFromRole removes a permission from a role
        RemovePermissionFromRole(context.Context, *RemovePermissionFromRoleRequest) (*emptypb.Empty, error)
        mustEmbedUnimplementedAuthorizationServiceServer()
}

// UnimplementedAuthorizationServiceServer must be embedded to have forward compatible implementations.
type UnimplementedAuthorizationServiceServer struct {
}

func (UnimplementedAuthorizationServiceServer) CheckPermission(context.Context, *CheckPermissionRequest) (*CheckPermissionResponse, error) <span class="cov0" title="0">{
        return nil, status.Errorf(codes.Unimplemented, "method CheckPermission not implemented")
}</span>
func (UnimplementedAuthorizationServiceServer) GetUserRoles(context.Context, *GetUserRolesRequest) (*GetUserRolesResponse, error) <span class="cov0" title="0">{
        return nil, status.Errorf(codes.Unimplemented, "method GetUserRoles not implemented")
}</span>
func (UnimplementedAuthorizationServiceServer) AssignRoleToUser(context.Context, *AssignRoleToUserRequest) (*emptypb.Empty, error) <span class="cov0" title="0">{
        return nil, status.Errorf(codes.Unimplemented, "method AssignRoleToUser not implemented")
}</span>
func (UnimplementedAuthorizationServiceServer) RemoveRoleFromUser(context.Context, *RemoveRoleFromUserRequest) (*emptypb.Empty, error) <span class="cov0" title="0">{
        return nil, status.Errorf(codes.Unimplemented, "method RemoveRoleFromUser not implemented")
}</span>
func (UnimplementedAuthorizationServiceServer) CreateRole(context.Context, *CreateRoleRequest) (*CreateRoleResponse, error) <span class="cov0" title="0">{
        return nil, status.Errorf(codes.Unimplemented, "method CreateRole not implemented")
}</span>
func (UnimplementedAuthorizationServiceServer) UpdateRole(context.Context, *UpdateRoleRequest) (*UpdateRoleResponse, error) <span class="cov0" title="0">{
        return nil, status.Errorf(codes.Unimplemented, "method UpdateRole not implemented")
}</span>
func (UnimplementedAuthorizationServiceServer) DeleteRole(context.Context, *DeleteRoleRequest) (*emptypb.Empty, error) <span class="cov0" title="0">{
        return nil, status.Errorf(codes.Unimplemented, "method DeleteRole not implemented")
}</span>
func (UnimplementedAuthorizationServiceServer) GetRole(context.Context, *GetRoleRequest) (*GetRoleResponse, error) <span class="cov0" title="0">{
        return nil, status.Errorf(codes.Unimplemented, "method GetRole not implemented")
}</span>
func (UnimplementedAuthorizationServiceServer) ListRoles(context.Context, *ListRolesRequest) (*ListRolesResponse, error) <span class="cov0" title="0">{
        return nil, status.Errorf(codes.Unimplemented, "method ListRoles not implemented")
}</span>
func (UnimplementedAuthorizationServiceServer) AddPermissionToRole(context.Context, *AddPermissionToRoleRequest) (*emptypb.Empty, error) <span class="cov0" title="0">{
        return nil, status.Errorf(codes.Unimplemented, "method AddPermissionToRole not implemented")
}</span>
func (UnimplementedAuthorizationServiceServer) RemovePermissionFromRole(context.Context, *RemovePermissionFromRoleRequest) (*emptypb.Empty, error) <span class="cov0" title="0">{
        return nil, status.Errorf(codes.Unimplemented, "method RemovePermissionFromRole not implemented")
}</span>
func (UnimplementedAuthorizationServiceServer) mustEmbedUnimplementedAuthorizationServiceServer() {<span class="cov0" title="0">}</span>

// UnsafeAuthorizationServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to AuthorizationServiceServer will
// result in compilation errors.
type UnsafeAuthorizationServiceServer interface {
        mustEmbedUnimplementedAuthorizationServiceServer()
}

func RegisterAuthorizationServiceServer(s grpc.ServiceRegistrar, srv AuthorizationServiceServer) <span class="cov0" title="0">{
        s.RegisterService(&amp;AuthorizationService_ServiceDesc, srv)
}</span>

func _AuthorizationService_CheckPermission_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) <span class="cov0" title="0">{
        in := new(CheckPermissionRequest)
        if err := dec(in); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">if interceptor == nil </span><span class="cov0" title="0">{
                return srv.(AuthorizationServiceServer).CheckPermission(ctx, in)
        }</span>
        <span class="cov0" title="0">info := &amp;grpc.UnaryServerInfo{
                Server:     srv,
                FullMethod: AuthorizationService_CheckPermission_FullMethodName,
        }
        handler := func(ctx context.Context, req interface{}) (interface{}, error) </span><span class="cov0" title="0">{
                return srv.(AuthorizationServiceServer).CheckPermission(ctx, req.(*CheckPermissionRequest))
        }</span>
        <span class="cov0" title="0">return interceptor(ctx, in, info, handler)</span>
}

func _AuthorizationService_GetUserRoles_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) <span class="cov0" title="0">{
        in := new(GetUserRolesRequest)
        if err := dec(in); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">if interceptor == nil </span><span class="cov0" title="0">{
                return srv.(AuthorizationServiceServer).GetUserRoles(ctx, in)
        }</span>
        <span class="cov0" title="0">info := &amp;grpc.UnaryServerInfo{
                Server:     srv,
                FullMethod: AuthorizationService_GetUserRoles_FullMethodName,
        }
        handler := func(ctx context.Context, req interface{}) (interface{}, error) </span><span class="cov0" title="0">{
                return srv.(AuthorizationServiceServer).GetUserRoles(ctx, req.(*GetUserRolesRequest))
        }</span>
        <span class="cov0" title="0">return interceptor(ctx, in, info, handler)</span>
}

func _AuthorizationService_AssignRoleToUser_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) <span class="cov0" title="0">{
        in := new(AssignRoleToUserRequest)
        if err := dec(in); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">if interceptor == nil </span><span class="cov0" title="0">{
                return srv.(AuthorizationServiceServer).AssignRoleToUser(ctx, in)
        }</span>
        <span class="cov0" title="0">info := &amp;grpc.UnaryServerInfo{
                Server:     srv,
                FullMethod: AuthorizationService_AssignRoleToUser_FullMethodName,
        }
        handler := func(ctx context.Context, req interface{}) (interface{}, error) </span><span class="cov0" title="0">{
                return srv.(AuthorizationServiceServer).AssignRoleToUser(ctx, req.(*AssignRoleToUserRequest))
        }</span>
        <span class="cov0" title="0">return interceptor(ctx, in, info, handler)</span>
}

func _AuthorizationService_RemoveRoleFromUser_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) <span class="cov0" title="0">{
        in := new(RemoveRoleFromUserRequest)
        if err := dec(in); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">if interceptor == nil </span><span class="cov0" title="0">{
                return srv.(AuthorizationServiceServer).RemoveRoleFromUser(ctx, in)
        }</span>
        <span class="cov0" title="0">info := &amp;grpc.UnaryServerInfo{
                Server:     srv,
                FullMethod: AuthorizationService_RemoveRoleFromUser_FullMethodName,
        }
        handler := func(ctx context.Context, req interface{}) (interface{}, error) </span><span class="cov0" title="0">{
                return srv.(AuthorizationServiceServer).RemoveRoleFromUser(ctx, req.(*RemoveRoleFromUserRequest))
        }</span>
        <span class="cov0" title="0">return interceptor(ctx, in, info, handler)</span>
}

func _AuthorizationService_CreateRole_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) <span class="cov0" title="0">{
        in := new(CreateRoleRequest)
        if err := dec(in); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">if interceptor == nil </span><span class="cov0" title="0">{
                return srv.(AuthorizationServiceServer).CreateRole(ctx, in)
        }</span>
        <span class="cov0" title="0">info := &amp;grpc.UnaryServerInfo{
                Server:     srv,
                FullMethod: AuthorizationService_CreateRole_FullMethodName,
        }
        handler := func(ctx context.Context, req interface{}) (interface{}, error) </span><span class="cov0" title="0">{
                return srv.(AuthorizationServiceServer).CreateRole(ctx, req.(*CreateRoleRequest))
        }</span>
        <span class="cov0" title="0">return interceptor(ctx, in, info, handler)</span>
}

func _AuthorizationService_UpdateRole_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) <span class="cov0" title="0">{
        in := new(UpdateRoleRequest)
        if err := dec(in); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">if interceptor == nil </span><span class="cov0" title="0">{
                return srv.(AuthorizationServiceServer).UpdateRole(ctx, in)
        }</span>
        <span class="cov0" title="0">info := &amp;grpc.UnaryServerInfo{
                Server:     srv,
                FullMethod: AuthorizationService_UpdateRole_FullMethodName,
        }
        handler := func(ctx context.Context, req interface{}) (interface{}, error) </span><span class="cov0" title="0">{
                return srv.(AuthorizationServiceServer).UpdateRole(ctx, req.(*UpdateRoleRequest))
        }</span>
        <span class="cov0" title="0">return interceptor(ctx, in, info, handler)</span>
}

func _AuthorizationService_DeleteRole_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) <span class="cov0" title="0">{
        in := new(DeleteRoleRequest)
        if err := dec(in); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">if interceptor == nil </span><span class="cov0" title="0">{
                return srv.(AuthorizationServiceServer).DeleteRole(ctx, in)
        }</span>
        <span class="cov0" title="0">info := &amp;grpc.UnaryServerInfo{
                Server:     srv,
                FullMethod: AuthorizationService_DeleteRole_FullMethodName,
        }
        handler := func(ctx context.Context, req interface{}) (interface{}, error) </span><span class="cov0" title="0">{
                return srv.(AuthorizationServiceServer).DeleteRole(ctx, req.(*DeleteRoleRequest))
        }</span>
        <span class="cov0" title="0">return interceptor(ctx, in, info, handler)</span>
}

func _AuthorizationService_GetRole_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) <span class="cov0" title="0">{
        in := new(GetRoleRequest)
        if err := dec(in); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">if interceptor == nil </span><span class="cov0" title="0">{
                return srv.(AuthorizationServiceServer).GetRole(ctx, in)
        }</span>
        <span class="cov0" title="0">info := &amp;grpc.UnaryServerInfo{
                Server:     srv,
                FullMethod: AuthorizationService_GetRole_FullMethodName,
        }
        handler := func(ctx context.Context, req interface{}) (interface{}, error) </span><span class="cov0" title="0">{
                return srv.(AuthorizationServiceServer).GetRole(ctx, req.(*GetRoleRequest))
        }</span>
        <span class="cov0" title="0">return interceptor(ctx, in, info, handler)</span>
}

func _AuthorizationService_ListRoles_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) <span class="cov0" title="0">{
        in := new(ListRolesRequest)
        if err := dec(in); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">if interceptor == nil </span><span class="cov0" title="0">{
                return srv.(AuthorizationServiceServer).ListRoles(ctx, in)
        }</span>
        <span class="cov0" title="0">info := &amp;grpc.UnaryServerInfo{
                Server:     srv,
                FullMethod: AuthorizationService_ListRoles_FullMethodName,
        }
        handler := func(ctx context.Context, req interface{}) (interface{}, error) </span><span class="cov0" title="0">{
                return srv.(AuthorizationServiceServer).ListRoles(ctx, req.(*ListRolesRequest))
        }</span>
        <span class="cov0" title="0">return interceptor(ctx, in, info, handler)</span>
}

func _AuthorizationService_AddPermissionToRole_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) <span class="cov0" title="0">{
        in := new(AddPermissionToRoleRequest)
        if err := dec(in); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">if interceptor == nil </span><span class="cov0" title="0">{
                return srv.(AuthorizationServiceServer).AddPermissionToRole(ctx, in)
        }</span>
        <span class="cov0" title="0">info := &amp;grpc.UnaryServerInfo{
                Server:     srv,
                FullMethod: AuthorizationService_AddPermissionToRole_FullMethodName,
        }
        handler := func(ctx context.Context, req interface{}) (interface{}, error) </span><span class="cov0" title="0">{
                return srv.(AuthorizationServiceServer).AddPermissionToRole(ctx, req.(*AddPermissionToRoleRequest))
        }</span>
        <span class="cov0" title="0">return interceptor(ctx, in, info, handler)</span>
}

func _AuthorizationService_RemovePermissionFromRole_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) <span class="cov0" title="0">{
        in := new(RemovePermissionFromRoleRequest)
        if err := dec(in); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">if interceptor == nil </span><span class="cov0" title="0">{
                return srv.(AuthorizationServiceServer).RemovePermissionFromRole(ctx, in)
        }</span>
        <span class="cov0" title="0">info := &amp;grpc.UnaryServerInfo{
                Server:     srv,
                FullMethod: AuthorizationService_RemovePermissionFromRole_FullMethodName,
        }
        handler := func(ctx context.Context, req interface{}) (interface{}, error) </span><span class="cov0" title="0">{
                return srv.(AuthorizationServiceServer).RemovePermissionFromRole(ctx, req.(*RemovePermissionFromRoleRequest))
        }</span>
        <span class="cov0" title="0">return interceptor(ctx, in, info, handler)</span>
}

// AuthorizationService_ServiceDesc is the grpc.ServiceDesc for AuthorizationService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var AuthorizationService_ServiceDesc = grpc.ServiceDesc{
        ServiceName: "datavinci.auth.AuthorizationService",
        HandlerType: (*AuthorizationServiceServer)(nil),
        Methods: []grpc.MethodDesc{
                {
                        MethodName: "CheckPermission",
                        Handler:    _AuthorizationService_CheckPermission_Handler,
                },
                {
                        MethodName: "GetUserRoles",
                        Handler:    _AuthorizationService_GetUserRoles_Handler,
                },
                {
                        MethodName: "AssignRoleToUser",
                        Handler:    _AuthorizationService_AssignRoleToUser_Handler,
                },
                {
                        MethodName: "RemoveRoleFromUser",
                        Handler:    _AuthorizationService_RemoveRoleFromUser_Handler,
                },
                {
                        MethodName: "CreateRole",
                        Handler:    _AuthorizationService_CreateRole_Handler,
                },
                {
                        MethodName: "UpdateRole",
                        Handler:    _AuthorizationService_UpdateRole_Handler,
                },
                {
                        MethodName: "DeleteRole",
                        Handler:    _AuthorizationService_DeleteRole_Handler,
                },
                {
                        MethodName: "GetRole",
                        Handler:    _AuthorizationService_GetRole_Handler,
                },
                {
                        MethodName: "ListRoles",
                        Handler:    _AuthorizationService_ListRoles_Handler,
                },
                {
                        MethodName: "AddPermissionToRole",
                        Handler:    _AuthorizationService_AddPermissionToRole_Handler,
                },
                {
                        MethodName: "RemovePermissionFromRole",
                        Handler:    _AuthorizationService_RemovePermissionFromRole_Handler,
                },
        },
        Streams:  []grpc.StreamDesc{},
        Metadata: "authorization.proto",
}
</pre>
		
		<pre class="file" id="file48" style="display: none">// Code generated by protoc-gen-go. DO NOT EDIT.
// versions:
//         protoc-gen-go v1.34.2
//         protoc        v3.21.12
// source: common.proto

package grpc

import (
        reflect "reflect"
        sync "sync"

        protoreflect "google.golang.org/protobuf/reflect/protoreflect"
        protoimpl "google.golang.org/protobuf/runtime/protoimpl"
        timestamppb "google.golang.org/protobuf/types/known/timestamppb"
)

const (
        // Verify that this generated code is sufficiently up-to-date.
        _ = protoimpl.EnforceVersion(20 - protoimpl.MinVersion)
        // Verify that runtime/protoimpl is sufficiently up-to-date.
        _ = protoimpl.EnforceVersion(protoimpl.MaxVersion - 20)
)

// User represents a user in the system
type User struct {
        state         protoimpl.MessageState
        sizeCache     protoimpl.SizeCache
        unknownFields protoimpl.UnknownFields

        Id        string                 `protobuf:"bytes,1,opt,name=id,proto3" json:"id,omitempty"`
        Username  string                 `protobuf:"bytes,2,opt,name=username,proto3" json:"username,omitempty"`
        Email     string                 `protobuf:"bytes,3,opt,name=email,proto3" json:"email,omitempty"`
        Roles     []string               `protobuf:"bytes,4,rep,name=roles,proto3" json:"roles,omitempty"`
        CreatedAt *timestamppb.Timestamp `protobuf:"bytes,5,opt,name=created_at,json=createdAt,proto3" json:"created_at,omitempty"`
        UpdatedAt *timestamppb.Timestamp `protobuf:"bytes,6,opt,name=updated_at,json=updatedAt,proto3" json:"updated_at,omitempty"`
}

func (x *User) Reset() <span class="cov0" title="0">{
        *x = User{}
        if protoimpl.UnsafeEnabled </span><span class="cov0" title="0">{
                mi := &amp;file_common_proto_msgTypes[0]
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                ms.StoreMessageInfo(mi)
        }</span>
}

func (x *User) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*User) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *User) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_common_proto_msgTypes[0]
        if protoimpl.UnsafeEnabled &amp;&amp; x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use User.ProtoReflect.Descriptor instead.
func (*User) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_common_proto_rawDescGZIP(), []int{0}
}</span>

func (x *User) GetId() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Id
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *User) GetUsername() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Username
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *User) GetEmail() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Email
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *User) GetRoles() []string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Roles
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (x *User) GetCreatedAt() *timestamppb.Timestamp <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.CreatedAt
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (x *User) GetUpdatedAt() *timestamppb.Timestamp <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.UpdatedAt
        }</span>
        <span class="cov0" title="0">return nil</span>
}

// Role represents a role in the RBAC system
type Role struct {
        state         protoimpl.MessageState
        sizeCache     protoimpl.SizeCache
        unknownFields protoimpl.UnknownFields

        Id          string                 `protobuf:"bytes,1,opt,name=id,proto3" json:"id,omitempty"`
        Name        string                 `protobuf:"bytes,2,opt,name=name,proto3" json:"name,omitempty"`
        Permissions []string               `protobuf:"bytes,3,rep,name=permissions,proto3" json:"permissions,omitempty"`
        CreatedAt   *timestamppb.Timestamp `protobuf:"bytes,4,opt,name=created_at,json=createdAt,proto3" json:"created_at,omitempty"`
        UpdatedAt   *timestamppb.Timestamp `protobuf:"bytes,5,opt,name=updated_at,json=updatedAt,proto3" json:"updated_at,omitempty"`
}

func (x *Role) Reset() <span class="cov0" title="0">{
        *x = Role{}
        if protoimpl.UnsafeEnabled </span><span class="cov0" title="0">{
                mi := &amp;file_common_proto_msgTypes[1]
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                ms.StoreMessageInfo(mi)
        }</span>
}

func (x *Role) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*Role) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *Role) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_common_proto_msgTypes[1]
        if protoimpl.UnsafeEnabled &amp;&amp; x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use Role.ProtoReflect.Descriptor instead.
func (*Role) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_common_proto_rawDescGZIP(), []int{1}
}</span>

func (x *Role) GetId() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Id
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *Role) GetName() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Name
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *Role) GetPermissions() []string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Permissions
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (x *Role) GetCreatedAt() *timestamppb.Timestamp <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.CreatedAt
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (x *Role) GetUpdatedAt() *timestamppb.Timestamp <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.UpdatedAt
        }</span>
        <span class="cov0" title="0">return nil</span>
}

// Permission represents a single permission
type Permission struct {
        state         protoimpl.MessageState
        sizeCache     protoimpl.SizeCache
        unknownFields protoimpl.UnknownFields

        Resource string `protobuf:"bytes,1,opt,name=resource,proto3" json:"resource,omitempty"`
        Action   string `protobuf:"bytes,2,opt,name=action,proto3" json:"action,omitempty"`
}

func (x *Permission) Reset() <span class="cov0" title="0">{
        *x = Permission{}
        if protoimpl.UnsafeEnabled </span><span class="cov0" title="0">{
                mi := &amp;file_common_proto_msgTypes[2]
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                ms.StoreMessageInfo(mi)
        }</span>
}

func (x *Permission) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*Permission) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *Permission) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_common_proto_msgTypes[2]
        if protoimpl.UnsafeEnabled &amp;&amp; x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use Permission.ProtoReflect.Descriptor instead.
func (*Permission) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_common_proto_rawDescGZIP(), []int{2}
}</span>

func (x *Permission) GetResource() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Resource
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *Permission) GetAction() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Action
        }</span>
        <span class="cov0" title="0">return ""</span>
}

// Error represents an error response
type Error struct {
        state         protoimpl.MessageState
        sizeCache     protoimpl.SizeCache
        unknownFields protoimpl.UnknownFields

        Code    string `protobuf:"bytes,1,opt,name=code,proto3" json:"code,omitempty"`
        Message string `protobuf:"bytes,2,opt,name=message,proto3" json:"message,omitempty"`
}

func (x *Error) Reset() <span class="cov0" title="0">{
        *x = Error{}
        if protoimpl.UnsafeEnabled </span><span class="cov0" title="0">{
                mi := &amp;file_common_proto_msgTypes[3]
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                ms.StoreMessageInfo(mi)
        }</span>
}

func (x *Error) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*Error) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *Error) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_common_proto_msgTypes[3]
        if protoimpl.UnsafeEnabled &amp;&amp; x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use Error.ProtoReflect.Descriptor instead.
func (*Error) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_common_proto_rawDescGZIP(), []int{3}
}</span>

func (x *Error) GetCode() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Code
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *Error) GetMessage() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Message
        }</span>
        <span class="cov0" title="0">return ""</span>
}

var File_common_proto protoreflect.FileDescriptor

var file_common_proto_rawDesc = []byte{
        0x0a, 0x0c, 0x63, 0x6f, 0x6d, 0x6d, 0x6f, 0x6e, 0x2e, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x12, 0x0e,
        0x64, 0x61, 0x74, 0x61, 0x76, 0x69, 0x6e, 0x63, 0x69, 0x2e, 0x61, 0x75, 0x74, 0x68, 0x1a, 0x1f,
        0x67, 0x6f, 0x6f, 0x67, 0x6c, 0x65, 0x2f, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x62, 0x75, 0x66, 0x2f,
        0x74, 0x69, 0x6d, 0x65, 0x73, 0x74, 0x61, 0x6d, 0x70, 0x2e, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x22,
        0xd4, 0x01, 0x0a, 0x04, 0x55, 0x73, 0x65, 0x72, 0x12, 0x0e, 0x0a, 0x02, 0x69, 0x64, 0x18, 0x01,
        0x20, 0x01, 0x28, 0x09, 0x52, 0x02, 0x69, 0x64, 0x12, 0x1a, 0x0a, 0x08, 0x75, 0x73, 0x65, 0x72,
        0x6e, 0x61, 0x6d, 0x65, 0x18, 0x02, 0x20, 0x01, 0x28, 0x09, 0x52, 0x08, 0x75, 0x73, 0x65, 0x72,
        0x6e, 0x61, 0x6d, 0x65, 0x12, 0x14, 0x0a, 0x05, 0x65, 0x6d, 0x61, 0x69, 0x6c, 0x18, 0x03, 0x20,
        0x01, 0x28, 0x09, 0x52, 0x05, 0x65, 0x6d, 0x61, 0x69, 0x6c, 0x12, 0x14, 0x0a, 0x05, 0x72, 0x6f,
        0x6c, 0x65, 0x73, 0x18, 0x04, 0x20, 0x03, 0x28, 0x09, 0x52, 0x05, 0x72, 0x6f, 0x6c, 0x65, 0x73,
        0x12, 0x39, 0x0a, 0x0a, 0x63, 0x72, 0x65, 0x61, 0x74, 0x65, 0x64, 0x5f, 0x61, 0x74, 0x18, 0x05,
        0x20, 0x01, 0x28, 0x0b, 0x32, 0x1a, 0x2e, 0x67, 0x6f, 0x6f, 0x67, 0x6c, 0x65, 0x2e, 0x70, 0x72,
        0x6f, 0x74, 0x6f, 0x62, 0x75, 0x66, 0x2e, 0x54, 0x69, 0x6d, 0x65, 0x73, 0x74, 0x61, 0x6d, 0x70,
        0x52, 0x09, 0x63, 0x72, 0x65, 0x61, 0x74, 0x65, 0x64, 0x41, 0x74, 0x12, 0x39, 0x0a, 0x0a, 0x75,
        0x70, 0x64, 0x61, 0x74, 0x65, 0x64, 0x5f, 0x61, 0x74, 0x18, 0x06, 0x20, 0x01, 0x28, 0x0b, 0x32,
        0x1a, 0x2e, 0x67, 0x6f, 0x6f, 0x67, 0x6c, 0x65, 0x2e, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x62, 0x75,
        0x66, 0x2e, 0x54, 0x69, 0x6d, 0x65, 0x73, 0x74, 0x61, 0x6d, 0x70, 0x52, 0x09, 0x75, 0x70, 0x64,
        0x61, 0x74, 0x65, 0x64, 0x41, 0x74, 0x22, 0xc2, 0x01, 0x0a, 0x04, 0x52, 0x6f, 0x6c, 0x65, 0x12,
        0x0e, 0x0a, 0x02, 0x69, 0x64, 0x18, 0x01, 0x20, 0x01, 0x28, 0x09, 0x52, 0x02, 0x69, 0x64, 0x12,
        0x12, 0x0a, 0x04, 0x6e, 0x61, 0x6d, 0x65, 0x18, 0x02, 0x20, 0x01, 0x28, 0x09, 0x52, 0x04, 0x6e,
        0x61, 0x6d, 0x65, 0x12, 0x20, 0x0a, 0x0b, 0x70, 0x65, 0x72, 0x6d, 0x69, 0x73, 0x73, 0x69, 0x6f,
        0x6e, 0x73, 0x18, 0x03, 0x20, 0x03, 0x28, 0x09, 0x52, 0x0b, 0x70, 0x65, 0x72, 0x6d, 0x69, 0x73,
        0x73, 0x69, 0x6f, 0x6e, 0x73, 0x12, 0x39, 0x0a, 0x0a, 0x63, 0x72, 0x65, 0x61, 0x74, 0x65, 0x64,
        0x5f, 0x61, 0x74, 0x18, 0x04, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x1a, 0x2e, 0x67, 0x6f, 0x6f, 0x67,
        0x6c, 0x65, 0x2e, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x62, 0x75, 0x66, 0x2e, 0x54, 0x69, 0x6d, 0x65,
        0x73, 0x74, 0x61, 0x6d, 0x70, 0x52, 0x09, 0x63, 0x72, 0x65, 0x61, 0x74, 0x65, 0x64, 0x41, 0x74,
        0x12, 0x39, 0x0a, 0x0a, 0x75, 0x70, 0x64, 0x61, 0x74, 0x65, 0x64, 0x5f, 0x61, 0x74, 0x18, 0x05,
        0x20, 0x01, 0x28, 0x0b, 0x32, 0x1a, 0x2e, 0x67, 0x6f, 0x6f, 0x67, 0x6c, 0x65, 0x2e, 0x70, 0x72,
        0x6f, 0x74, 0x6f, 0x62, 0x75, 0x66, 0x2e, 0x54, 0x69, 0x6d, 0x65, 0x73, 0x74, 0x61, 0x6d, 0x70,
        0x52, 0x09, 0x75, 0x70, 0x64, 0x61, 0x74, 0x65, 0x64, 0x41, 0x74, 0x22, 0x40, 0x0a, 0x0a, 0x50,
        0x65, 0x72, 0x6d, 0x69, 0x73, 0x73, 0x69, 0x6f, 0x6e, 0x12, 0x1a, 0x0a, 0x08, 0x72, 0x65, 0x73,
        0x6f, 0x75, 0x72, 0x63, 0x65, 0x18, 0x01, 0x20, 0x01, 0x28, 0x09, 0x52, 0x08, 0x72, 0x65, 0x73,
        0x6f, 0x75, 0x72, 0x63, 0x65, 0x12, 0x16, 0x0a, 0x06, 0x61, 0x63, 0x74, 0x69, 0x6f, 0x6e, 0x18,
        0x02, 0x20, 0x01, 0x28, 0x09, 0x52, 0x06, 0x61, 0x63, 0x74, 0x69, 0x6f, 0x6e, 0x22, 0x35, 0x0a,
        0x05, 0x45, 0x72, 0x72, 0x6f, 0x72, 0x12, 0x12, 0x0a, 0x04, 0x63, 0x6f, 0x64, 0x65, 0x18, 0x01,
        0x20, 0x01, 0x28, 0x09, 0x52, 0x04, 0x63, 0x6f, 0x64, 0x65, 0x12, 0x18, 0x0a, 0x07, 0x6d, 0x65,
        0x73, 0x73, 0x61, 0x67, 0x65, 0x18, 0x02, 0x20, 0x01, 0x28, 0x09, 0x52, 0x07, 0x6d, 0x65, 0x73,
        0x73, 0x61, 0x67, 0x65, 0x42, 0x1e, 0x5a, 0x1c, 0x64, 0x61, 0x74, 0x61, 0x76, 0x69, 0x6e, 0x63,
        0x69, 0x2f, 0x69, 0x6e, 0x74, 0x65, 0x72, 0x6e, 0x61, 0x6c, 0x2f, 0x61, 0x75, 0x74, 0x68, 0x2f,
        0x67, 0x72, 0x70, 0x63, 0x62, 0x06, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x33,
}

var (
        file_common_proto_rawDescOnce sync.Once
        file_common_proto_rawDescData = file_common_proto_rawDesc
)

func file_common_proto_rawDescGZIP() []byte <span class="cov0" title="0">{
        file_common_proto_rawDescOnce.Do(func() </span><span class="cov0" title="0">{
                file_common_proto_rawDescData = protoimpl.X.CompressGZIP(file_common_proto_rawDescData)
        }</span>)
        <span class="cov0" title="0">return file_common_proto_rawDescData</span>
}

var file_common_proto_msgTypes = make([]protoimpl.MessageInfo, 4)
var file_common_proto_goTypes = []any{
        (*User)(nil),                  // 0: datavinci.auth.User
        (*Role)(nil),                  // 1: datavinci.auth.Role
        (*Permission)(nil),            // 2: datavinci.auth.Permission
        (*Error)(nil),                 // 3: datavinci.auth.Error
        (*timestamppb.Timestamp)(nil), // 4: google.protobuf.Timestamp
}
var file_common_proto_depIdxs = []int32{
        4, // 0: datavinci.auth.User.created_at:type_name -&gt; google.protobuf.Timestamp
        4, // 1: datavinci.auth.User.updated_at:type_name -&gt; google.protobuf.Timestamp
        4, // 2: datavinci.auth.Role.created_at:type_name -&gt; google.protobuf.Timestamp
        4, // 3: datavinci.auth.Role.updated_at:type_name -&gt; google.protobuf.Timestamp
        4, // [4:4] is the sub-list for method output_type
        4, // [4:4] is the sub-list for method input_type
        4, // [4:4] is the sub-list for extension type_name
        4, // [4:4] is the sub-list for extension extendee
        0, // [0:4] is the sub-list for field type_name
}

func init() <span class="cov0" title="0">{ file_common_proto_init() }</span>
func file_common_proto_init() <span class="cov0" title="0">{
        if File_common_proto != nil </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov0" title="0">if !protoimpl.UnsafeEnabled </span><span class="cov0" title="0">{
                file_common_proto_msgTypes[0].Exporter = func(v any, i int) any </span><span class="cov0" title="0">{
                        switch v := v.(*User); i </span>{
                        case 0:<span class="cov0" title="0">
                                return &amp;v.state</span>
                        case 1:<span class="cov0" title="0">
                                return &amp;v.sizeCache</span>
                        case 2:<span class="cov0" title="0">
                                return &amp;v.unknownFields</span>
                        default:<span class="cov0" title="0">
                                return nil</span>
                        }
                }
                <span class="cov0" title="0">file_common_proto_msgTypes[1].Exporter = func(v any, i int) any </span><span class="cov0" title="0">{
                        switch v := v.(*Role); i </span>{
                        case 0:<span class="cov0" title="0">
                                return &amp;v.state</span>
                        case 1:<span class="cov0" title="0">
                                return &amp;v.sizeCache</span>
                        case 2:<span class="cov0" title="0">
                                return &amp;v.unknownFields</span>
                        default:<span class="cov0" title="0">
                                return nil</span>
                        }
                }
                <span class="cov0" title="0">file_common_proto_msgTypes[2].Exporter = func(v any, i int) any </span><span class="cov0" title="0">{
                        switch v := v.(*Permission); i </span>{
                        case 0:<span class="cov0" title="0">
                                return &amp;v.state</span>
                        case 1:<span class="cov0" title="0">
                                return &amp;v.sizeCache</span>
                        case 2:<span class="cov0" title="0">
                                return &amp;v.unknownFields</span>
                        default:<span class="cov0" title="0">
                                return nil</span>
                        }
                }
                <span class="cov0" title="0">file_common_proto_msgTypes[3].Exporter = func(v any, i int) any </span><span class="cov0" title="0">{
                        switch v := v.(*Error); i </span>{
                        case 0:<span class="cov0" title="0">
                                return &amp;v.state</span>
                        case 1:<span class="cov0" title="0">
                                return &amp;v.sizeCache</span>
                        case 2:<span class="cov0" title="0">
                                return &amp;v.unknownFields</span>
                        default:<span class="cov0" title="0">
                                return nil</span>
                        }
                }
        }
        <span class="cov0" title="0">type x struct{}
        out := protoimpl.TypeBuilder{
                File: protoimpl.DescBuilder{
                        GoPackagePath: reflect.TypeOf(x{}).PkgPath(),
                        RawDescriptor: file_common_proto_rawDesc,
                        NumEnums:      0,
                        NumMessages:   4,
                        NumExtensions: 0,
                        NumServices:   0,
                },
                GoTypes:           file_common_proto_goTypes,
                DependencyIndexes: file_common_proto_depIdxs,
                MessageInfos:      file_common_proto_msgTypes,
        }.Build()
        File_common_proto = out.File
        file_common_proto_rawDesc = nil
        file_common_proto_goTypes = nil
        file_common_proto_depIdxs = nil</span>
}
</pre>
		
		<pre class="file" id="file49" style="display: none">package pkg

import (
        "math/rand"
        "sync"
        "time"

        "golang.org/x/time/rate"
)

// PerIPRateLimiter is a helper struct for per-IP rate limiting.
// It uses a map to store rate limiters for each IP address.
// The rate limiter is created on the first request from an IP address.
type PerIPRateLimiter struct {
        ips map[string]*rate.Limiter
        mu  *sync.RWMutex
        r   rate.Limit
        b   int
}

// NewPerIPRateLimiter creates a new PerIPRateLimiter.
// The rate is the maximum number of requests per second.
// The burst is the maximum number of requests that can be made in a short burst.
// Parameters:
//   - r: The rate limit.
//   - b: The burst limit.
//
// Usage:
//
//        limiter := NewPerIPRateLimiter(10, 5)
func NewPerIPRateLimiter(r rate.Limit, b int) *PerIPRateLimiter <span class="cov3" title="7">{
        rand.New(rand.NewSource(time.Now().UnixNano()))
        return &amp;PerIPRateLimiter{
                ips: make(map[string]*rate.Limiter),
                mu:  &amp;sync.RWMutex{},
                r:   r,
                b:   b,
        }
}</span>

// AddIP adds an IP address to the rate limiter.
// If the IP address already exists, it returns the existing rate limiter.
// Otherwise, it creates a new rate limiter with a small random variation to the rate.
// Parameters:
//   - ip: The IP address to add.
//
// Returns:
//   - The rate limiter for the IP address.
//
// Usage:
//
//        limiter.AddIP("126.0.0.1")
func (l *PerIPRateLimiter) AddIP(ip string) *rate.Limiter <span class="cov4" title="11">{
        l.mu.Lock()
        defer l.mu.Unlock()

        limiter, exists := l.ips[ip]
        if !exists </span><span class="cov4" title="11">{
                // Add a small random variation to the rate
                adjustedRate := l.r + rate.Limit(rand.Float64()*0.1*float64(l.r))
                limiter = rate.NewLimiter(adjustedRate, l.b)
                l.ips[ip] = limiter
        }</span>

        <span class="cov4" title="11">return limiter</span>
}

// GetLimiter returns the rate limiter for the given IP address.
// If the IP address does not exist, it creates a new rate limiter.
// Parameters:
//   - ip: The IP address to get the rate limiter for.
//
// Returns:
//   - The rate limiter for the IP address.
//
// Usage:
//
//        limiter.GetLimiter("126.0.0.1")
func (l *PerIPRateLimiter) GetLimiter(ip string) *rate.Limiter <span class="cov10" title="506">{
        l.mu.RLock()
        limiter, exists := l.ips[ip]
        l.mu.RUnlock()

        if !exists </span><span class="cov4" title="10">{
                return l.AddIP(ip)
        }</span>

        <span class="cov9" title="496">return limiter</span>
}
</pre>
		
		<pre class="file" id="file50" style="display: none">package pkg

import (
        "pkg/common/errors"

        "golang.org/x/crypto/bcrypt"
)

// PasswordHasher is a helper struct for hashing and verifying passwords.
type PasswordHasher struct {
        cost int
}

// NewPasswordHasher creates a new PasswordHasher.
//
// Parameters:
//   - cost: The cost of the bcrypt algorithm (default is 10).
//
// Usage:
//
//        hasher := NewPasswordHasher(12)
func NewPasswordHasher(cost int) *PasswordHasher <span class="cov10" title="8">{
        if cost &lt;= 0 </span><span class="cov4" title="2">{
                cost = 10
        }</span>
        <span class="cov10" title="8">return &amp;PasswordHasher{cost: cost}</span>
}

// HashPassword hashes a password using bcrypt.
//
// Parameters:
//   - password: The password to hash.
//
// Returns:
//   - The hashed password and an error if hashing fails.
//
// Usage:
//
//        hashedPassword, err := hasher.HashPassword("myPassword123")
func (ph *PasswordHasher) HashPassword(password string) (string, error) <span class="cov10" title="8">{
        if password == "" </span><span class="cov1" title="1">{
                return "", errors.NewError(errors.ErrorTypeEmptyPassword, "Password cannot be empty", nil)
        }</span>
        <span class="cov9" title="7">if ph.cost &lt; bcrypt.MinCost || ph.cost &gt; bcrypt.MaxCost </span><span class="cov1" title="1">{
                return "", errors.NewError(errors.ErrorTypeInvalidCost, "Invalid bcrypt cost", nil)
        }</span>
        <span class="cov8" title="6">bytes, err := bcrypt.GenerateFromPassword([]byte(password), ph.cost)
        return string(bytes), err</span>
}

// VerifyPassword verifies a password against a hashed password.
//
// Parameters:
//   - hashedPassword: The hashed password.
//   - password: The password to verify.
//
// Returns:
//   - True if the password matches the hashed password, false otherwise.
//
// Usage:
//
//        valid, err := hasher.VerifyPassword(hashedPassword, "myPassword123")
func (ph *PasswordHasher) VerifyPassword(hashedPassword, password string) (bool, error) <span class="cov5" title="3">{
        if hashedPassword == "" </span><span class="cov0" title="0">{
                return false, errors.NewError(errors.ErrorTypeEmptyPassword, "Hashed password cannot be empty", nil)
        }</span>
        <span class="cov5" title="3">if password == "" </span><span class="cov1" title="1">{
                return false, errors.NewError(errors.ErrorTypeEmptyPassword, "Password cannot be empty", nil)
        }</span>
        <span class="cov4" title="2">err := bcrypt.CompareHashAndPassword([]byte(hashedPassword), []byte(password))
        if err != nil </span><span class="cov1" title="1">{
                if err == bcrypt.ErrMismatchedHashAndPassword </span><span class="cov1" title="1">{
                        return false, nil
                }</span>
                <span class="cov0" title="0">return false, err</span>
        }
        <span class="cov1" title="1">return true, nil</span>
}
</pre>
		
		<pre class="file" id="file51" style="display: none">package pkg

import (
        "time"

        "github.com/golang-jwt/jwt"
)

// TokenGenerator is a helper struct for generating JWT tokens.
type TokenGenerator struct {
        secretKey []byte
        issuer    string
        duration  time.Duration
}

// NewTokenGenerator creates a new TokenGenerator.
func NewTokenGenerator(secretKey []byte, issuer string, duration time.Duration) *TokenGenerator <span class="cov5" title="2">{
        return &amp;TokenGenerator{
                secretKey: secretKey,
                issuer:    issuer,
                duration:  duration,
        }
}</span>

// GenerateToken generates a new JWT token with the given claims.
func (g *TokenGenerator) GenerateToken(claims jwt.MapClaims) (string, error) <span class="cov10" title="4">{
        if claims == nil </span><span class="cov1" title="1">{
                claims = jwt.MapClaims{}
        }</span>
        <span class="cov10" title="4">now := time.Now()
        claims["iss"] = g.issuer
        claims["iat"] = now.Unix()
        claims["exp"] = now.Add(g.duration).Unix()
        token := jwt.NewWithClaims(jwt.SigningMethodHS256, claims)
        return token.SignedString(g.secretKey)</span>
}
</pre>
		
		<pre class="file" id="file52" style="display: none">package main

import (
        "fmt"
        "log"
        "net"

        "google.golang.org/grpc"

        pb "datasource/grpc"

        "google.golang.org/grpc/reflection"

        "datasource/grpc/server"
        manager "datasource/managers"
)

type ServerConfig struct {
        Port int
}

func SetupAndServe(config ServerConfig) error <span class="cov0" title="0">{
        address := fmt.Sprintf(":%d", config.Port)
        lis, err := net.Listen("tcp", address)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to listen: %v", err)
        }</span>

        <span class="cov0" title="0">connManager := manager.NewConnectorManager()
        server := server.NewDataSourceServer(connManager)

        s := grpc.NewServer()
        pb.RegisterDataSourceServiceServer(s, server)

        // Register reflection service on gRPC server.
        reflection.Register(s)

        log.Printf("Starting DataSource gRPC server on %s", address)
        if err := s.Serve(lis); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to serve: %v", err)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

func main() <span class="cov0" title="0">{
        config := ServerConfig{
                Port: 50051,
        }

        if err := SetupAndServe(config); err != nil </span><span class="cov0" title="0">{
                log.Fatalf("Failed to serve: %v", err)
        }</span>
}
</pre>
		
		<pre class="file" id="file53" style="display: none">// Package connectors provides implementations for various data source connectors.
package connectors

import (
        "context"
        "encoding/json"
        "fmt"
        "io"
        "log"
        "net/http"
        "sync"
        "time"

        "pkg/common/errors"
        "pkg/common/retry"

        "github.com/gorilla/websocket"
)

// APIConnector implements the Connector interface for API data sources.
// It supports both RESTful HTTP APIs and WebSocket connections, as well as periodic polling.
type APIConnector struct {
        client            *http.Client
        config            *Config
        baseURL           string
        wsConn            *websocket.Conn
        wsBuffer          chan []byte
        pollingTicker     *time.Ticker
        stopPolling       chan struct{}
        wsLock            sync.Mutex
        reconnectBackoff  time.Duration
        maxReconnectWait  time.Duration
        stopReadWebSocket chan struct{}
}

// NewAPIConnector creates a new APIConnector with the given configuration.
//
// The config parameter should include:
//   - BaseURL: The base URL for the API
//   - TimeoutSeconds: Timeout for HTTP requests and WebSocket connection
//   - IsWebSocket: Set to true for WebSocket connections
//   - WebSocketBufferSize: Buffer size for WebSocket messages
//   - PollingIntervalSeconds: Interval for periodic polling (if &gt; 0)
//
// Example:
//
//        config := &amp;Config{
//            BaseURL:                "https://api.example.com",
//            TimeoutSeconds:         30,
//            IsWebSocket:            false,
//            PollingIntervalSeconds: 60,
//        }
//        connector := NewAPIConnector(config)
func NewAPIConnector(config *Config) *APIConnector <span class="cov0" title="0">{
        return &amp;APIConnector{
                config: config,
                client: &amp;http.Client{
                        Timeout: time.Duration(config.TimeoutSeconds) * time.Second,
                },
                baseURL:           config.BaseURL,
                wsBuffer:          make(chan []byte, config.WebSocketBufferSize),
                stopPolling:       make(chan struct{}),
                reconnectBackoff:  time.Second,
                maxReconnectWait:  2 * time.Minute,
                stopReadWebSocket: make(chan struct{}),
        }
}</span>

// Connect initializes the API connector.
// For WebSocket connections, it establishes the connection.
// For polling configurations, it starts the polling routine.
//
// Example:
//
//        ctx := context.Background()
//        err := connector.Connect(ctx)
//        if err != nil {
//            log.Fatalf("Failed to connect: %v", err)
//        }
func (c *APIConnector) Connect(ctx context.Context) error <span class="cov0" title="0">{
        if c.baseURL == "" </span><span class="cov0" title="0">{
                return errors.NewError(errors.ErrorTypeConfiguration, "base URL is required for API connector", nil)
        }</span>

        <span class="cov0" title="0">if c.config.IsWebSocket </span><span class="cov0" title="0">{
                return c.connectWebSocket(ctx)
        }</span>

        <span class="cov0" title="0">if c.config.PollingIntervalSeconds &gt; 0 </span><span class="cov0" title="0">{
                c.startPolling(ctx)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// Close closes the WebSocket connection or stops the polling routine.
// It should be called when the connector is no longer needed to free up resources.
//
// Example:
//
//        ctx := context.Background()
//        err := connector.Close(ctx)
//        if err != nil {
//            log.Printf("Error closing connector: %v", err)
//        }
func (c *APIConnector) Close(ctx context.Context) error <span class="cov0" title="0">{
        if c.wsConn != nil </span><span class="cov0" title="0">{
                c.stopReadWebSocket &lt;- struct{}{}
                err := c.wsConn.Close()
                c.wsConn = nil
                return err
        }</span>

        <span class="cov0" title="0">if c.pollingTicker != nil </span><span class="cov0" title="0">{
                c.stopPolling &lt;- struct{}{}
                c.pollingTicker.Stop()
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// Query executes a request to the API and returns the results.
// For WebSocket connections, it returns the latest message from the WebSocket.
// For HTTP connections, it sends a GET request to the specified endpoint.
//
// The query parameter is appended to the base URL for HTTP requests.
// For WebSocket connections, the query parameter is ignored.
//
// Example:
//
//        ctx := context.Background()
//        results, err := connector.Query(ctx, "/users")
//        if err != nil {
//            log.Printf("Query failed: %v", err)
//        } else {
//            for _, user := range results {
//                fmt.Printf("User: %v\n", user)
//            }
//        }
func (c *APIConnector) Query(ctx context.Context, query string, args ...interface{}) ([]map[string]interface{}, error) <span class="cov0" title="0">{
        if c.config.IsWebSocket </span><span class="cov0" title="0">{
                return c.queryWebSocket(ctx)
        }</span>

        <span class="cov0" title="0">return c.queryHTTP(ctx, query)</span>
}

// connectWebSocket establishes a WebSocket connection to the API.
func (c *APIConnector) connectWebSocket(ctx context.Context) error <span class="cov0" title="0">{
        dialer := websocket.Dialer{
                HandshakeTimeout: time.Duration(c.config.TimeoutSeconds) * time.Second,
        }

        conn, _, err := dialer.DialContext(ctx, c.baseURL, nil)
        if err != nil </span><span class="cov0" title="0">{
                return errors.NewError(errors.ErrorTypeAPIConnection, "failed to connect to WebSocket", err)
        }</span>

        <span class="cov0" title="0">c.wsConn = conn
        return nil</span>
}

// readWebSocket continuously reads messages from the WebSocket connection
// and sends them to the wsBuffer channel.
func (c *APIConnector) readWebSocket() <span class="cov0" title="0">{
        defer func() </span><span class="cov0" title="0">{
                close(c.wsBuffer)
                close(c.stopReadWebSocket)
        }</span>()

        <span class="cov0" title="0">for </span><span class="cov0" title="0">{
                _, message, err := c.wsConn.ReadMessage()
                if err != nil </span><span class="cov0" title="0">{
                        select </span>{
                        case &lt;-c.stopReadWebSocket:<span class="cov0" title="0">
                                return</span>
                        default:<span class="cov0" title="0">
                                log.Printf("WebSocket read error: %v", err)
                                if err := c.reconnectWebSocket(); err != nil </span><span class="cov0" title="0">{
                                        log.Printf("Failed to reconnect WebSocket: %v", err)
                                        return
                                }</span>
                                <span class="cov0" title="0">continue</span>
                        }
                }
                <span class="cov0" title="0">c.wsBuffer &lt;- message</span>
        }
}

// reconnectWebSocket attempts to reconnect the WebSocket with exponential backoff
func (c *APIConnector) reconnectWebSocket() error <span class="cov0" title="0">{
        c.wsLock.Lock()
        defer c.wsLock.Unlock()

        backoff := c.reconnectBackoff
        for </span><span class="cov0" title="0">{
                log.Printf("Attempting to reconnect WebSocket in %v", backoff)
                time.Sleep(backoff)

                if err := c.connectWebSocket(context.Background()); err == nil </span><span class="cov0" title="0">{
                        log.Println("Successfully reconnected WebSocket")
                        c.reconnectBackoff = time.Second // Reset backoff on successful connection
                        return nil
                }</span>

                <span class="cov0" title="0">backoff *= 2
                if backoff &gt; c.maxReconnectWait </span><span class="cov0" title="0">{
                        backoff = c.maxReconnectWait
                }</span>
        }
}

// queryWebSocket returns the latest message received from the WebSocket connection.
func (c *APIConnector) queryWebSocket(ctx context.Context) ([]map[string]interface{}, error) <span class="cov0" title="0">{
        select </span>{
        case message := &lt;-c.wsBuffer:<span class="cov0" title="0">
                var result []map[string]interface{}
                err := json.Unmarshal(message, &amp;result)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, errors.NewError(errors.ErrorTypeQuery, "failed to unmarshal WebSocket message", err)
                }</span>
                <span class="cov0" title="0">return result, nil</span>
        case &lt;-ctx.Done():<span class="cov0" title="0">
                return nil, errors.NewError(errors.ErrorTypeQuery, "context cancelled while waiting for WebSocket message", ctx.Err())</span>
        }
}

// queryHTTP sends an HTTP GET request to the API and returns the results.
// It uses the custom retry mechanism to handle transient errors.
func (c *APIConnector) queryHTTP(ctx context.Context, query string) ([]map[string]interface{}, error) <span class="cov0" title="0">{
        url := fmt.Sprintf("%s%s", c.baseURL, query)

        var result []map[string]interface{}
        err := retry.Retry(ctx, func() error </span><span class="cov0" title="0">{
                req, err := http.NewRequestWithContext(ctx, "GET", url, nil)
                if err != nil </span><span class="cov0" title="0">{
                        return errors.NewError(errors.ErrorTypeQuery, "failed to create request", err)
                }</span>

                <span class="cov0" title="0">resp, err := c.client.Do(req)
                if err != nil </span><span class="cov0" title="0">{
                        return errors.NewError(errors.ErrorTypeQuery, "failed to execute request", err)
                }</span>
                <span class="cov0" title="0">defer resp.Body.Close()

                if resp.StatusCode != http.StatusOK </span><span class="cov0" title="0">{
                        return errors.NewError(errors.ErrorTypeQuery, fmt.Sprintf("API returned non-OK status: %d", resp.StatusCode), nil)
                }</span>

                <span class="cov0" title="0">body, err := io.ReadAll(resp.Body)
                if err != nil </span><span class="cov0" title="0">{
                        return errors.NewError(errors.ErrorTypeQuery, "failed to read response body", err)
                }</span>

                <span class="cov0" title="0">err = json.Unmarshal(body, &amp;result)
                if err != nil </span><span class="cov0" title="0">{
                        return errors.NewError(errors.ErrorTypeQuery, "failed to unmarshal response", err)
                }</span>

                <span class="cov0" title="0">return nil</span>
        }, retry.DefaultConfig())

        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">return result, nil</span>
}

// startPolling begins a periodic polling routine that calls the API at regular intervals.
func (c *APIConnector) startPolling(ctx context.Context) <span class="cov0" title="0">{
        c.pollingTicker = time.NewTicker(time.Duration(c.config.PollingIntervalSeconds) * time.Second)

        go func() </span><span class="cov0" title="0">{
                for </span><span class="cov0" title="0">{
                        select </span>{
                        case &lt;-c.pollingTicker.C:<span class="cov0" title="0">
                                _, err := c.queryHTTP(ctx, "")
                                if err != nil </span><span class="cov0" title="0">{
                                        log.Printf("Polling error: %v", err)
                                }</span>
                        case &lt;-c.stopPolling:<span class="cov0" title="0">
                                return</span>
                        }
                }
        }()
}

// Execute sends a POST request to the API and returns the number of affected items.
// It uses the custom retry mechanism to handle transient errors.
//
// Example:
//
//        ctx := context.Background()
//        affected, err := connector.Execute(ctx, "/users/create", user)
//        if err != nil {
//            log.Printf("Failed to create user: %v", err)
//        } else {
//            fmt.Printf("Created %d user(s)\n", affected)
//        }
func (c *APIConnector) Execute(ctx context.Context, command string, args ...interface{}) (int64, error) <span class="cov0" title="0">{
        url := fmt.Sprintf("%s%s", c.baseURL, command)

        var result struct {
                AffectedItems int64 `json:"affectedItems"`
        }

        err := retry.Retry(ctx, func() error </span><span class="cov0" title="0">{
                req, err := http.NewRequestWithContext(ctx, "POST", url, nil)
                if err != nil </span><span class="cov0" title="0">{
                        return errors.NewError(errors.ErrorTypeExecution, "failed to create request", err)
                }</span>

                <span class="cov0" title="0">resp, err := c.client.Do(req)
                if err != nil </span><span class="cov0" title="0">{
                        return errors.NewError(errors.ErrorTypeExecution, "failed to execute request", err)
                }</span>
                <span class="cov0" title="0">defer resp.Body.Close()

                if resp.StatusCode != http.StatusOK </span><span class="cov0" title="0">{
                        return errors.NewError(errors.ErrorTypeExecution, fmt.Sprintf("API returned non-OK status: %d", resp.StatusCode), nil)
                }</span>

                <span class="cov0" title="0">body, err := io.ReadAll(resp.Body)
                if err != nil </span><span class="cov0" title="0">{
                        return errors.NewError(errors.ErrorTypeExecution, "failed to read response body", err)
                }</span>

                <span class="cov0" title="0">err = json.Unmarshal(body, &amp;result)
                if err != nil </span><span class="cov0" title="0">{
                        return errors.NewError(errors.ErrorTypeExecution, "failed to unmarshal response", err)
                }</span>

                <span class="cov0" title="0">return nil</span>
        }, retry.DefaultConfig())

        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                return 0, err
        }</span>

        <span class="cov0" title="0">return result.AffectedItems, nil</span>
}

// Ping checks if the API is accessible.
// For WebSocket connections, it checks if the connection is established.
// For HTTP connections, it sends a GET request to the /ping endpoint.
//
// Example:
//
//        ctx := context.Background()
//        err := connector.Ping(ctx)
//        if err != nil {
//            log.Printf("API is not accessible: %v", err)
//        } else {
//            fmt.Println("API is accessible")
//        }
func (c *APIConnector) Ping(ctx context.Context) error <span class="cov0" title="0">{
        if c.config.IsWebSocket </span><span class="cov0" title="0">{
                if c.wsConn == nil </span><span class="cov0" title="0">{
                        return errors.NewError(errors.ErrorTypeAPIConnection, "WebSocket connection not established", nil)
                }</span>
                <span class="cov0" title="0">return nil</span>
        }

        <span class="cov0" title="0">_, err := c.queryHTTP(ctx, "/ping")
        return err</span>
}

// Transaction is not supported for API connector.
// It always returns an error indicating that transactions are not supported.
func (c *APIConnector) Transaction(ctx context.Context) (TransactionConnector, error) <span class="cov0" title="0">{
        return nil, errors.NewError(errors.ErrorTypeUnsupported, "transactions are not supported for API connector", nil)
}</span>
</pre>
		
		<pre class="file" id="file54" style="display: none">package connectors

import (
        "fmt"
)

// ConnectorFactory creates and returns a Connector based on the provided Config.
func ConnectorFactory(config *Config) (Connector, error) <span class="cov0" title="0">{
        switch config.Type </span>{
        case "sql":<span class="cov0" title="0">
                return NewSQLConnector(config), nil</span>
        case "redis":<span class="cov0" title="0">
                return NewRedisConnector(config), nil</span>
        case "mongo":<span class="cov0" title="0">
                return NewMongoConnector(config), nil</span>
        case "api":<span class="cov0" title="0">
                return NewAPIConnector(config), nil</span>
        case "file":<span class="cov0" title="0">
                return NewFileConnector(config), nil</span>
        default:<span class="cov0" title="0">
                return nil, fmt.Errorf("unsupported connector type: %s", config.Type)</span>
        }
}
</pre>
		
		<pre class="file" id="file55" style="display: none">// Package connectors provides various data source connectors for the DataVinci project.
package connectors

import (
        "context"
        "encoding/csv"
        "encoding/json"
        "fmt"
        "os"
        "path/filepath"

        "pkg/common/errors"
)

// FileConnector implements the Connector interface for file-based data sources.
// It supports reading data from JSON and CSV files.
type FileConnector struct {
        config   *Config
        basePath string
}

// NewFileConnector creates a new FileConnector with the given configuration.
//
// The config parameter should include:
//   - BasePath: The base directory path where the files are located
//
// Example:
//
//        config := &amp;Config{
//            BasePath: "/path/to/data/files",
//        }
//        connector := NewFileConnector(config)
func NewFileConnector(config *Config) *FileConnector <span class="cov0" title="0">{
        return &amp;FileConnector{
                config:   config,
                basePath: config.BasePath,
        }
}</span>

// Connect validates the base path for the file connector.
// It ensures that the specified base path exists and is accessible.
//
// Example:
//
//        ctx := context.Background()
//        err := connector.Connect(ctx)
//        if err != nil {
//            log.Fatalf("Failed to connect: %v", err)
//        }
func (c *FileConnector) Connect(ctx context.Context) error <span class="cov0" title="0">{
        if c.basePath == "" </span><span class="cov0" title="0">{
                return errors.NewError(errors.ErrorTypeConfiguration, "base path is required for file connector", nil)
        }</span>

        // Check if the base path exists and is accessible
        <span class="cov0" title="0">_, err := os.Stat(c.basePath)
        if err != nil </span><span class="cov0" title="0">{
                return errors.NewError(errors.ErrorTypeFileConnection, "failed to access base path", err)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// Close is a no-op for file connector as there's no persistent connection to close.
// It's implemented to satisfy the Connector interface.
func (c *FileConnector) Close(ctx context.Context) error <span class="cov0" title="0">{
        return nil
}</span>

// Query reads data from a file and returns the results.
// The query parameter is treated as a relative file path from the base path.
// It supports JSON and CSV file formats.
//
// Example:
//
//        ctx := context.Background()
//        results, err := connector.Query(ctx, "users.json")
//        if err != nil {
//            log.Printf("Query failed: %v", err)
//        } else {
//            for _, user := range results {
//                fmt.Printf("User: %v\n", user)
//            }
//        }
func (c *FileConnector) Query(ctx context.Context, query string, args ...interface{}) ([]map[string]interface{}, error) <span class="cov0" title="0">{
        filePath := filepath.Join(c.basePath, query)
        ext := filepath.Ext(filePath)

        switch ext </span>{
        case ".json":<span class="cov0" title="0">
                return c.readJSONFile(filePath)</span>
        case ".csv":<span class="cov0" title="0">
                return c.readCSVFile(filePath)</span>
        default:<span class="cov0" title="0">
                return nil, errors.NewError(errors.ErrorTypeUnsupported, fmt.Sprintf("unsupported file type: %s", ext), nil)</span>
        }
}

// Execute is not supported for file connector.
// It always returns an error indicating that the operation is not supported.
func (c *FileConnector) Execute(ctx context.Context, command string, args ...interface{}) (int64, error) <span class="cov0" title="0">{
        return 0, errors.NewError(errors.ErrorTypeUnsupported, "execute operation is not supported for file connector", nil)
}</span>

// Ping checks if the base path is accessible.
// It can be used to verify that the file connector is properly configured and operational.
//
// Example:
//
//        ctx := context.Background()
//        err := connector.Ping(ctx)
//        if err != nil {
//            log.Printf("File connector is not accessible: %v", err)
//        } else {
//            fmt.Println("File connector is accessible")
//        }
func (c *FileConnector) Ping(ctx context.Context) error <span class="cov0" title="0">{
        _, err := os.Stat(c.basePath)
        if err != nil </span><span class="cov0" title="0">{
                return errors.NewError(errors.ErrorTypeFileConnection, "failed to access base path", err)
        }</span>
        <span class="cov0" title="0">return nil</span>
}

// Transaction is not supported for file connector.
// It always returns an error indicating that transactions are not supported.
func (c *FileConnector) Transaction(ctx context.Context) (TransactionConnector, error) <span class="cov0" title="0">{
        return nil, errors.NewError(errors.ErrorTypeUnsupported, "transactions are not supported for file connector", nil)
}</span>

// readJSONFile reads and parses a JSON file, returning the data as a slice of maps.
// It's used internally by the Query method for JSON files.
func (c *FileConnector) readJSONFile(filePath string) ([]map[string]interface{}, error) <span class="cov0" title="0">{
        data, err := os.ReadFile(filePath)
        if err != nil </span><span class="cov0" title="0">{
                return nil, errors.NewError(errors.ErrorTypeQuery, "failed to read JSON file", err)
        }</span>

        <span class="cov0" title="0">var result []map[string]interface{}
        err = json.Unmarshal(data, &amp;result)
        if err != nil </span><span class="cov0" title="0">{
                return nil, errors.NewError(errors.ErrorTypeQuery, "failed to unmarshal JSON data", err)
        }</span>

        <span class="cov0" title="0">return result, nil</span>
}

// readCSVFile reads and parses a CSV file, returning the data as a slice of maps.
// It's used internally by the Query method for CSV files.
// The first row of the CSV file is expected to contain headers.
func (c *FileConnector) readCSVFile(filePath string) ([]map[string]interface{}, error) <span class="cov0" title="0">{
        file, err := os.Open(filePath)
        if err != nil </span><span class="cov0" title="0">{
                return nil, errors.NewError(errors.ErrorTypeQuery, "failed to open CSV file", err)
        }</span>
        <span class="cov0" title="0">defer file.Close()

        reader := csv.NewReader(file)
        records, err := reader.ReadAll()
        if err != nil </span><span class="cov0" title="0">{
                return nil, errors.NewError(errors.ErrorTypeQuery, "failed to read CSV data", err)
        }</span>

        <span class="cov0" title="0">if len(records) == 0 </span><span class="cov0" title="0">{
                return nil, errors.NewError(errors.ErrorTypeQuery, "CSV file is empty", nil)
        }</span>

        <span class="cov0" title="0">headers := records[0]
        var result []map[string]interface{}

        for _, record := range records[1:] </span><span class="cov0" title="0">{
                row := make(map[string]interface{})
                for i, value := range record </span><span class="cov0" title="0">{
                        row[headers[i]] = value
                }</span>
                <span class="cov0" title="0">result = append(result, row)</span>
        }

        <span class="cov0" title="0">return result, nil</span>
}
</pre>
		
		<pre class="file" id="file56" style="display: none">package connectors

import (
        "context"
        "encoding/json"
        "fmt"
        "net/url"

        "pkg/common/errors"
        "pkg/common/retry"

        "log"

        "go.mongodb.org/mongo-driver/bson"
        "go.mongodb.org/mongo-driver/mongo"
        "go.mongodb.org/mongo-driver/mongo/options"
)

// MongoConnector implements the Connector interface for MongoDB.
type MongoConnector struct {
        client *mongo.Client
        config *Config
}

// NewMongoConnector creates a new MongoConnector with the given configuration.
func NewMongoConnector(config *Config) *MongoConnector <span class="cov0" title="0">{
        return &amp;MongoConnector{config: config}
}</span>

// Connect establishes a connection to the MongoDB database.
func (c *MongoConnector) Connect(ctx context.Context) error <span class="cov0" title="0">{
        uri := c.buildConnectionString()

        clientOptions := options.Client().ApplyURI(uri)

        log.Printf("Connecting to MongoDB: %s", uri)

        var client *mongo.Client
        err := retry.Retry(ctx, func() error </span><span class="cov0" title="0">{
                var err error
                client, err = mongo.Connect(ctx, clientOptions)
                if err != nil </span><span class="cov0" title="0">{
                        log.Printf("Failed to connect to MongoDB: %v", err)
                        return errors.NewError(errors.ErrorTypeConnection, "failed to connect to MongoDB", err)
                }</span>
                <span class="cov0" title="0">return client.Ping(ctx, nil)</span>
        }, retry.DefaultConfig())

        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">c.client = client
        return nil</span>
}

func (c *MongoConnector) buildConnectionString() string <span class="cov0" title="0">{
        query := url.Values{}
        for k, v := range c.config.Options </span><span class="cov0" title="0">{
                query.Add(k, fmt.Sprintf("%v", v))
        }</span>

        <span class="cov0" title="0">var baseURL string
        if c.config.Port &gt; 0 </span><span class="cov0" title="0">{
                // If port is provided, use standard MongoDB protocol
                baseURL = fmt.Sprintf("mongodb://%s:%s@%s:%d",
                        url.QueryEscape(c.config.Username),
                        url.QueryEscape(c.config.Password),
                        c.config.Host,
                        c.config.Port)
        }</span> else<span class="cov0" title="0"> {
                // If no port, assume it's MongoDB Atlas and use srv protocol
                baseURL = fmt.Sprintf("mongodb+srv://%s:%s@%s",
                        url.QueryEscape(c.config.Username),
                        url.QueryEscape(c.config.Password),
                        c.config.Host)
        }</span>

        // Append database and query parameters
        <span class="cov0" title="0">return fmt.Sprintf("%s/%s?%s", baseURL, c.config.Database, query.Encode())</span>
}

// Close closes the connection to the MongoDB database.
func (c *MongoConnector) Close(ctx context.Context) error <span class="cov0" title="0">{
        if c.client == nil </span><span class="cov0" title="0">{
                return errors.NewError(errors.ErrorTypeDatabaseConnection, "connection already closed", nil)
        }</span>
        <span class="cov0" title="0">return c.client.Disconnect(ctx)</span>
}

// Query executes a query and returns the results as a slice of maps.
func (c *MongoConnector) Query(ctx context.Context, query string, args ...interface{}) ([]map[string]interface{}, error) <span class="cov0" title="0">{
        if len(args) == 0 </span><span class="cov0" title="0">{
                return nil, errors.NewError(errors.ErrorTypeQuery, "missing collection name", nil)
        }</span>
        <span class="cov0" title="0">collection, ok := args[0].(string)
        if !ok </span><span class="cov0" title="0">{
                return nil, errors.NewError(errors.ErrorTypeQuery, "invalid collection name", nil)
        }</span>

        <span class="cov0" title="0">coll := c.client.Database(c.config.Database).Collection(collection)

        var filter bson.M
        err := json.Unmarshal([]byte(query), &amp;filter)
        if err != nil </span><span class="cov0" title="0">{
                return nil, errors.NewError(errors.ErrorTypeQuery, "failed to parse query", err)
        }</span>

        <span class="cov0" title="0">cursor, err := coll.Find(ctx, filter)
        if err != nil </span><span class="cov0" title="0">{
                return nil, errors.NewError(errors.ErrorTypeQuery, "failed to execute query", err)
        }</span>
        <span class="cov0" title="0">defer cursor.Close(ctx)

        var results []map[string]interface{}
        if err = cursor.All(ctx, &amp;results); err != nil </span><span class="cov0" title="0">{
                return nil, errors.NewError(errors.ErrorTypeQuery, "failed to decode query results", err)
        }</span>

        <span class="cov0" title="0">return results, nil</span>
}

// Execute executes a command and returns the number of affected documents.
func (c *MongoConnector) Execute(ctx context.Context, command string, args ...interface{}) (int64, error) <span class="cov0" title="0">{
        if len(args) == 0 </span><span class="cov0" title="0">{
                return 0, errors.NewError(errors.ErrorTypeExecution, "missing collection name", nil)
        }</span>
        <span class="cov0" title="0">collectionName, ok := args[0].(string)
        if !ok </span><span class="cov0" title="0">{
                return 0, errors.NewError(errors.ErrorTypeExecution, "invalid collection name", nil)
        }</span>

        <span class="cov0" title="0">collection := c.client.Database(c.config.Database).Collection(collectionName)

        var result int64
        var err error

        switch command </span>{
        case "insert":<span class="cov0" title="0">
                if len(args) &lt; 2 </span><span class="cov0" title="0">{
                        return 0, errors.NewError(errors.ErrorTypeExecution, "missing document to insert", nil)
                }</span>
                <span class="cov0" title="0">doc, ok := args[1].(map[string]interface{})
                if !ok </span><span class="cov0" title="0">{
                        return 0, errors.NewError(errors.ErrorTypeExecution, "invalid document format", nil)
                }</span>
                <span class="cov0" title="0">_, err = collection.InsertOne(ctx, doc)
                if err == nil </span><span class="cov0" title="0">{
                        result = 1
                }</span>
        case "update":<span class="cov0" title="0">
                if len(args) &lt; 3 </span><span class="cov0" title="0">{
                        return 0, errors.NewError(errors.ErrorTypeExecution, "missing update parameters", nil)
                }</span>
                <span class="cov0" title="0">filter, ok := args[1].(map[string]interface{})
                if !ok </span><span class="cov0" title="0">{
                        return 0, errors.NewError(errors.ErrorTypeExecution, "invalid filter format", nil)
                }</span>
                <span class="cov0" title="0">update, ok := args[2].(map[string]interface{})
                if !ok </span><span class="cov0" title="0">{
                        return 0, errors.NewError(errors.ErrorTypeExecution, "invalid update format", nil)
                }</span>
                <span class="cov0" title="0">updateResult, err := collection.UpdateMany(ctx, filter, bson.M{"$set": update})
                if err == nil </span><span class="cov0" title="0">{
                        result = updateResult.ModifiedCount
                }</span>
        case "delete":<span class="cov0" title="0">
                if len(args) &lt; 2 </span><span class="cov0" title="0">{
                        return 0, errors.NewError(errors.ErrorTypeExecution, "missing delete parameters", nil)
                }</span>
                <span class="cov0" title="0">filter, ok := args[1].(map[string]interface{})
                if !ok </span><span class="cov0" title="0">{
                        return 0, errors.NewError(errors.ErrorTypeExecution, "invalid filter format", nil)
                }</span>
                <span class="cov0" title="0">deleteResult, err := collection.DeleteMany(ctx, filter)
                if err == nil </span><span class="cov0" title="0">{
                        result = deleteResult.DeletedCount
                }</span>
        default:<span class="cov0" title="0">
                return 0, errors.NewError(errors.ErrorTypeExecution, fmt.Sprintf("unsupported command: %s", command), nil)</span>
        }

        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                return 0, errors.NewError(errors.ErrorTypeExecution, fmt.Sprintf("failed to execute command: %s", command), err)
        }</span>

        <span class="cov0" title="0">return result, nil</span>
}

// Ping checks if the database connection is still alive.
func (c *MongoConnector) Ping(ctx context.Context) error <span class="cov0" title="0">{
        if c.client == nil </span><span class="cov0" title="0">{
                return errors.NewError(errors.ErrorTypeDatabaseConnection, errors.ErrorMessages[errors.ErrorTypeDatabaseConnection], nil)
        }</span>
        <span class="cov0" title="0">return c.client.Ping(ctx, nil)</span>
}

// Transaction starts a new database transaction and returns a TransactionConnector.
func (c *MongoConnector) Transaction(ctx context.Context) (TransactionConnector, error) <span class="cov0" title="0">{
        if c.client == nil </span><span class="cov0" title="0">{
                return nil, errors.NewError(errors.ErrorTypeDatabaseConnection, errors.ErrorMessages[errors.ErrorTypeDatabaseConnection], nil)
        }</span>

        <span class="cov0" title="0">session, err := c.client.StartSession()
        if err != nil </span><span class="cov0" title="0">{
                return nil, errors.NewError(errors.ErrorTypeTransaction, "failed to start session", err)
        }</span>

        <span class="cov0" title="0">if err := session.StartTransaction(); err != nil </span><span class="cov0" title="0">{
                return nil, errors.NewError(errors.ErrorTypeTransaction, "failed to start transaction", err)
        }</span>

        <span class="cov0" title="0">return &amp;MongoTransactionConnector{session: session, client: c.client, config: c.config}, nil</span>
}

// MongoTransactionConnector implements the TransactionConnector interface for MongoDB.
type MongoTransactionConnector struct {
        session mongo.Session
        client  *mongo.Client
        config  *Config
}

// Query executes a query within the transaction and returns the results.
func (c *MongoTransactionConnector) Query(ctx context.Context, query string, args ...interface{}) ([]map[string]interface{}, error) <span class="cov0" title="0">{
        var results []map[string]interface{}

        _, err := c.session.WithTransaction(ctx, func(sessCtx mongo.SessionContext) (interface{}, error) </span><span class="cov0" title="0">{
                // Parse the query string into a BSON document
                var filter bson.D
                err := bson.UnmarshalExtJSON([]byte(query), true, &amp;filter)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, errors.NewError(errors.ErrorTypeQuery, "failed to parse query", err)
                }</span>

                // Ensure we have at least one argument for the collection name
                <span class="cov0" title="0">if len(args) == 0 </span><span class="cov0" title="0">{
                        return nil, errors.NewError(errors.ErrorTypeQuery, "missing collection name", nil)
                }</span>
                <span class="cov0" title="0">collectionName, ok := args[0].(string)
                if !ok </span><span class="cov0" title="0">{
                        return nil, errors.NewError(errors.ErrorTypeQuery, "invalid collection name", nil)
                }</span>

                <span class="cov0" title="0">collection := c.client.Database(c.config.Database).Collection(collectionName)
                cursor, err := collection.Find(sessCtx, filter)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, errors.NewError(errors.ErrorTypeQuery, "failed to execute query", err)
                }</span>
                <span class="cov0" title="0">defer cursor.Close(sessCtx)

                for cursor.Next(sessCtx) </span><span class="cov0" title="0">{
                        var result map[string]interface{}
                        if err := cursor.Decode(&amp;result); err != nil </span><span class="cov0" title="0">{
                                return nil, errors.NewError(errors.ErrorTypeQuery, "failed to decode result", err)
                        }</span>
                        <span class="cov0" title="0">results = append(results, result)</span>
                }

                <span class="cov0" title="0">if err := cursor.Err(); err != nil </span><span class="cov0" title="0">{
                        return nil, errors.NewError(errors.ErrorTypeQuery, "error during cursor iteration", err)
                }</span>

                <span class="cov0" title="0">return results, nil</span>
        })

        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                return nil, errors.NewError(errors.ErrorTypeTransaction, "transaction failed", err)
        }</span>

        <span class="cov0" title="0">return results, nil</span>
}

// Execute executes a command within the transaction and returns the number of affected documents.
func (c *MongoTransactionConnector) Execute(ctx context.Context, command string, args ...interface{}) (int64, error) <span class="cov0" title="0">{
        var modifiedCount int64

        _, err := c.session.WithTransaction(ctx, func(sessCtx mongo.SessionContext) (interface{}, error) </span><span class="cov0" title="0">{
                var doc bson.D
                err := bson.UnmarshalExtJSON([]byte(command), true, &amp;doc)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, errors.NewError(errors.ErrorTypeExecution, "failed to parse command", err)
                }</span>

                // Ensure we have at least one argument for the collection name
                <span class="cov0" title="0">if len(args) == 0 </span><span class="cov0" title="0">{
                        return nil, errors.NewError(errors.ErrorTypeExecution, "missing collection name", nil)
                }</span>
                <span class="cov0" title="0">collectionName, ok := args[0].(string)
                if !ok </span><span class="cov0" title="0">{
                        return nil, errors.NewError(errors.ErrorTypeExecution, "invalid collection name", nil)
                }</span>

                <span class="cov0" title="0">collection := c.client.Database(c.config.Database).Collection(collectionName)

                // Assuming the first element is the filter and the second is the update
                if len(doc) &lt; 2 </span><span class="cov0" title="0">{
                        return nil, errors.NewError(errors.ErrorTypeExecution, "invalid command structure", nil)
                }</span>

                <span class="cov0" title="0">result, err := collection.UpdateMany(sessCtx, doc[0].Value, doc[1].Value)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, errors.NewError(errors.ErrorTypeExecution, "failed to execute command", err)
                }</span>

                <span class="cov0" title="0">modifiedCount = result.ModifiedCount
                return modifiedCount, nil</span>
        })

        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                return 0, errors.NewError(errors.ErrorTypeTransaction, "transaction failed", err)
        }</span>

        <span class="cov0" title="0">return modifiedCount, nil</span>
}

// Commit commits the transaction.
func (c *MongoTransactionConnector) Commit(ctx context.Context) error <span class="cov0" title="0">{
        return c.session.CommitTransaction(ctx)
}</span>

// Rollback rolls back the transaction.
func (c *MongoTransactionConnector) Rollback(ctx context.Context) error <span class="cov0" title="0">{
        return c.session.AbortTransaction(ctx)
}</span>
</pre>
		
		<pre class="file" id="file57" style="display: none">package connectors

import (
        "context"
        "fmt"

        "pkg/common/errors"
        "pkg/common/retry"

        "github.com/go-redis/redis/v8"
)

// RedisConnector implements the Connector interface for Redis.
type RedisConnector struct {
        client *redis.Client
        config *Config
}

// NewRedisConnector creates a new RedisConnector with the given configuration.
func NewRedisConnector(config *Config) *RedisConnector <span class="cov0" title="0">{
        return &amp;RedisConnector{config: config}
}</span>

// Connect establishes a connection to the Redis database.
func (c *RedisConnector) Connect(ctx context.Context) error <span class="cov0" title="0">{
        client := redis.NewClient(&amp;redis.Options{
                Addr:     fmt.Sprintf("%s:%d", c.config.Host, c.config.Port),
                Password: c.config.Password,
                DB:       c.config.RedisDB, // Redis uses integer for database selection
        })

        err := retry.Retry(ctx, func() error </span><span class="cov0" title="0">{
                return client.Ping(ctx).Err()
        }</span>, retry.DefaultConfig())

        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                return errors.NewError(errors.ErrorTypeDatabaseConnection, "failed to connect to Redis", err)
        }</span>

        <span class="cov0" title="0">c.client = client
        return nil</span>
}

// Close closes the connection to the Redis database.
func (c *RedisConnector) Close(ctx context.Context) error <span class="cov0" title="0">{
        if c.client == nil </span><span class="cov0" title="0">{
                return errors.NewError(errors.ErrorTypeDatabaseConnection, "connection already closed", nil)
        }</span>
        <span class="cov0" title="0">return c.client.Close()</span>
}

// Query executes a query and returns the results as a slice of maps.
// For Redis, this is implemented as a key lookup.
func (c *RedisConnector) Query(ctx context.Context, query string, args ...interface{}) ([]map[string]interface{}, error) <span class="cov0" title="0">{
        if c.client == nil </span><span class="cov0" title="0">{
                return nil, errors.NewError(errors.ErrorTypeDatabaseConnection, errors.ErrorMessages[errors.ErrorTypeDatabaseConnection], nil)
        }</span>

        <span class="cov0" title="0">val, err := c.client.Get(ctx, query).Result()
        if err == redis.Nil </span><span class="cov0" title="0">{
                return nil, nil // Key does not exist
        }</span> else<span class="cov0" title="0"> if err != nil </span><span class="cov0" title="0">{
                return nil, errors.NewError(errors.ErrorTypeQuery, "failed to execute query", err)
        }</span>

        <span class="cov0" title="0">return []map[string]interface{}{{"value": val}}, nil</span>
}

// Execute executes a command and returns the number of affected keys.
func (c *RedisConnector) Execute(ctx context.Context, command string, args ...interface{}) (int64, error) <span class="cov0" title="0">{
        if c.client == nil </span><span class="cov0" title="0">{
                return 0, errors.NewError(errors.ErrorTypeDatabaseConnection, errors.ErrorMessages[errors.ErrorTypeDatabaseConnection], nil)
        }</span>

        <span class="cov0" title="0">cmd := c.client.Do(ctx, append([]interface{}{command}, args...)...)
        if cmd.Err() != nil </span><span class="cov0" title="0">{
                return 0, errors.NewError(errors.ErrorTypeExecution, "failed to execute command", cmd.Err())
        }</span>

        // For simplicity, we're returning 1 if the command was successful.
        // In a real-world scenario, you might want to interpret the result based on the specific command.
        <span class="cov0" title="0">return 1, nil</span>
}

// Ping checks if the database connection is still alive.
func (c *RedisConnector) Ping(ctx context.Context) error <span class="cov0" title="0">{
        if c.client == nil </span><span class="cov0" title="0">{
                return errors.NewError(errors.ErrorTypeDatabaseConnection, errors.ErrorMessages[errors.ErrorTypeDatabaseConnection], nil)
        }</span>
        <span class="cov0" title="0">return c.client.Ping(ctx).Err()</span>
}

// Transaction starts a new database transaction and returns a TransactionConnector.
func (c *RedisConnector) Transaction(ctx context.Context) (TransactionConnector, error) <span class="cov0" title="0">{
        if c.client == nil </span><span class="cov0" title="0">{
                return nil, errors.NewError(errors.ErrorTypeDatabaseConnection, errors.ErrorMessages[errors.ErrorTypeDatabaseConnection], nil)
        }</span>

        <span class="cov0" title="0">tx := c.client.TxPipeline()
        return &amp;RedisTransactionConnector{tx: tx}, nil</span>
}

// RedisTransactionConnector implements the TransactionConnector interface for Redis.
type RedisTransactionConnector struct {
        tx redis.Pipeliner
}

// Query executes a query within the transaction and returns the results.
func (c *RedisTransactionConnector) Query(ctx context.Context, query string, args ...interface{}) ([]map[string]interface{}, error) <span class="cov0" title="0">{
        cmd := c.tx.Get(ctx, query)
        val, err := cmd.Result()
        if err == redis.Nil </span><span class="cov0" title="0">{
                return nil, nil // Key does not exist
        }</span> else<span class="cov0" title="0"> if err != nil </span><span class="cov0" title="0">{
                return nil, errors.NewError(errors.ErrorTypeTransaction, "cannot query in Redis transaction, use Execute instead", nil)
        }</span>

        <span class="cov0" title="0">return []map[string]interface{}{{"value": val}}, nil</span>
}

// Execute executes a command within the transaction.
func (c *RedisTransactionConnector) Execute(ctx context.Context, command string, args ...interface{}) (int64, error) <span class="cov0" title="0">{
        cmd := c.tx.Do(ctx, append([]interface{}{command}, args...)...)
        if cmd.Err() != nil </span><span class="cov0" title="0">{
                return 0, errors.NewError(errors.ErrorTypeTransaction, "failed to execute command", cmd.Err())
        }</span>
        <span class="cov0" title="0">return 0, nil</span> // The actual execution happens on Commit
}

// Commit commits the transaction.
func (c *RedisTransactionConnector) Commit(ctx context.Context) error <span class="cov0" title="0">{
        _, err := c.tx.Exec(ctx)
        if err != nil </span><span class="cov0" title="0">{
                return errors.NewError(errors.ErrorTypeTransaction, "failed to commit transaction", err)
        }</span>
        <span class="cov0" title="0">return nil</span>
}

// Rollback rolls back the transaction.
func (c *RedisTransactionConnector) Rollback(ctx context.Context) error <span class="cov0" title="0">{
        err := c.tx.Discard()
        if err != nil </span><span class="cov0" title="0">{
                return errors.NewError(errors.ErrorTypeTransaction, "failed to rollback transaction", err)
        }</span>
        <span class="cov0" title="0">return nil</span>
}
</pre>
		
		<pre class="file" id="file58" style="display: none">// Package connectors provides implementations of various data source connectors.
package connectors

import (
        "context"
        "database/sql"
        "fmt"
        "time"

        "pkg/common/errors"
        "pkg/common/retry"

        _ "github.com/lib/pq"
)

// SQLConnector implements the Connector interface for SQL databases.
type SQLConnector struct {
        db     *sql.DB
        config *Config
}

// NewSQLConnector creates a new SQLConnector with the given configuration.
func NewSQLConnector(config *Config) *SQLConnector <span class="cov0" title="0">{
        return &amp;SQLConnector{config: config}
}</span>

// Connect establishes a connection to the SQL database.
func (c *SQLConnector) Connect(ctx context.Context) error <span class="cov0" title="0">{
        var dsn string
        var driverName string

        switch c.config.Driver </span>{
        case "postgres":<span class="cov0" title="0">
                driverName = "postgres"
                dsn = fmt.Sprintf("host=%s port=%d user=%s password=%s dbname=%s sslmode=disable",
                        c.config.Host, c.config.Port, c.config.Username, c.config.Password, c.config.Database)</span>
        case "mysql":<span class="cov0" title="0">
                driverName = "mysql"
                dsn = fmt.Sprintf("%s:%s@tcp(%s:%d)/%s",
                        c.config.Username, c.config.Password, c.config.Host, c.config.Port, c.config.Database)</span>
        case "sqlite":<span class="cov0" title="0">
                driverName = "sqlite3"
                dsn = c.config.Database</span> // For SQLite, the database is the file path
        default:<span class="cov0" title="0">
                return errors.NewError(errors.ErrorTypeConfiguration, "unsupported SQL driver", nil)</span>
        }

        <span class="cov0" title="0">var db *sql.DB
        err := retry.Retry(ctx, func() error </span><span class="cov0" title="0">{
                var err error
                db, err = sql.Open(driverName, dsn)
                if err != nil </span><span class="cov0" title="0">{
                        return errors.NewError(errors.ErrorTypeDatabaseConnection, "failed to open database", err)
                }</span>
                <span class="cov0" title="0">return db.PingContext(ctx)</span>
        }, retry.DefaultConfig())

        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // Configure connection pool
        <span class="cov0" title="0">db.SetMaxOpenConns(c.config.MaxOpenConns)
        db.SetMaxIdleConns(c.config.MaxIdleConns)
        db.SetConnMaxLifetime(time.Duration(c.config.ConnMaxLifetimeSeconds) * time.Second)

        c.db = db
        return nil</span>
}

// Close closes the connection to the SQL database.
func (c *SQLConnector) Close(ctx context.Context) error <span class="cov0" title="0">{
        if c.db == nil </span><span class="cov0" title="0">{
                return errors.NewError(errors.ErrorTypeDatabaseConnection, "connection already closed", nil)
        }</span>
        <span class="cov0" title="0">return c.db.Close()</span>
}

// Query executes a query and returns the results as a slice of maps.
func (c *SQLConnector) Query(ctx context.Context, query string, args ...interface{}) ([]map[string]interface{}, error) <span class="cov0" title="0">{
        if c.db == nil </span><span class="cov0" title="0">{
                return nil, errors.NewError(errors.ErrorTypeDatabaseConnection, errors.ErrorMessages[errors.ErrorTypeDatabaseConnection], nil)
        }</span>

        <span class="cov0" title="0">rows, err := c.db.QueryContext(ctx, query, args...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, errors.NewError(errors.ErrorTypeQuery, "failed to execute query", err)
        }</span>
        <span class="cov0" title="0">defer rows.Close()

        columns, err := rows.Columns()
        if err != nil </span><span class="cov0" title="0">{
                return nil, errors.NewError(errors.ErrorTypeQuery, "failed to get columns", err)
        }</span>

        <span class="cov0" title="0">var results []map[string]interface{}
        for rows.Next() </span><span class="cov0" title="0">{
                values := make([]interface{}, len(columns))
                for i := range values </span><span class="cov0" title="0">{
                        values[i] = new(interface{})
                }</span>

                <span class="cov0" title="0">if err := rows.Scan(values...); err != nil </span><span class="cov0" title="0">{
                        return nil, errors.NewError(errors.ErrorTypeQuery, "failed to scan row", err)
                }</span>

                <span class="cov0" title="0">row := make(map[string]interface{})
                for i, column := range columns </span><span class="cov0" title="0">{
                        row[column] = *(values[i].(*interface{}))
                }</span>
                <span class="cov0" title="0">results = append(results, row)</span>
        }

        <span class="cov0" title="0">if err := rows.Err(); err != nil </span><span class="cov0" title="0">{
                return nil, errors.NewError(errors.ErrorTypeQuery, "error during row iteration", err)
        }</span>

        <span class="cov0" title="0">return results, nil</span>
}

// Execute executes a command (e.g., INSERT, UPDATE, DELETE) and returns the number of affected rows.
func (c *SQLConnector) Execute(ctx context.Context, command string, args ...interface{}) (int64, error) <span class="cov0" title="0">{
        if c.db == nil </span><span class="cov0" title="0">{
                return 0, errors.NewError(errors.ErrorTypeDatabaseConnection, errors.ErrorMessages[errors.ErrorTypeDatabaseConnection], nil)
        }</span>

        <span class="cov0" title="0">result, err := c.db.ExecContext(ctx, command, args...)
        if err != nil </span><span class="cov0" title="0">{
                return 0, errors.NewError(errors.ErrorTypeExecution, "failed to execute command", err)
        }</span>

        <span class="cov0" title="0">affected, err := result.RowsAffected()
        if err != nil </span><span class="cov0" title="0">{
                return 0, errors.NewError(errors.ErrorTypeExecution, "failed to get affected rows", err)
        }</span>

        <span class="cov0" title="0">return affected, nil</span>
}

// Ping checks if the database connection is still alive.
func (c *SQLConnector) Ping(ctx context.Context) error <span class="cov0" title="0">{
        if c.db == nil </span><span class="cov0" title="0">{
                return errors.NewError(errors.ErrorTypeDatabaseConnection, errors.ErrorMessages[errors.ErrorTypeDatabaseConnection], nil)
        }</span>
        <span class="cov0" title="0">return c.db.PingContext(ctx)</span>
}

// Transaction starts a new database transaction and returns a TransactionConnector.
func (c *SQLConnector) Transaction(ctx context.Context) (TransactionConnector, error) <span class="cov0" title="0">{
        if c.db == nil </span><span class="cov0" title="0">{
                return nil, errors.NewError(errors.ErrorTypeDatabaseConnection, errors.ErrorMessages[errors.ErrorTypeDatabaseConnection], nil)
        }</span>

        <span class="cov0" title="0">tx, err := c.db.BeginTx(ctx, nil)
        if err != nil </span><span class="cov0" title="0">{
                return nil, errors.NewError(errors.ErrorTypeTransaction, "failed to start transaction", err)
        }</span>

        <span class="cov0" title="0">return &amp;SQLTransactionConnector{tx: tx}, nil</span>
}

// SQLTransactionConnector implements the TransactionConnector interface for SQL databases.
type SQLTransactionConnector struct {
        tx *sql.Tx
}

// Query executes a query within the transaction and returns the results.
func (c *SQLTransactionConnector) Query(ctx context.Context, query string, args ...interface{}) ([]map[string]interface{}, error) <span class="cov0" title="0">{
        rows, err := c.tx.QueryContext(ctx, query, args...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, errors.NewError(errors.ErrorTypeQuery, "failed to execute query in transaction", err)
        }</span>
        <span class="cov0" title="0">defer rows.Close()

        columns, err := rows.Columns()
        if err != nil </span><span class="cov0" title="0">{
                return nil, errors.NewError(errors.ErrorTypeQuery, "failed to get columns in transaction", err)
        }</span>

        <span class="cov0" title="0">var results []map[string]interface{}

        for rows.Next() </span><span class="cov0" title="0">{
                values := make([]interface{}, len(columns))
                for i := range values </span><span class="cov0" title="0">{
                        values[i] = new(interface{})
                }</span>

                <span class="cov0" title="0">if err := rows.Scan(values...); err != nil </span><span class="cov0" title="0">{
                        return nil, errors.NewError(errors.ErrorTypeQuery, "failed to scan row in transaction", err)
                }</span>

                <span class="cov0" title="0">row := make(map[string]interface{})
                for i, column := range columns </span><span class="cov0" title="0">{
                        row[column] = *(values[i].(*interface{}))
                }</span>
                <span class="cov0" title="0">results = append(results, row)</span>
        }

        <span class="cov0" title="0">if err := rows.Err(); err != nil </span><span class="cov0" title="0">{
                return nil, errors.NewError(errors.ErrorTypeQuery, "error during row iteration in transaction", err)
        }</span>

        <span class="cov0" title="0">return results, nil</span>
}

// Execute executes a command within the transaction and returns the number of affected rows.
func (c *SQLTransactionConnector) Execute(ctx context.Context, command string, args ...interface{}) (int64, error) <span class="cov0" title="0">{
        result, err := c.tx.ExecContext(ctx, command, args...)
        if err != nil </span><span class="cov0" title="0">{
                return 0, errors.NewError(errors.ErrorTypeExecution, "failed to execute command in transaction", err)
        }</span>

        <span class="cov0" title="0">affected, err := result.RowsAffected()
        if err != nil </span><span class="cov0" title="0">{
                return 0, errors.NewError(errors.ErrorTypeExecution, "failed to get affected rows in transaction", err)
        }</span>

        <span class="cov0" title="0">return affected, nil</span>
}

// Commit commits the transaction.
func (c *SQLTransactionConnector) Commit(ctx context.Context) error <span class="cov0" title="0">{
        if err := c.tx.Commit(); err != nil </span><span class="cov0" title="0">{
                return errors.NewError(errors.ErrorTypeTransaction, "failed to commit transaction", err)
        }</span>
        <span class="cov0" title="0">return nil</span>
}

// Rollback rolls back the transaction.
func (c *SQLTransactionConnector) Rollback(ctx context.Context) error <span class="cov0" title="0">{
        if err := c.tx.Rollback(); err != nil </span><span class="cov0" title="0">{
                return errors.NewError(errors.ErrorTypeTransaction, "failed to rollback transaction", err)
        }</span>
        <span class="cov0" title="0">return nil</span>
}
</pre>
		
		<pre class="file" id="file59" style="display: none">// Code generated by protoc-gen-go. DO NOT EDIT.
// versions:
//         protoc-gen-go v1.34.2
//         protoc        v3.21.12
// source: connector.proto

package grpc

import (
        reflect "reflect"
        sync "sync"

        protoreflect "google.golang.org/protobuf/reflect/protoreflect"
        protoimpl "google.golang.org/protobuf/runtime/protoimpl"
)

const (
        // Verify that this generated code is sufficiently up-to-date.
        _ = protoimpl.EnforceVersion(20 - protoimpl.MinVersion)
        // Verify that runtime/protoimpl is sufficiently up-to-date.
        _ = protoimpl.EnforceVersion(protoimpl.MaxVersion - 20)
)

type ConnectRequest struct {
        state         protoimpl.MessageState
        sizeCache     protoimpl.SizeCache
        unknownFields protoimpl.UnknownFields

        ConnectorName string `protobuf:"bytes,1,opt,name=connector_name,json=connectorName,proto3" json:"connector_name,omitempty"`
}

func (x *ConnectRequest) Reset() <span class="cov0" title="0">{
        *x = ConnectRequest{}
        if protoimpl.UnsafeEnabled </span><span class="cov0" title="0">{
                mi := &amp;file_connector_proto_msgTypes[0]
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                ms.StoreMessageInfo(mi)
        }</span>
}

func (x *ConnectRequest) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*ConnectRequest) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *ConnectRequest) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_connector_proto_msgTypes[0]
        if protoimpl.UnsafeEnabled &amp;&amp; x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use ConnectRequest.ProtoReflect.Descriptor instead.
func (*ConnectRequest) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_connector_proto_rawDescGZIP(), []int{0}
}</span>

func (x *ConnectRequest) GetConnectorName() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.ConnectorName
        }</span>
        <span class="cov0" title="0">return ""</span>
}

type ConnectResponse struct {
        state         protoimpl.MessageState
        sizeCache     protoimpl.SizeCache
        unknownFields protoimpl.UnknownFields

        Success bool   `protobuf:"varint,1,opt,name=success,proto3" json:"success,omitempty"`
        Error   string `protobuf:"bytes,2,opt,name=error,proto3" json:"error,omitempty"`
}

func (x *ConnectResponse) Reset() <span class="cov0" title="0">{
        *x = ConnectResponse{}
        if protoimpl.UnsafeEnabled </span><span class="cov0" title="0">{
                mi := &amp;file_connector_proto_msgTypes[1]
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                ms.StoreMessageInfo(mi)
        }</span>
}

func (x *ConnectResponse) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*ConnectResponse) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *ConnectResponse) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_connector_proto_msgTypes[1]
        if protoimpl.UnsafeEnabled &amp;&amp; x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use ConnectResponse.ProtoReflect.Descriptor instead.
func (*ConnectResponse) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_connector_proto_rawDescGZIP(), []int{1}
}</span>

func (x *ConnectResponse) GetSuccess() bool <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Success
        }</span>
        <span class="cov0" title="0">return false</span>
}

func (x *ConnectResponse) GetError() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Error
        }</span>
        <span class="cov0" title="0">return ""</span>
}

type DisconnectRequest struct {
        state         protoimpl.MessageState
        sizeCache     protoimpl.SizeCache
        unknownFields protoimpl.UnknownFields

        ConnectorName string `protobuf:"bytes,1,opt,name=connector_name,json=connectorName,proto3" json:"connector_name,omitempty"`
}

func (x *DisconnectRequest) Reset() <span class="cov0" title="0">{
        *x = DisconnectRequest{}
        if protoimpl.UnsafeEnabled </span><span class="cov0" title="0">{
                mi := &amp;file_connector_proto_msgTypes[2]
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                ms.StoreMessageInfo(mi)
        }</span>
}

func (x *DisconnectRequest) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*DisconnectRequest) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *DisconnectRequest) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_connector_proto_msgTypes[2]
        if protoimpl.UnsafeEnabled &amp;&amp; x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use DisconnectRequest.ProtoReflect.Descriptor instead.
func (*DisconnectRequest) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_connector_proto_rawDescGZIP(), []int{2}
}</span>

func (x *DisconnectRequest) GetConnectorName() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.ConnectorName
        }</span>
        <span class="cov0" title="0">return ""</span>
}

type DisconnectResponse struct {
        state         protoimpl.MessageState
        sizeCache     protoimpl.SizeCache
        unknownFields protoimpl.UnknownFields

        Success bool   `protobuf:"varint,1,opt,name=success,proto3" json:"success,omitempty"`
        Error   string `protobuf:"bytes,2,opt,name=error,proto3" json:"error,omitempty"`
}

func (x *DisconnectResponse) Reset() <span class="cov0" title="0">{
        *x = DisconnectResponse{}
        if protoimpl.UnsafeEnabled </span><span class="cov0" title="0">{
                mi := &amp;file_connector_proto_msgTypes[3]
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                ms.StoreMessageInfo(mi)
        }</span>
}

func (x *DisconnectResponse) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*DisconnectResponse) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *DisconnectResponse) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_connector_proto_msgTypes[3]
        if protoimpl.UnsafeEnabled &amp;&amp; x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use DisconnectResponse.ProtoReflect.Descriptor instead.
func (*DisconnectResponse) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_connector_proto_rawDescGZIP(), []int{3}
}</span>

func (x *DisconnectResponse) GetSuccess() bool <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Success
        }</span>
        <span class="cov0" title="0">return false</span>
}

func (x *DisconnectResponse) GetError() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Error
        }</span>
        <span class="cov0" title="0">return ""</span>
}

type QueryRequest struct {
        state         protoimpl.MessageState
        sizeCache     protoimpl.SizeCache
        unknownFields protoimpl.UnknownFields

        ConnectorName string   `protobuf:"bytes,1,opt,name=connector_name,json=connectorName,proto3" json:"connector_name,omitempty"`
        Query         string   `protobuf:"bytes,2,opt,name=query,proto3" json:"query,omitempty"`
        Args          []string `protobuf:"bytes,3,rep,name=args,proto3" json:"args,omitempty"`
}

func (x *QueryRequest) Reset() <span class="cov0" title="0">{
        *x = QueryRequest{}
        if protoimpl.UnsafeEnabled </span><span class="cov0" title="0">{
                mi := &amp;file_connector_proto_msgTypes[4]
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                ms.StoreMessageInfo(mi)
        }</span>
}

func (x *QueryRequest) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*QueryRequest) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *QueryRequest) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_connector_proto_msgTypes[4]
        if protoimpl.UnsafeEnabled &amp;&amp; x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use QueryRequest.ProtoReflect.Descriptor instead.
func (*QueryRequest) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_connector_proto_rawDescGZIP(), []int{4}
}</span>

func (x *QueryRequest) GetConnectorName() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.ConnectorName
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *QueryRequest) GetQuery() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Query
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *QueryRequest) GetArgs() []string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Args
        }</span>
        <span class="cov0" title="0">return nil</span>
}

type QueryResponse struct {
        state         protoimpl.MessageState
        sizeCache     protoimpl.SizeCache
        unknownFields protoimpl.UnknownFields

        Rows  [][]byte `protobuf:"bytes,1,rep,name=rows,proto3" json:"rows,omitempty"`
        Error string   `protobuf:"bytes,2,opt,name=error,proto3" json:"error,omitempty"`
}

func (x *QueryResponse) Reset() <span class="cov0" title="0">{
        *x = QueryResponse{}
        if protoimpl.UnsafeEnabled </span><span class="cov0" title="0">{
                mi := &amp;file_connector_proto_msgTypes[5]
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                ms.StoreMessageInfo(mi)
        }</span>
}

func (x *QueryResponse) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*QueryResponse) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *QueryResponse) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_connector_proto_msgTypes[5]
        if protoimpl.UnsafeEnabled &amp;&amp; x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use QueryResponse.ProtoReflect.Descriptor instead.
func (*QueryResponse) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_connector_proto_rawDescGZIP(), []int{5}
}</span>

func (x *QueryResponse) GetRows() [][]byte <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Rows
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (x *QueryResponse) GetError() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Error
        }</span>
        <span class="cov0" title="0">return ""</span>
}

type CommandRequest struct {
        state         protoimpl.MessageState
        sizeCache     protoimpl.SizeCache
        unknownFields protoimpl.UnknownFields

        ConnectorName string   `protobuf:"bytes,1,opt,name=connector_name,json=connectorName,proto3" json:"connector_name,omitempty"`
        Command       string   `protobuf:"bytes,2,opt,name=command,proto3" json:"command,omitempty"`
        Args          []string `protobuf:"bytes,3,rep,name=args,proto3" json:"args,omitempty"`
}

func (x *CommandRequest) Reset() <span class="cov0" title="0">{
        *x = CommandRequest{}
        if protoimpl.UnsafeEnabled </span><span class="cov0" title="0">{
                mi := &amp;file_connector_proto_msgTypes[6]
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                ms.StoreMessageInfo(mi)
        }</span>
}

func (x *CommandRequest) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*CommandRequest) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *CommandRequest) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_connector_proto_msgTypes[6]
        if protoimpl.UnsafeEnabled &amp;&amp; x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use CommandRequest.ProtoReflect.Descriptor instead.
func (*CommandRequest) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_connector_proto_rawDescGZIP(), []int{6}
}</span>

func (x *CommandRequest) GetConnectorName() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.ConnectorName
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *CommandRequest) GetCommand() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Command
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *CommandRequest) GetArgs() []string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Args
        }</span>
        <span class="cov0" title="0">return nil</span>
}

type CommandResponse struct {
        state         protoimpl.MessageState
        sizeCache     protoimpl.SizeCache
        unknownFields protoimpl.UnknownFields

        AffectedRows int64  `protobuf:"varint,1,opt,name=affected_rows,json=affectedRows,proto3" json:"affected_rows,omitempty"`
        Error        string `protobuf:"bytes,2,opt,name=error,proto3" json:"error,omitempty"`
}

func (x *CommandResponse) Reset() <span class="cov0" title="0">{
        *x = CommandResponse{}
        if protoimpl.UnsafeEnabled </span><span class="cov0" title="0">{
                mi := &amp;file_connector_proto_msgTypes[7]
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                ms.StoreMessageInfo(mi)
        }</span>
}

func (x *CommandResponse) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*CommandResponse) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *CommandResponse) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_connector_proto_msgTypes[7]
        if protoimpl.UnsafeEnabled &amp;&amp; x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use CommandResponse.ProtoReflect.Descriptor instead.
func (*CommandResponse) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_connector_proto_rawDescGZIP(), []int{7}
}</span>

func (x *CommandResponse) GetAffectedRows() int64 <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.AffectedRows
        }</span>
        <span class="cov0" title="0">return 0</span>
}

func (x *CommandResponse) GetError() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Error
        }</span>
        <span class="cov0" title="0">return ""</span>
}

type GetConnectorsRequest struct {
        state         protoimpl.MessageState
        sizeCache     protoimpl.SizeCache
        unknownFields protoimpl.UnknownFields
}

func (x *GetConnectorsRequest) Reset() <span class="cov0" title="0">{
        *x = GetConnectorsRequest{}
        if protoimpl.UnsafeEnabled </span><span class="cov0" title="0">{
                mi := &amp;file_connector_proto_msgTypes[8]
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                ms.StoreMessageInfo(mi)
        }</span>
}

func (x *GetConnectorsRequest) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*GetConnectorsRequest) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *GetConnectorsRequest) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_connector_proto_msgTypes[8]
        if protoimpl.UnsafeEnabled &amp;&amp; x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use GetConnectorsRequest.ProtoReflect.Descriptor instead.
func (*GetConnectorsRequest) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_connector_proto_rawDescGZIP(), []int{8}
}</span>

type GetConnectorsResponse struct {
        state         protoimpl.MessageState
        sizeCache     protoimpl.SizeCache
        unknownFields protoimpl.UnknownFields

        ConnectorNames []string `protobuf:"bytes,1,rep,name=connector_names,json=connectorNames,proto3" json:"connector_names,omitempty"`
}

func (x *GetConnectorsResponse) Reset() <span class="cov0" title="0">{
        *x = GetConnectorsResponse{}
        if protoimpl.UnsafeEnabled </span><span class="cov0" title="0">{
                mi := &amp;file_connector_proto_msgTypes[9]
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                ms.StoreMessageInfo(mi)
        }</span>
}

func (x *GetConnectorsResponse) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*GetConnectorsResponse) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *GetConnectorsResponse) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_connector_proto_msgTypes[9]
        if protoimpl.UnsafeEnabled &amp;&amp; x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use GetConnectorsResponse.ProtoReflect.Descriptor instead.
func (*GetConnectorsResponse) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_connector_proto_rawDescGZIP(), []int{9}
}</span>

func (x *GetConnectorsResponse) GetConnectorNames() []string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.ConnectorNames
        }</span>
        <span class="cov0" title="0">return nil</span>
}

type AddConnectorRequest struct {
        state         protoimpl.MessageState
        sizeCache     protoimpl.SizeCache
        unknownFields protoimpl.UnknownFields

        Name   string           `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
        Config *ConnectorConfig `protobuf:"bytes,2,opt,name=config,proto3" json:"config,omitempty"`
}

func (x *AddConnectorRequest) Reset() <span class="cov0" title="0">{
        *x = AddConnectorRequest{}
        if protoimpl.UnsafeEnabled </span><span class="cov0" title="0">{
                mi := &amp;file_connector_proto_msgTypes[10]
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                ms.StoreMessageInfo(mi)
        }</span>
}

func (x *AddConnectorRequest) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*AddConnectorRequest) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *AddConnectorRequest) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_connector_proto_msgTypes[10]
        if protoimpl.UnsafeEnabled &amp;&amp; x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use AddConnectorRequest.ProtoReflect.Descriptor instead.
func (*AddConnectorRequest) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_connector_proto_rawDescGZIP(), []int{10}
}</span>

func (x *AddConnectorRequest) GetName() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Name
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *AddConnectorRequest) GetConfig() *ConnectorConfig <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Config
        }</span>
        <span class="cov0" title="0">return nil</span>
}

type ConnectorConfig struct {
        state         protoimpl.MessageState
        sizeCache     protoimpl.SizeCache
        unknownFields protoimpl.UnknownFields

        Type     string            `protobuf:"bytes,1,opt,name=type,proto3" json:"type,omitempty"`
        Host     string            `protobuf:"bytes,2,opt,name=host,proto3" json:"host,omitempty"`
        Port     int32             `protobuf:"varint,3,opt,name=port,proto3" json:"port,omitempty"`
        Username string            `protobuf:"bytes,4,opt,name=username,proto3" json:"username,omitempty"`
        Password string            `protobuf:"bytes,5,opt,name=password,proto3" json:"password,omitempty"`
        Database string            `protobuf:"bytes,6,opt,name=database,proto3" json:"database,omitempty"`
        Options  map[string]string `protobuf:"bytes,7,rep,name=options,proto3" json:"options,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
}

func (x *ConnectorConfig) Reset() <span class="cov0" title="0">{
        *x = ConnectorConfig{}
        if protoimpl.UnsafeEnabled </span><span class="cov0" title="0">{
                mi := &amp;file_connector_proto_msgTypes[11]
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                ms.StoreMessageInfo(mi)
        }</span>
}

func (x *ConnectorConfig) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*ConnectorConfig) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *ConnectorConfig) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_connector_proto_msgTypes[11]
        if protoimpl.UnsafeEnabled &amp;&amp; x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use ConnectorConfig.ProtoReflect.Descriptor instead.
func (*ConnectorConfig) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_connector_proto_rawDescGZIP(), []int{11}
}</span>

func (x *ConnectorConfig) GetType() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Type
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *ConnectorConfig) GetHost() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Host
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *ConnectorConfig) GetPort() int32 <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Port
        }</span>
        <span class="cov0" title="0">return 0</span>
}

func (x *ConnectorConfig) GetUsername() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Username
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *ConnectorConfig) GetPassword() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Password
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *ConnectorConfig) GetDatabase() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Database
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *ConnectorConfig) GetOptions() map[string]string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Options
        }</span>
        <span class="cov0" title="0">return nil</span>
}

type AddConnectorResponse struct {
        state         protoimpl.MessageState
        sizeCache     protoimpl.SizeCache
        unknownFields protoimpl.UnknownFields

        Success bool   `protobuf:"varint,1,opt,name=success,proto3" json:"success,omitempty"`
        Error   string `protobuf:"bytes,2,opt,name=error,proto3" json:"error,omitempty"`
}

func (x *AddConnectorResponse) Reset() <span class="cov0" title="0">{
        *x = AddConnectorResponse{}
        if protoimpl.UnsafeEnabled </span><span class="cov0" title="0">{
                mi := &amp;file_connector_proto_msgTypes[12]
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                ms.StoreMessageInfo(mi)
        }</span>
}

func (x *AddConnectorResponse) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*AddConnectorResponse) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *AddConnectorResponse) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_connector_proto_msgTypes[12]
        if protoimpl.UnsafeEnabled &amp;&amp; x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use AddConnectorResponse.ProtoReflect.Descriptor instead.
func (*AddConnectorResponse) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_connector_proto_rawDescGZIP(), []int{12}
}</span>

func (x *AddConnectorResponse) GetSuccess() bool <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Success
        }</span>
        <span class="cov0" title="0">return false</span>
}

func (x *AddConnectorResponse) GetError() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Error
        }</span>
        <span class="cov0" title="0">return ""</span>
}

type RemoveConnectorRequest struct {
        state         protoimpl.MessageState
        sizeCache     protoimpl.SizeCache
        unknownFields protoimpl.UnknownFields

        Name string `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
}

func (x *RemoveConnectorRequest) Reset() <span class="cov0" title="0">{
        *x = RemoveConnectorRequest{}
        if protoimpl.UnsafeEnabled </span><span class="cov0" title="0">{
                mi := &amp;file_connector_proto_msgTypes[13]
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                ms.StoreMessageInfo(mi)
        }</span>
}

func (x *RemoveConnectorRequest) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*RemoveConnectorRequest) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *RemoveConnectorRequest) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_connector_proto_msgTypes[13]
        if protoimpl.UnsafeEnabled &amp;&amp; x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use RemoveConnectorRequest.ProtoReflect.Descriptor instead.
func (*RemoveConnectorRequest) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_connector_proto_rawDescGZIP(), []int{13}
}</span>

func (x *RemoveConnectorRequest) GetName() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Name
        }</span>
        <span class="cov0" title="0">return ""</span>
}

type RemoveConnectorResponse struct {
        state         protoimpl.MessageState
        sizeCache     protoimpl.SizeCache
        unknownFields protoimpl.UnknownFields

        Success bool   `protobuf:"varint,1,opt,name=success,proto3" json:"success,omitempty"`
        Error   string `protobuf:"bytes,2,opt,name=error,proto3" json:"error,omitempty"`
}

func (x *RemoveConnectorResponse) Reset() <span class="cov0" title="0">{
        *x = RemoveConnectorResponse{}
        if protoimpl.UnsafeEnabled </span><span class="cov0" title="0">{
                mi := &amp;file_connector_proto_msgTypes[14]
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                ms.StoreMessageInfo(mi)
        }</span>
}

func (x *RemoveConnectorResponse) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*RemoveConnectorResponse) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *RemoveConnectorResponse) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_connector_proto_msgTypes[14]
        if protoimpl.UnsafeEnabled &amp;&amp; x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use RemoveConnectorResponse.ProtoReflect.Descriptor instead.
func (*RemoveConnectorResponse) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_connector_proto_rawDescGZIP(), []int{14}
}</span>

func (x *RemoveConnectorResponse) GetSuccess() bool <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Success
        }</span>
        <span class="cov0" title="0">return false</span>
}

func (x *RemoveConnectorResponse) GetError() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Error
        }</span>
        <span class="cov0" title="0">return ""</span>
}

var File_connector_proto protoreflect.FileDescriptor

var file_connector_proto_rawDesc = []byte{
        0x0a, 0x0f, 0x63, 0x6f, 0x6e, 0x6e, 0x65, 0x63, 0x74, 0x6f, 0x72, 0x2e, 0x70, 0x72, 0x6f, 0x74,
        0x6f, 0x12, 0x0a, 0x64, 0x61, 0x74, 0x61, 0x73, 0x6f, 0x75, 0x72, 0x63, 0x65, 0x22, 0x37, 0x0a,
        0x0e, 0x43, 0x6f, 0x6e, 0x6e, 0x65, 0x63, 0x74, 0x52, 0x65, 0x71, 0x75, 0x65, 0x73, 0x74, 0x12,
        0x25, 0x0a, 0x0e, 0x63, 0x6f, 0x6e, 0x6e, 0x65, 0x63, 0x74, 0x6f, 0x72, 0x5f, 0x6e, 0x61, 0x6d,
        0x65, 0x18, 0x01, 0x20, 0x01, 0x28, 0x09, 0x52, 0x0d, 0x63, 0x6f, 0x6e, 0x6e, 0x65, 0x63, 0x74,
        0x6f, 0x72, 0x4e, 0x61, 0x6d, 0x65, 0x22, 0x41, 0x0a, 0x0f, 0x43, 0x6f, 0x6e, 0x6e, 0x65, 0x63,
        0x74, 0x52, 0x65, 0x73, 0x70, 0x6f, 0x6e, 0x73, 0x65, 0x12, 0x18, 0x0a, 0x07, 0x73, 0x75, 0x63,
        0x63, 0x65, 0x73, 0x73, 0x18, 0x01, 0x20, 0x01, 0x28, 0x08, 0x52, 0x07, 0x73, 0x75, 0x63, 0x63,
        0x65, 0x73, 0x73, 0x12, 0x14, 0x0a, 0x05, 0x65, 0x72, 0x72, 0x6f, 0x72, 0x18, 0x02, 0x20, 0x01,
        0x28, 0x09, 0x52, 0x05, 0x65, 0x72, 0x72, 0x6f, 0x72, 0x22, 0x3a, 0x0a, 0x11, 0x44, 0x69, 0x73,
        0x63, 0x6f, 0x6e, 0x6e, 0x65, 0x63, 0x74, 0x52, 0x65, 0x71, 0x75, 0x65, 0x73, 0x74, 0x12, 0x25,
        0x0a, 0x0e, 0x63, 0x6f, 0x6e, 0x6e, 0x65, 0x63, 0x74, 0x6f, 0x72, 0x5f, 0x6e, 0x61, 0x6d, 0x65,
        0x18, 0x01, 0x20, 0x01, 0x28, 0x09, 0x52, 0x0d, 0x63, 0x6f, 0x6e, 0x6e, 0x65, 0x63, 0x74, 0x6f,
        0x72, 0x4e, 0x61, 0x6d, 0x65, 0x22, 0x44, 0x0a, 0x12, 0x44, 0x69, 0x73, 0x63, 0x6f, 0x6e, 0x6e,
        0x65, 0x63, 0x74, 0x52, 0x65, 0x73, 0x70, 0x6f, 0x6e, 0x73, 0x65, 0x12, 0x18, 0x0a, 0x07, 0x73,
        0x75, 0x63, 0x63, 0x65, 0x73, 0x73, 0x18, 0x01, 0x20, 0x01, 0x28, 0x08, 0x52, 0x07, 0x73, 0x75,
        0x63, 0x63, 0x65, 0x73, 0x73, 0x12, 0x14, 0x0a, 0x05, 0x65, 0x72, 0x72, 0x6f, 0x72, 0x18, 0x02,
        0x20, 0x01, 0x28, 0x09, 0x52, 0x05, 0x65, 0x72, 0x72, 0x6f, 0x72, 0x22, 0x5f, 0x0a, 0x0c, 0x51,
        0x75, 0x65, 0x72, 0x79, 0x52, 0x65, 0x71, 0x75, 0x65, 0x73, 0x74, 0x12, 0x25, 0x0a, 0x0e, 0x63,
        0x6f, 0x6e, 0x6e, 0x65, 0x63, 0x74, 0x6f, 0x72, 0x5f, 0x6e, 0x61, 0x6d, 0x65, 0x18, 0x01, 0x20,
        0x01, 0x28, 0x09, 0x52, 0x0d, 0x63, 0x6f, 0x6e, 0x6e, 0x65, 0x63, 0x74, 0x6f, 0x72, 0x4e, 0x61,
        0x6d, 0x65, 0x12, 0x14, 0x0a, 0x05, 0x71, 0x75, 0x65, 0x72, 0x79, 0x18, 0x02, 0x20, 0x01, 0x28,
        0x09, 0x52, 0x05, 0x71, 0x75, 0x65, 0x72, 0x79, 0x12, 0x12, 0x0a, 0x04, 0x61, 0x72, 0x67, 0x73,
        0x18, 0x03, 0x20, 0x03, 0x28, 0x09, 0x52, 0x04, 0x61, 0x72, 0x67, 0x73, 0x22, 0x39, 0x0a, 0x0d,
        0x51, 0x75, 0x65, 0x72, 0x79, 0x52, 0x65, 0x73, 0x70, 0x6f, 0x6e, 0x73, 0x65, 0x12, 0x12, 0x0a,
        0x04, 0x72, 0x6f, 0x77, 0x73, 0x18, 0x01, 0x20, 0x03, 0x28, 0x0c, 0x52, 0x04, 0x72, 0x6f, 0x77,
        0x73, 0x12, 0x14, 0x0a, 0x05, 0x65, 0x72, 0x72, 0x6f, 0x72, 0x18, 0x02, 0x20, 0x01, 0x28, 0x09,
        0x52, 0x05, 0x65, 0x72, 0x72, 0x6f, 0x72, 0x22, 0x65, 0x0a, 0x0e, 0x43, 0x6f, 0x6d, 0x6d, 0x61,
        0x6e, 0x64, 0x52, 0x65, 0x71, 0x75, 0x65, 0x73, 0x74, 0x12, 0x25, 0x0a, 0x0e, 0x63, 0x6f, 0x6e,
        0x6e, 0x65, 0x63, 0x74, 0x6f, 0x72, 0x5f, 0x6e, 0x61, 0x6d, 0x65, 0x18, 0x01, 0x20, 0x01, 0x28,
        0x09, 0x52, 0x0d, 0x63, 0x6f, 0x6e, 0x6e, 0x65, 0x63, 0x74, 0x6f, 0x72, 0x4e, 0x61, 0x6d, 0x65,
        0x12, 0x18, 0x0a, 0x07, 0x63, 0x6f, 0x6d, 0x6d, 0x61, 0x6e, 0x64, 0x18, 0x02, 0x20, 0x01, 0x28,
        0x09, 0x52, 0x07, 0x63, 0x6f, 0x6d, 0x6d, 0x61, 0x6e, 0x64, 0x12, 0x12, 0x0a, 0x04, 0x61, 0x72,
        0x67, 0x73, 0x18, 0x03, 0x20, 0x03, 0x28, 0x09, 0x52, 0x04, 0x61, 0x72, 0x67, 0x73, 0x22, 0x4c,
        0x0a, 0x0f, 0x43, 0x6f, 0x6d, 0x6d, 0x61, 0x6e, 0x64, 0x52, 0x65, 0x73, 0x70, 0x6f, 0x6e, 0x73,
        0x65, 0x12, 0x23, 0x0a, 0x0d, 0x61, 0x66, 0x66, 0x65, 0x63, 0x74, 0x65, 0x64, 0x5f, 0x72, 0x6f,
        0x77, 0x73, 0x18, 0x01, 0x20, 0x01, 0x28, 0x03, 0x52, 0x0c, 0x61, 0x66, 0x66, 0x65, 0x63, 0x74,
        0x65, 0x64, 0x52, 0x6f, 0x77, 0x73, 0x12, 0x14, 0x0a, 0x05, 0x65, 0x72, 0x72, 0x6f, 0x72, 0x18,
        0x02, 0x20, 0x01, 0x28, 0x09, 0x52, 0x05, 0x65, 0x72, 0x72, 0x6f, 0x72, 0x22, 0x16, 0x0a, 0x14,
        0x47, 0x65, 0x74, 0x43, 0x6f, 0x6e, 0x6e, 0x65, 0x63, 0x74, 0x6f, 0x72, 0x73, 0x52, 0x65, 0x71,
        0x75, 0x65, 0x73, 0x74, 0x22, 0x40, 0x0a, 0x15, 0x47, 0x65, 0x74, 0x43, 0x6f, 0x6e, 0x6e, 0x65,
        0x63, 0x74, 0x6f, 0x72, 0x73, 0x52, 0x65, 0x73, 0x70, 0x6f, 0x6e, 0x73, 0x65, 0x12, 0x27, 0x0a,
        0x0f, 0x63, 0x6f, 0x6e, 0x6e, 0x65, 0x63, 0x74, 0x6f, 0x72, 0x5f, 0x6e, 0x61, 0x6d, 0x65, 0x73,
        0x18, 0x01, 0x20, 0x03, 0x28, 0x09, 0x52, 0x0e, 0x63, 0x6f, 0x6e, 0x6e, 0x65, 0x63, 0x74, 0x6f,
        0x72, 0x4e, 0x61, 0x6d, 0x65, 0x73, 0x22, 0x5e, 0x0a, 0x13, 0x41, 0x64, 0x64, 0x43, 0x6f, 0x6e,
        0x6e, 0x65, 0x63, 0x74, 0x6f, 0x72, 0x52, 0x65, 0x71, 0x75, 0x65, 0x73, 0x74, 0x12, 0x12, 0x0a,
        0x04, 0x6e, 0x61, 0x6d, 0x65, 0x18, 0x01, 0x20, 0x01, 0x28, 0x09, 0x52, 0x04, 0x6e, 0x61, 0x6d,
        0x65, 0x12, 0x33, 0x0a, 0x06, 0x63, 0x6f, 0x6e, 0x66, 0x69, 0x67, 0x18, 0x02, 0x20, 0x01, 0x28,
        0x0b, 0x32, 0x1b, 0x2e, 0x64, 0x61, 0x74, 0x61, 0x73, 0x6f, 0x75, 0x72, 0x63, 0x65, 0x2e, 0x43,
        0x6f, 0x6e, 0x6e, 0x65, 0x63, 0x74, 0x6f, 0x72, 0x43, 0x6f, 0x6e, 0x66, 0x69, 0x67, 0x52, 0x06,
        0x63, 0x6f, 0x6e, 0x66, 0x69, 0x67, 0x22, 0xa1, 0x02, 0x0a, 0x0f, 0x43, 0x6f, 0x6e, 0x6e, 0x65,
        0x63, 0x74, 0x6f, 0x72, 0x43, 0x6f, 0x6e, 0x66, 0x69, 0x67, 0x12, 0x12, 0x0a, 0x04, 0x74, 0x79,
        0x70, 0x65, 0x18, 0x01, 0x20, 0x01, 0x28, 0x09, 0x52, 0x04, 0x74, 0x79, 0x70, 0x65, 0x12, 0x12,
        0x0a, 0x04, 0x68, 0x6f, 0x73, 0x74, 0x18, 0x02, 0x20, 0x01, 0x28, 0x09, 0x52, 0x04, 0x68, 0x6f,
        0x73, 0x74, 0x12, 0x12, 0x0a, 0x04, 0x70, 0x6f, 0x72, 0x74, 0x18, 0x03, 0x20, 0x01, 0x28, 0x05,
        0x52, 0x04, 0x70, 0x6f, 0x72, 0x74, 0x12, 0x1a, 0x0a, 0x08, 0x75, 0x73, 0x65, 0x72, 0x6e, 0x61,
        0x6d, 0x65, 0x18, 0x04, 0x20, 0x01, 0x28, 0x09, 0x52, 0x08, 0x75, 0x73, 0x65, 0x72, 0x6e, 0x61,
        0x6d, 0x65, 0x12, 0x1a, 0x0a, 0x08, 0x70, 0x61, 0x73, 0x73, 0x77, 0x6f, 0x72, 0x64, 0x18, 0x05,
        0x20, 0x01, 0x28, 0x09, 0x52, 0x08, 0x70, 0x61, 0x73, 0x73, 0x77, 0x6f, 0x72, 0x64, 0x12, 0x1a,
        0x0a, 0x08, 0x64, 0x61, 0x74, 0x61, 0x62, 0x61, 0x73, 0x65, 0x18, 0x06, 0x20, 0x01, 0x28, 0x09,
        0x52, 0x08, 0x64, 0x61, 0x74, 0x61, 0x62, 0x61, 0x73, 0x65, 0x12, 0x42, 0x0a, 0x07, 0x6f, 0x70,
        0x74, 0x69, 0x6f, 0x6e, 0x73, 0x18, 0x07, 0x20, 0x03, 0x28, 0x0b, 0x32, 0x28, 0x2e, 0x64, 0x61,
        0x74, 0x61, 0x73, 0x6f, 0x75, 0x72, 0x63, 0x65, 0x2e, 0x43, 0x6f, 0x6e, 0x6e, 0x65, 0x63, 0x74,
        0x6f, 0x72, 0x43, 0x6f, 0x6e, 0x66, 0x69, 0x67, 0x2e, 0x4f, 0x70, 0x74, 0x69, 0x6f, 0x6e, 0x73,
        0x45, 0x6e, 0x74, 0x72, 0x79, 0x52, 0x07, 0x6f, 0x70, 0x74, 0x69, 0x6f, 0x6e, 0x73, 0x1a, 0x3a,
        0x0a, 0x0c, 0x4f, 0x70, 0x74, 0x69, 0x6f, 0x6e, 0x73, 0x45, 0x6e, 0x74, 0x72, 0x79, 0x12, 0x10,
        0x0a, 0x03, 0x6b, 0x65, 0x79, 0x18, 0x01, 0x20, 0x01, 0x28, 0x09, 0x52, 0x03, 0x6b, 0x65, 0x79,
        0x12, 0x14, 0x0a, 0x05, 0x76, 0x61, 0x6c, 0x75, 0x65, 0x18, 0x02, 0x20, 0x01, 0x28, 0x09, 0x52,
        0x05, 0x76, 0x61, 0x6c, 0x75, 0x65, 0x3a, 0x02, 0x38, 0x01, 0x22, 0x46, 0x0a, 0x14, 0x41, 0x64,
        0x64, 0x43, 0x6f, 0x6e, 0x6e, 0x65, 0x63, 0x74, 0x6f, 0x72, 0x52, 0x65, 0x73, 0x70, 0x6f, 0x6e,
        0x73, 0x65, 0x12, 0x18, 0x0a, 0x07, 0x73, 0x75, 0x63, 0x63, 0x65, 0x73, 0x73, 0x18, 0x01, 0x20,
        0x01, 0x28, 0x08, 0x52, 0x07, 0x73, 0x75, 0x63, 0x63, 0x65, 0x73, 0x73, 0x12, 0x14, 0x0a, 0x05,
        0x65, 0x72, 0x72, 0x6f, 0x72, 0x18, 0x02, 0x20, 0x01, 0x28, 0x09, 0x52, 0x05, 0x65, 0x72, 0x72,
        0x6f, 0x72, 0x22, 0x2c, 0x0a, 0x16, 0x52, 0x65, 0x6d, 0x6f, 0x76, 0x65, 0x43, 0x6f, 0x6e, 0x6e,
        0x65, 0x63, 0x74, 0x6f, 0x72, 0x52, 0x65, 0x71, 0x75, 0x65, 0x73, 0x74, 0x12, 0x12, 0x0a, 0x04,
        0x6e, 0x61, 0x6d, 0x65, 0x18, 0x01, 0x20, 0x01, 0x28, 0x09, 0x52, 0x04, 0x6e, 0x61, 0x6d, 0x65,
        0x22, 0x49, 0x0a, 0x17, 0x52, 0x65, 0x6d, 0x6f, 0x76, 0x65, 0x43, 0x6f, 0x6e, 0x6e, 0x65, 0x63,
        0x74, 0x6f, 0x72, 0x52, 0x65, 0x73, 0x70, 0x6f, 0x6e, 0x73, 0x65, 0x12, 0x18, 0x0a, 0x07, 0x73,
        0x75, 0x63, 0x63, 0x65, 0x73, 0x73, 0x18, 0x01, 0x20, 0x01, 0x28, 0x08, 0x52, 0x07, 0x73, 0x75,
        0x63, 0x63, 0x65, 0x73, 0x73, 0x12, 0x14, 0x0a, 0x05, 0x65, 0x72, 0x72, 0x6f, 0x72, 0x18, 0x02,
        0x20, 0x01, 0x28, 0x09, 0x52, 0x05, 0x65, 0x72, 0x72, 0x6f, 0x72, 0x32, 0xc7, 0x04, 0x0a, 0x11,
        0x44, 0x61, 0x74, 0x61, 0x53, 0x6f, 0x75, 0x72, 0x63, 0x65, 0x53, 0x65, 0x72, 0x76, 0x69, 0x63,
        0x65, 0x12, 0x44, 0x0a, 0x07, 0x43, 0x6f, 0x6e, 0x6e, 0x65, 0x63, 0x74, 0x12, 0x1a, 0x2e, 0x64,
        0x61, 0x74, 0x61, 0x73, 0x6f, 0x75, 0x72, 0x63, 0x65, 0x2e, 0x43, 0x6f, 0x6e, 0x6e, 0x65, 0x63,
        0x74, 0x52, 0x65, 0x71, 0x75, 0x65, 0x73, 0x74, 0x1a, 0x1b, 0x2e, 0x64, 0x61, 0x74, 0x61, 0x73,
        0x6f, 0x75, 0x72, 0x63, 0x65, 0x2e, 0x43, 0x6f, 0x6e, 0x6e, 0x65, 0x63, 0x74, 0x52, 0x65, 0x73,
        0x70, 0x6f, 0x6e, 0x73, 0x65, 0x22, 0x00, 0x12, 0x4d, 0x0a, 0x0a, 0x44, 0x69, 0x73, 0x63, 0x6f,
        0x6e, 0x6e, 0x65, 0x63, 0x74, 0x12, 0x1d, 0x2e, 0x64, 0x61, 0x74, 0x61, 0x73, 0x6f, 0x75, 0x72,
        0x63, 0x65, 0x2e, 0x44, 0x69, 0x73, 0x63, 0x6f, 0x6e, 0x6e, 0x65, 0x63, 0x74, 0x52, 0x65, 0x71,
        0x75, 0x65, 0x73, 0x74, 0x1a, 0x1e, 0x2e, 0x64, 0x61, 0x74, 0x61, 0x73, 0x6f, 0x75, 0x72, 0x63,
        0x65, 0x2e, 0x44, 0x69, 0x73, 0x63, 0x6f, 0x6e, 0x6e, 0x65, 0x63, 0x74, 0x52, 0x65, 0x73, 0x70,
        0x6f, 0x6e, 0x73, 0x65, 0x22, 0x00, 0x12, 0x45, 0x0a, 0x0c, 0x45, 0x78, 0x65, 0x63, 0x75, 0x74,
        0x65, 0x51, 0x75, 0x65, 0x72, 0x79, 0x12, 0x18, 0x2e, 0x64, 0x61, 0x74, 0x61, 0x73, 0x6f, 0x75,
        0x72, 0x63, 0x65, 0x2e, 0x51, 0x75, 0x65, 0x72, 0x79, 0x52, 0x65, 0x71, 0x75, 0x65, 0x73, 0x74,
        0x1a, 0x19, 0x2e, 0x64, 0x61, 0x74, 0x61, 0x73, 0x6f, 0x75, 0x72, 0x63, 0x65, 0x2e, 0x51, 0x75,
        0x65, 0x72, 0x79, 0x52, 0x65, 0x73, 0x70, 0x6f, 0x6e, 0x73, 0x65, 0x22, 0x00, 0x12, 0x4b, 0x0a,
        0x0e, 0x45, 0x78, 0x65, 0x63, 0x75, 0x74, 0x65, 0x43, 0x6f, 0x6d, 0x6d, 0x61, 0x6e, 0x64, 0x12,
        0x1a, 0x2e, 0x64, 0x61, 0x74, 0x61, 0x73, 0x6f, 0x75, 0x72, 0x63, 0x65, 0x2e, 0x43, 0x6f, 0x6d,
        0x6d, 0x61, 0x6e, 0x64, 0x52, 0x65, 0x71, 0x75, 0x65, 0x73, 0x74, 0x1a, 0x1b, 0x2e, 0x64, 0x61,
        0x74, 0x61, 0x73, 0x6f, 0x75, 0x72, 0x63, 0x65, 0x2e, 0x43, 0x6f, 0x6d, 0x6d, 0x61, 0x6e, 0x64,
        0x52, 0x65, 0x73, 0x70, 0x6f, 0x6e, 0x73, 0x65, 0x22, 0x00, 0x12, 0x56, 0x0a, 0x0d, 0x47, 0x65,
        0x74, 0x43, 0x6f, 0x6e, 0x6e, 0x65, 0x63, 0x74, 0x6f, 0x72, 0x73, 0x12, 0x20, 0x2e, 0x64, 0x61,
        0x74, 0x61, 0x73, 0x6f, 0x75, 0x72, 0x63, 0x65, 0x2e, 0x47, 0x65, 0x74, 0x43, 0x6f, 0x6e, 0x6e,
        0x65, 0x63, 0x74, 0x6f, 0x72, 0x73, 0x52, 0x65, 0x71, 0x75, 0x65, 0x73, 0x74, 0x1a, 0x21, 0x2e,
        0x64, 0x61, 0x74, 0x61, 0x73, 0x6f, 0x75, 0x72, 0x63, 0x65, 0x2e, 0x47, 0x65, 0x74, 0x43, 0x6f,
        0x6e, 0x6e, 0x65, 0x63, 0x74, 0x6f, 0x72, 0x73, 0x52, 0x65, 0x73, 0x70, 0x6f, 0x6e, 0x73, 0x65,
        0x22, 0x00, 0x12, 0x53, 0x0a, 0x0c, 0x41, 0x64, 0x64, 0x43, 0x6f, 0x6e, 0x6e, 0x65, 0x63, 0x74,
        0x6f, 0x72, 0x12, 0x1f, 0x2e, 0x64, 0x61, 0x74, 0x61, 0x73, 0x6f, 0x75, 0x72, 0x63, 0x65, 0x2e,
        0x41, 0x64, 0x64, 0x43, 0x6f, 0x6e, 0x6e, 0x65, 0x63, 0x74, 0x6f, 0x72, 0x52, 0x65, 0x71, 0x75,
        0x65, 0x73, 0x74, 0x1a, 0x20, 0x2e, 0x64, 0x61, 0x74, 0x61, 0x73, 0x6f, 0x75, 0x72, 0x63, 0x65,
        0x2e, 0x41, 0x64, 0x64, 0x43, 0x6f, 0x6e, 0x6e, 0x65, 0x63, 0x74, 0x6f, 0x72, 0x52, 0x65, 0x73,
        0x70, 0x6f, 0x6e, 0x73, 0x65, 0x22, 0x00, 0x12, 0x5c, 0x0a, 0x0f, 0x52, 0x65, 0x6d, 0x6f, 0x76,
        0x65, 0x43, 0x6f, 0x6e, 0x6e, 0x65, 0x63, 0x74, 0x6f, 0x72, 0x12, 0x22, 0x2e, 0x64, 0x61, 0x74,
        0x61, 0x73, 0x6f, 0x75, 0x72, 0x63, 0x65, 0x2e, 0x52, 0x65, 0x6d, 0x6f, 0x76, 0x65, 0x43, 0x6f,
        0x6e, 0x6e, 0x65, 0x63, 0x74, 0x6f, 0x72, 0x52, 0x65, 0x71, 0x75, 0x65, 0x73, 0x74, 0x1a, 0x23,
        0x2e, 0x64, 0x61, 0x74, 0x61, 0x73, 0x6f, 0x75, 0x72, 0x63, 0x65, 0x2e, 0x52, 0x65, 0x6d, 0x6f,
        0x76, 0x65, 0x43, 0x6f, 0x6e, 0x6e, 0x65, 0x63, 0x74, 0x6f, 0x72, 0x52, 0x65, 0x73, 0x70, 0x6f,
        0x6e, 0x73, 0x65, 0x22, 0x00, 0x42, 0x11, 0x5a, 0x0f, 0x64, 0x61, 0x74, 0x61, 0x73, 0x6f, 0x75,
        0x72, 0x63, 0x65, 0x2f, 0x67, 0x72, 0x70, 0x63, 0x62, 0x06, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x33,
}

var (
        file_connector_proto_rawDescOnce sync.Once
        file_connector_proto_rawDescData = file_connector_proto_rawDesc
)

func file_connector_proto_rawDescGZIP() []byte <span class="cov0" title="0">{
        file_connector_proto_rawDescOnce.Do(func() </span><span class="cov0" title="0">{
                file_connector_proto_rawDescData = protoimpl.X.CompressGZIP(file_connector_proto_rawDescData)
        }</span>)
        <span class="cov0" title="0">return file_connector_proto_rawDescData</span>
}

var file_connector_proto_msgTypes = make([]protoimpl.MessageInfo, 16)
var file_connector_proto_goTypes = []any{
        (*ConnectRequest)(nil),          // 0: datasource.ConnectRequest
        (*ConnectResponse)(nil),         // 1: datasource.ConnectResponse
        (*DisconnectRequest)(nil),       // 2: datasource.DisconnectRequest
        (*DisconnectResponse)(nil),      // 3: datasource.DisconnectResponse
        (*QueryRequest)(nil),            // 4: datasource.QueryRequest
        (*QueryResponse)(nil),           // 5: datasource.QueryResponse
        (*CommandRequest)(nil),          // 6: datasource.CommandRequest
        (*CommandResponse)(nil),         // 7: datasource.CommandResponse
        (*GetConnectorsRequest)(nil),    // 8: datasource.GetConnectorsRequest
        (*GetConnectorsResponse)(nil),   // 9: datasource.GetConnectorsResponse
        (*AddConnectorRequest)(nil),     // 10: datasource.AddConnectorRequest
        (*ConnectorConfig)(nil),         // 11: datasource.ConnectorConfig
        (*AddConnectorResponse)(nil),    // 12: datasource.AddConnectorResponse
        (*RemoveConnectorRequest)(nil),  // 13: datasource.RemoveConnectorRequest
        (*RemoveConnectorResponse)(nil), // 14: datasource.RemoveConnectorResponse
        nil,                             // 15: datasource.ConnectorConfig.OptionsEntry
}
var file_connector_proto_depIdxs = []int32{
        11, // 0: datasource.AddConnectorRequest.config:type_name -&gt; datasource.ConnectorConfig
        15, // 1: datasource.ConnectorConfig.options:type_name -&gt; datasource.ConnectorConfig.OptionsEntry
        0,  // 2: datasource.DataSourceService.Connect:input_type -&gt; datasource.ConnectRequest
        2,  // 3: datasource.DataSourceService.Disconnect:input_type -&gt; datasource.DisconnectRequest
        4,  // 4: datasource.DataSourceService.ExecuteQuery:input_type -&gt; datasource.QueryRequest
        6,  // 5: datasource.DataSourceService.ExecuteCommand:input_type -&gt; datasource.CommandRequest
        8,  // 6: datasource.DataSourceService.GetConnectors:input_type -&gt; datasource.GetConnectorsRequest
        10, // 7: datasource.DataSourceService.AddConnector:input_type -&gt; datasource.AddConnectorRequest
        13, // 8: datasource.DataSourceService.RemoveConnector:input_type -&gt; datasource.RemoveConnectorRequest
        1,  // 9: datasource.DataSourceService.Connect:output_type -&gt; datasource.ConnectResponse
        3,  // 10: datasource.DataSourceService.Disconnect:output_type -&gt; datasource.DisconnectResponse
        5,  // 11: datasource.DataSourceService.ExecuteQuery:output_type -&gt; datasource.QueryResponse
        7,  // 12: datasource.DataSourceService.ExecuteCommand:output_type -&gt; datasource.CommandResponse
        9,  // 13: datasource.DataSourceService.GetConnectors:output_type -&gt; datasource.GetConnectorsResponse
        12, // 14: datasource.DataSourceService.AddConnector:output_type -&gt; datasource.AddConnectorResponse
        14, // 15: datasource.DataSourceService.RemoveConnector:output_type -&gt; datasource.RemoveConnectorResponse
        9,  // [9:16] is the sub-list for method output_type
        2,  // [2:9] is the sub-list for method input_type
        2,  // [2:2] is the sub-list for extension type_name
        2,  // [2:2] is the sub-list for extension extendee
        0,  // [0:2] is the sub-list for field type_name
}

func init() <span class="cov0" title="0">{ file_connector_proto_init() }</span>
func file_connector_proto_init() <span class="cov0" title="0">{
        if File_connector_proto != nil </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov0" title="0">if !protoimpl.UnsafeEnabled </span><span class="cov0" title="0">{
                file_connector_proto_msgTypes[0].Exporter = func(v any, i int) any </span><span class="cov0" title="0">{
                        switch v := v.(*ConnectRequest); i </span>{
                        case 0:<span class="cov0" title="0">
                                return &amp;v.state</span>
                        case 1:<span class="cov0" title="0">
                                return &amp;v.sizeCache</span>
                        case 2:<span class="cov0" title="0">
                                return &amp;v.unknownFields</span>
                        default:<span class="cov0" title="0">
                                return nil</span>
                        }
                }
                <span class="cov0" title="0">file_connector_proto_msgTypes[1].Exporter = func(v any, i int) any </span><span class="cov0" title="0">{
                        switch v := v.(*ConnectResponse); i </span>{
                        case 0:<span class="cov0" title="0">
                                return &amp;v.state</span>
                        case 1:<span class="cov0" title="0">
                                return &amp;v.sizeCache</span>
                        case 2:<span class="cov0" title="0">
                                return &amp;v.unknownFields</span>
                        default:<span class="cov0" title="0">
                                return nil</span>
                        }
                }
                <span class="cov0" title="0">file_connector_proto_msgTypes[2].Exporter = func(v any, i int) any </span><span class="cov0" title="0">{
                        switch v := v.(*DisconnectRequest); i </span>{
                        case 0:<span class="cov0" title="0">
                                return &amp;v.state</span>
                        case 1:<span class="cov0" title="0">
                                return &amp;v.sizeCache</span>
                        case 2:<span class="cov0" title="0">
                                return &amp;v.unknownFields</span>
                        default:<span class="cov0" title="0">
                                return nil</span>
                        }
                }
                <span class="cov0" title="0">file_connector_proto_msgTypes[3].Exporter = func(v any, i int) any </span><span class="cov0" title="0">{
                        switch v := v.(*DisconnectResponse); i </span>{
                        case 0:<span class="cov0" title="0">
                                return &amp;v.state</span>
                        case 1:<span class="cov0" title="0">
                                return &amp;v.sizeCache</span>
                        case 2:<span class="cov0" title="0">
                                return &amp;v.unknownFields</span>
                        default:<span class="cov0" title="0">
                                return nil</span>
                        }
                }
                <span class="cov0" title="0">file_connector_proto_msgTypes[4].Exporter = func(v any, i int) any </span><span class="cov0" title="0">{
                        switch v := v.(*QueryRequest); i </span>{
                        case 0:<span class="cov0" title="0">
                                return &amp;v.state</span>
                        case 1:<span class="cov0" title="0">
                                return &amp;v.sizeCache</span>
                        case 2:<span class="cov0" title="0">
                                return &amp;v.unknownFields</span>
                        default:<span class="cov0" title="0">
                                return nil</span>
                        }
                }
                <span class="cov0" title="0">file_connector_proto_msgTypes[5].Exporter = func(v any, i int) any </span><span class="cov0" title="0">{
                        switch v := v.(*QueryResponse); i </span>{
                        case 0:<span class="cov0" title="0">
                                return &amp;v.state</span>
                        case 1:<span class="cov0" title="0">
                                return &amp;v.sizeCache</span>
                        case 2:<span class="cov0" title="0">
                                return &amp;v.unknownFields</span>
                        default:<span class="cov0" title="0">
                                return nil</span>
                        }
                }
                <span class="cov0" title="0">file_connector_proto_msgTypes[6].Exporter = func(v any, i int) any </span><span class="cov0" title="0">{
                        switch v := v.(*CommandRequest); i </span>{
                        case 0:<span class="cov0" title="0">
                                return &amp;v.state</span>
                        case 1:<span class="cov0" title="0">
                                return &amp;v.sizeCache</span>
                        case 2:<span class="cov0" title="0">
                                return &amp;v.unknownFields</span>
                        default:<span class="cov0" title="0">
                                return nil</span>
                        }
                }
                <span class="cov0" title="0">file_connector_proto_msgTypes[7].Exporter = func(v any, i int) any </span><span class="cov0" title="0">{
                        switch v := v.(*CommandResponse); i </span>{
                        case 0:<span class="cov0" title="0">
                                return &amp;v.state</span>
                        case 1:<span class="cov0" title="0">
                                return &amp;v.sizeCache</span>
                        case 2:<span class="cov0" title="0">
                                return &amp;v.unknownFields</span>
                        default:<span class="cov0" title="0">
                                return nil</span>
                        }
                }
                <span class="cov0" title="0">file_connector_proto_msgTypes[8].Exporter = func(v any, i int) any </span><span class="cov0" title="0">{
                        switch v := v.(*GetConnectorsRequest); i </span>{
                        case 0:<span class="cov0" title="0">
                                return &amp;v.state</span>
                        case 1:<span class="cov0" title="0">
                                return &amp;v.sizeCache</span>
                        case 2:<span class="cov0" title="0">
                                return &amp;v.unknownFields</span>
                        default:<span class="cov0" title="0">
                                return nil</span>
                        }
                }
                <span class="cov0" title="0">file_connector_proto_msgTypes[9].Exporter = func(v any, i int) any </span><span class="cov0" title="0">{
                        switch v := v.(*GetConnectorsResponse); i </span>{
                        case 0:<span class="cov0" title="0">
                                return &amp;v.state</span>
                        case 1:<span class="cov0" title="0">
                                return &amp;v.sizeCache</span>
                        case 2:<span class="cov0" title="0">
                                return &amp;v.unknownFields</span>
                        default:<span class="cov0" title="0">
                                return nil</span>
                        }
                }
                <span class="cov0" title="0">file_connector_proto_msgTypes[10].Exporter = func(v any, i int) any </span><span class="cov0" title="0">{
                        switch v := v.(*AddConnectorRequest); i </span>{
                        case 0:<span class="cov0" title="0">
                                return &amp;v.state</span>
                        case 1:<span class="cov0" title="0">
                                return &amp;v.sizeCache</span>
                        case 2:<span class="cov0" title="0">
                                return &amp;v.unknownFields</span>
                        default:<span class="cov0" title="0">
                                return nil</span>
                        }
                }
                <span class="cov0" title="0">file_connector_proto_msgTypes[11].Exporter = func(v any, i int) any </span><span class="cov0" title="0">{
                        switch v := v.(*ConnectorConfig); i </span>{
                        case 0:<span class="cov0" title="0">
                                return &amp;v.state</span>
                        case 1:<span class="cov0" title="0">
                                return &amp;v.sizeCache</span>
                        case 2:<span class="cov0" title="0">
                                return &amp;v.unknownFields</span>
                        default:<span class="cov0" title="0">
                                return nil</span>
                        }
                }
                <span class="cov0" title="0">file_connector_proto_msgTypes[12].Exporter = func(v any, i int) any </span><span class="cov0" title="0">{
                        switch v := v.(*AddConnectorResponse); i </span>{
                        case 0:<span class="cov0" title="0">
                                return &amp;v.state</span>
                        case 1:<span class="cov0" title="0">
                                return &amp;v.sizeCache</span>
                        case 2:<span class="cov0" title="0">
                                return &amp;v.unknownFields</span>
                        default:<span class="cov0" title="0">
                                return nil</span>
                        }
                }
                <span class="cov0" title="0">file_connector_proto_msgTypes[13].Exporter = func(v any, i int) any </span><span class="cov0" title="0">{
                        switch v := v.(*RemoveConnectorRequest); i </span>{
                        case 0:<span class="cov0" title="0">
                                return &amp;v.state</span>
                        case 1:<span class="cov0" title="0">
                                return &amp;v.sizeCache</span>
                        case 2:<span class="cov0" title="0">
                                return &amp;v.unknownFields</span>
                        default:<span class="cov0" title="0">
                                return nil</span>
                        }
                }
                <span class="cov0" title="0">file_connector_proto_msgTypes[14].Exporter = func(v any, i int) any </span><span class="cov0" title="0">{
                        switch v := v.(*RemoveConnectorResponse); i </span>{
                        case 0:<span class="cov0" title="0">
                                return &amp;v.state</span>
                        case 1:<span class="cov0" title="0">
                                return &amp;v.sizeCache</span>
                        case 2:<span class="cov0" title="0">
                                return &amp;v.unknownFields</span>
                        default:<span class="cov0" title="0">
                                return nil</span>
                        }
                }
        }
        <span class="cov0" title="0">type x struct{}
        out := protoimpl.TypeBuilder{
                File: protoimpl.DescBuilder{
                        GoPackagePath: reflect.TypeOf(x{}).PkgPath(),
                        RawDescriptor: file_connector_proto_rawDesc,
                        NumEnums:      0,
                        NumMessages:   16,
                        NumExtensions: 0,
                        NumServices:   1,
                },
                GoTypes:           file_connector_proto_goTypes,
                DependencyIndexes: file_connector_proto_depIdxs,
                MessageInfos:      file_connector_proto_msgTypes,
        }.Build()
        File_connector_proto = out.File
        file_connector_proto_rawDesc = nil
        file_connector_proto_goTypes = nil
        file_connector_proto_depIdxs = nil</span>
}
</pre>
		
		<pre class="file" id="file60" style="display: none">// Code generated by protoc-gen-go-grpc. DO NOT EDIT.
// versions:
// - protoc-gen-go-grpc v1.4.0
// - protoc             v3.21.12
// source: connector.proto

package grpc

import (
        context "context"

        grpc "google.golang.org/grpc"
        codes "google.golang.org/grpc/codes"
        status "google.golang.org/grpc/status"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
// Requires gRPC-Go v1.62.0 or later.
const _ = grpc.SupportPackageIsVersion8

const (
        DataSourceService_Connect_FullMethodName         = "/datasource.DataSourceService/Connect"
        DataSourceService_Disconnect_FullMethodName      = "/datasource.DataSourceService/Disconnect"
        DataSourceService_ExecuteQuery_FullMethodName    = "/datasource.DataSourceService/ExecuteQuery"
        DataSourceService_ExecuteCommand_FullMethodName  = "/datasource.DataSourceService/ExecuteCommand"
        DataSourceService_GetConnectors_FullMethodName   = "/datasource.DataSourceService/GetConnectors"
        DataSourceService_AddConnector_FullMethodName    = "/datasource.DataSourceService/AddConnector"
        DataSourceService_RemoveConnector_FullMethodName = "/datasource.DataSourceService/RemoveConnector"
)

// DataSourceServiceClient is the client API for DataSourceService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type DataSourceServiceClient interface {
        Connect(ctx context.Context, in *ConnectRequest, opts ...grpc.CallOption) (*ConnectResponse, error)
        Disconnect(ctx context.Context, in *DisconnectRequest, opts ...grpc.CallOption) (*DisconnectResponse, error)
        ExecuteQuery(ctx context.Context, in *QueryRequest, opts ...grpc.CallOption) (*QueryResponse, error)
        ExecuteCommand(ctx context.Context, in *CommandRequest, opts ...grpc.CallOption) (*CommandResponse, error)
        GetConnectors(ctx context.Context, in *GetConnectorsRequest, opts ...grpc.CallOption) (*GetConnectorsResponse, error)
        AddConnector(ctx context.Context, in *AddConnectorRequest, opts ...grpc.CallOption) (*AddConnectorResponse, error)
        RemoveConnector(ctx context.Context, in *RemoveConnectorRequest, opts ...grpc.CallOption) (*RemoveConnectorResponse, error)
}

type dataSourceServiceClient struct {
        cc grpc.ClientConnInterface
}

func NewDataSourceServiceClient(cc grpc.ClientConnInterface) DataSourceServiceClient <span class="cov0" title="0">{
        return &amp;dataSourceServiceClient{cc}
}</span>

func (c *dataSourceServiceClient) Connect(ctx context.Context, in *ConnectRequest, opts ...grpc.CallOption) (*ConnectResponse, error) <span class="cov0" title="0">{
        cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
        out := new(ConnectResponse)
        err := c.cc.Invoke(ctx, DataSourceService_Connect_FullMethodName, in, out, cOpts...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return out, nil</span>
}

func (c *dataSourceServiceClient) Disconnect(ctx context.Context, in *DisconnectRequest, opts ...grpc.CallOption) (*DisconnectResponse, error) <span class="cov0" title="0">{
        cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
        out := new(DisconnectResponse)
        err := c.cc.Invoke(ctx, DataSourceService_Disconnect_FullMethodName, in, out, cOpts...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return out, nil</span>
}

func (c *dataSourceServiceClient) ExecuteQuery(ctx context.Context, in *QueryRequest, opts ...grpc.CallOption) (*QueryResponse, error) <span class="cov0" title="0">{
        cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
        out := new(QueryResponse)
        err := c.cc.Invoke(ctx, DataSourceService_ExecuteQuery_FullMethodName, in, out, cOpts...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return out, nil</span>
}

func (c *dataSourceServiceClient) ExecuteCommand(ctx context.Context, in *CommandRequest, opts ...grpc.CallOption) (*CommandResponse, error) <span class="cov0" title="0">{
        cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
        out := new(CommandResponse)
        err := c.cc.Invoke(ctx, DataSourceService_ExecuteCommand_FullMethodName, in, out, cOpts...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return out, nil</span>
}

func (c *dataSourceServiceClient) GetConnectors(ctx context.Context, in *GetConnectorsRequest, opts ...grpc.CallOption) (*GetConnectorsResponse, error) <span class="cov0" title="0">{
        cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
        out := new(GetConnectorsResponse)
        err := c.cc.Invoke(ctx, DataSourceService_GetConnectors_FullMethodName, in, out, cOpts...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return out, nil</span>
}

func (c *dataSourceServiceClient) AddConnector(ctx context.Context, in *AddConnectorRequest, opts ...grpc.CallOption) (*AddConnectorResponse, error) <span class="cov0" title="0">{
        cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
        out := new(AddConnectorResponse)
        err := c.cc.Invoke(ctx, DataSourceService_AddConnector_FullMethodName, in, out, cOpts...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return out, nil</span>
}

func (c *dataSourceServiceClient) RemoveConnector(ctx context.Context, in *RemoveConnectorRequest, opts ...grpc.CallOption) (*RemoveConnectorResponse, error) <span class="cov0" title="0">{
        cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
        out := new(RemoveConnectorResponse)
        err := c.cc.Invoke(ctx, DataSourceService_RemoveConnector_FullMethodName, in, out, cOpts...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return out, nil</span>
}

// DataSourceServiceServer is the server API for DataSourceService service.
// All implementations must embed UnimplementedDataSourceServiceServer
// for forward compatibility
type DataSourceServiceServer interface {
        Connect(context.Context, *ConnectRequest) (*ConnectResponse, error)
        Disconnect(context.Context, *DisconnectRequest) (*DisconnectResponse, error)
        ExecuteQuery(context.Context, *QueryRequest) (*QueryResponse, error)
        ExecuteCommand(context.Context, *CommandRequest) (*CommandResponse, error)
        GetConnectors(context.Context, *GetConnectorsRequest) (*GetConnectorsResponse, error)
        AddConnector(context.Context, *AddConnectorRequest) (*AddConnectorResponse, error)
        RemoveConnector(context.Context, *RemoveConnectorRequest) (*RemoveConnectorResponse, error)
        mustEmbedUnimplementedDataSourceServiceServer()
}

// UnimplementedDataSourceServiceServer must be embedded to have forward compatible implementations.
type UnimplementedDataSourceServiceServer struct {
}

func (UnimplementedDataSourceServiceServer) Connect(context.Context, *ConnectRequest) (*ConnectResponse, error) <span class="cov0" title="0">{
        return nil, status.Errorf(codes.Unimplemented, "method Connect not implemented")
}</span>
func (UnimplementedDataSourceServiceServer) Disconnect(context.Context, *DisconnectRequest) (*DisconnectResponse, error) <span class="cov0" title="0">{
        return nil, status.Errorf(codes.Unimplemented, "method Disconnect not implemented")
}</span>
func (UnimplementedDataSourceServiceServer) ExecuteQuery(context.Context, *QueryRequest) (*QueryResponse, error) <span class="cov0" title="0">{
        return nil, status.Errorf(codes.Unimplemented, "method ExecuteQuery not implemented")
}</span>
func (UnimplementedDataSourceServiceServer) ExecuteCommand(context.Context, *CommandRequest) (*CommandResponse, error) <span class="cov0" title="0">{
        return nil, status.Errorf(codes.Unimplemented, "method ExecuteCommand not implemented")
}</span>
func (UnimplementedDataSourceServiceServer) GetConnectors(context.Context, *GetConnectorsRequest) (*GetConnectorsResponse, error) <span class="cov0" title="0">{
        return nil, status.Errorf(codes.Unimplemented, "method GetConnectors not implemented")
}</span>
func (UnimplementedDataSourceServiceServer) AddConnector(context.Context, *AddConnectorRequest) (*AddConnectorResponse, error) <span class="cov0" title="0">{
        return nil, status.Errorf(codes.Unimplemented, "method AddConnector not implemented")
}</span>
func (UnimplementedDataSourceServiceServer) RemoveConnector(context.Context, *RemoveConnectorRequest) (*RemoveConnectorResponse, error) <span class="cov0" title="0">{
        return nil, status.Errorf(codes.Unimplemented, "method RemoveConnector not implemented")
}</span>
func (UnimplementedDataSourceServiceServer) mustEmbedUnimplementedDataSourceServiceServer() {<span class="cov0" title="0">}</span>

// UnsafeDataSourceServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to DataSourceServiceServer will
// result in compilation errors.
type UnsafeDataSourceServiceServer interface {
        mustEmbedUnimplementedDataSourceServiceServer()
}

func RegisterDataSourceServiceServer(s grpc.ServiceRegistrar, srv DataSourceServiceServer) <span class="cov0" title="0">{
        s.RegisterService(&amp;DataSourceService_ServiceDesc, srv)
}</span>

func _DataSourceService_Connect_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) <span class="cov0" title="0">{
        in := new(ConnectRequest)
        if err := dec(in); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">if interceptor == nil </span><span class="cov0" title="0">{
                return srv.(DataSourceServiceServer).Connect(ctx, in)
        }</span>
        <span class="cov0" title="0">info := &amp;grpc.UnaryServerInfo{
                Server:     srv,
                FullMethod: DataSourceService_Connect_FullMethodName,
        }
        handler := func(ctx context.Context, req interface{}) (interface{}, error) </span><span class="cov0" title="0">{
                return srv.(DataSourceServiceServer).Connect(ctx, req.(*ConnectRequest))
        }</span>
        <span class="cov0" title="0">return interceptor(ctx, in, info, handler)</span>
}

func _DataSourceService_Disconnect_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) <span class="cov0" title="0">{
        in := new(DisconnectRequest)
        if err := dec(in); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">if interceptor == nil </span><span class="cov0" title="0">{
                return srv.(DataSourceServiceServer).Disconnect(ctx, in)
        }</span>
        <span class="cov0" title="0">info := &amp;grpc.UnaryServerInfo{
                Server:     srv,
                FullMethod: DataSourceService_Disconnect_FullMethodName,
        }
        handler := func(ctx context.Context, req interface{}) (interface{}, error) </span><span class="cov0" title="0">{
                return srv.(DataSourceServiceServer).Disconnect(ctx, req.(*DisconnectRequest))
        }</span>
        <span class="cov0" title="0">return interceptor(ctx, in, info, handler)</span>
}

func _DataSourceService_ExecuteQuery_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) <span class="cov0" title="0">{
        in := new(QueryRequest)
        if err := dec(in); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">if interceptor == nil </span><span class="cov0" title="0">{
                return srv.(DataSourceServiceServer).ExecuteQuery(ctx, in)
        }</span>
        <span class="cov0" title="0">info := &amp;grpc.UnaryServerInfo{
                Server:     srv,
                FullMethod: DataSourceService_ExecuteQuery_FullMethodName,
        }
        handler := func(ctx context.Context, req interface{}) (interface{}, error) </span><span class="cov0" title="0">{
                return srv.(DataSourceServiceServer).ExecuteQuery(ctx, req.(*QueryRequest))
        }</span>
        <span class="cov0" title="0">return interceptor(ctx, in, info, handler)</span>
}

func _DataSourceService_ExecuteCommand_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) <span class="cov0" title="0">{
        in := new(CommandRequest)
        if err := dec(in); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">if interceptor == nil </span><span class="cov0" title="0">{
                return srv.(DataSourceServiceServer).ExecuteCommand(ctx, in)
        }</span>
        <span class="cov0" title="0">info := &amp;grpc.UnaryServerInfo{
                Server:     srv,
                FullMethod: DataSourceService_ExecuteCommand_FullMethodName,
        }
        handler := func(ctx context.Context, req interface{}) (interface{}, error) </span><span class="cov0" title="0">{
                return srv.(DataSourceServiceServer).ExecuteCommand(ctx, req.(*CommandRequest))
        }</span>
        <span class="cov0" title="0">return interceptor(ctx, in, info, handler)</span>
}

func _DataSourceService_GetConnectors_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) <span class="cov0" title="0">{
        in := new(GetConnectorsRequest)
        if err := dec(in); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">if interceptor == nil </span><span class="cov0" title="0">{
                return srv.(DataSourceServiceServer).GetConnectors(ctx, in)
        }</span>
        <span class="cov0" title="0">info := &amp;grpc.UnaryServerInfo{
                Server:     srv,
                FullMethod: DataSourceService_GetConnectors_FullMethodName,
        }
        handler := func(ctx context.Context, req interface{}) (interface{}, error) </span><span class="cov0" title="0">{
                return srv.(DataSourceServiceServer).GetConnectors(ctx, req.(*GetConnectorsRequest))
        }</span>
        <span class="cov0" title="0">return interceptor(ctx, in, info, handler)</span>
}

func _DataSourceService_AddConnector_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) <span class="cov0" title="0">{
        in := new(AddConnectorRequest)
        if err := dec(in); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">if interceptor == nil </span><span class="cov0" title="0">{
                return srv.(DataSourceServiceServer).AddConnector(ctx, in)
        }</span>
        <span class="cov0" title="0">info := &amp;grpc.UnaryServerInfo{
                Server:     srv,
                FullMethod: DataSourceService_AddConnector_FullMethodName,
        }
        handler := func(ctx context.Context, req interface{}) (interface{}, error) </span><span class="cov0" title="0">{
                return srv.(DataSourceServiceServer).AddConnector(ctx, req.(*AddConnectorRequest))
        }</span>
        <span class="cov0" title="0">return interceptor(ctx, in, info, handler)</span>
}

func _DataSourceService_RemoveConnector_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) <span class="cov0" title="0">{
        in := new(RemoveConnectorRequest)
        if err := dec(in); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">if interceptor == nil </span><span class="cov0" title="0">{
                return srv.(DataSourceServiceServer).RemoveConnector(ctx, in)
        }</span>
        <span class="cov0" title="0">info := &amp;grpc.UnaryServerInfo{
                Server:     srv,
                FullMethod: DataSourceService_RemoveConnector_FullMethodName,
        }
        handler := func(ctx context.Context, req interface{}) (interface{}, error) </span><span class="cov0" title="0">{
                return srv.(DataSourceServiceServer).RemoveConnector(ctx, req.(*RemoveConnectorRequest))
        }</span>
        <span class="cov0" title="0">return interceptor(ctx, in, info, handler)</span>
}

// DataSourceService_ServiceDesc is the grpc.ServiceDesc for DataSourceService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var DataSourceService_ServiceDesc = grpc.ServiceDesc{
        ServiceName: "datasource.DataSourceService",
        HandlerType: (*DataSourceServiceServer)(nil),
        Methods: []grpc.MethodDesc{
                {
                        MethodName: "Connect",
                        Handler:    _DataSourceService_Connect_Handler,
                },
                {
                        MethodName: "Disconnect",
                        Handler:    _DataSourceService_Disconnect_Handler,
                },
                {
                        MethodName: "ExecuteQuery",
                        Handler:    _DataSourceService_ExecuteQuery_Handler,
                },
                {
                        MethodName: "ExecuteCommand",
                        Handler:    _DataSourceService_ExecuteCommand_Handler,
                },
                {
                        MethodName: "GetConnectors",
                        Handler:    _DataSourceService_GetConnectors_Handler,
                },
                {
                        MethodName: "AddConnector",
                        Handler:    _DataSourceService_AddConnector_Handler,
                },
                {
                        MethodName: "RemoveConnector",
                        Handler:    _DataSourceService_RemoveConnector_Handler,
                },
        },
        Streams:  []grpc.StreamDesc{},
        Metadata: "connector.proto",
}
</pre>
		
		<pre class="file" id="file61" style="display: none">package server

import (
        "context"
        "encoding/json"
        "fmt"
        "log"

        "google.golang.org/grpc/codes"
        "google.golang.org/grpc/status"

        "datasource/connectors"
        "datasource/grpc"
        manager "datasource/managers"
        "datasource/managers/query"
)

type DataSourceServer struct {
        grpc.UnimplementedDataSourceServiceServer
        manager *manager.ConnectorManager
}

func NewDataSourceServer(manager *manager.ConnectorManager) *DataSourceServer <span class="cov0" title="0">{
        return &amp;DataSourceServer{manager: manager}
}</span>

func (s *DataSourceServer) Connect(ctx context.Context, req *grpc.ConnectRequest) (*grpc.ConnectResponse, error) <span class="cov0" title="0">{
        log.Printf("Received Connect request for connector: %s", req.ConnectorName)

        connector, err := s.manager.GetConnector(req.ConnectorName)
        if err != nil </span><span class="cov0" title="0">{
                log.Printf("Error getting connector %s: %v", req.ConnectorName, err)
                return &amp;grpc.ConnectResponse{Success: false, Error: err.Error()}, nil
        }</span>

        <span class="cov0" title="0">err = connector.Connect(ctx)
        if err != nil </span><span class="cov0" title="0">{
                log.Printf("Error connecting to %s: %v", req.ConnectorName, err)
                return &amp;grpc.ConnectResponse{Success: false, Error: err.Error()}, nil
        }</span>

        <span class="cov0" title="0">log.Printf("Successfully connected to %s", req.ConnectorName)
        return &amp;grpc.ConnectResponse{Success: true}, nil</span>
}

func (s *DataSourceServer) Disconnect(ctx context.Context, req *grpc.DisconnectRequest) (*grpc.DisconnectResponse, error) <span class="cov0" title="0">{
        log.Printf("Received Disconnect request for connector: %s", req.ConnectorName)

        connector, err := s.manager.GetConnector(req.ConnectorName)
        if err != nil </span><span class="cov0" title="0">{
                log.Printf("Error getting connector %s: %v", req.ConnectorName, err)
                return &amp;grpc.DisconnectResponse{Success: false, Error: err.Error()}, nil
        }</span>

        <span class="cov0" title="0">err = connector.Close(ctx)
        if err != nil </span><span class="cov0" title="0">{
                log.Printf("Error disconnecting from %s: %v", req.ConnectorName, err)
                return &amp;grpc.DisconnectResponse{Success: false, Error: err.Error()}, nil
        }</span>

        <span class="cov0" title="0">log.Printf("Successfully disconnected from %s", req.ConnectorName)
        return &amp;grpc.DisconnectResponse{Success: true}, nil</span>
}

func (s *DataSourceServer) ExecuteQuery(ctx context.Context, req *grpc.QueryRequest) (*grpc.QueryResponse, error) <span class="cov0" title="0">{
        log.Printf("Received ExecuteQuery request for connector: %s", req.ConnectorName)

        connector, err := s.manager.GetConnector(req.ConnectorName)
        if err != nil </span><span class="cov0" title="0">{
                log.Printf("Error getting connector %s: %v", req.ConnectorName, err)
                return nil, status.Errorf(codes.NotFound, "connector not found: %v", err)
        }</span>

        <span class="cov0" title="0">executor := query.NewQueryExecutor(connector)

        var q query.Query
        err = json.Unmarshal([]byte(req.Query), &amp;q)
        if err != nil </span><span class="cov0" title="0">{
                log.Printf("Error unmarshalling query: %v", err)
                return nil, status.Errorf(codes.InvalidArgument, "invalid query: %v", err)
        }</span>

        <span class="cov0" title="0">results, err := executor.Execute(ctx, q)
        if err != nil </span><span class="cov0" title="0">{
                log.Printf("Error executing query: %v", err)
                return nil, status.Errorf(codes.Internal, "query execution failed: %v", err)
        }</span>

        <span class="cov0" title="0">var rows [][]byte
        for _, result := range results </span><span class="cov0" title="0">{
                rowBytes, err := json.Marshal(result)
                if err != nil </span><span class="cov0" title="0">{
                        log.Printf("Error marshalling result: %v", err)
                        return nil, status.Errorf(codes.Internal, "failed to marshal result: %v", err)
                }</span>
                <span class="cov0" title="0">rows = append(rows, rowBytes)</span>
        }

        <span class="cov0" title="0">log.Printf("Successfully executed query on %s, returned %d rows", req.ConnectorName, len(rows))
        return &amp;grpc.QueryResponse{Rows: rows}, nil</span>
}

func (s *DataSourceServer) ExecuteCommand(ctx context.Context, req *grpc.CommandRequest) (*grpc.CommandResponse, error) <span class="cov0" title="0">{
        log.Printf("Received ExecuteCommand request for connector: %s", req.ConnectorName)

        connector, err := s.manager.GetConnector(req.ConnectorName)
        if err != nil </span><span class="cov0" title="0">{
                log.Printf("Error getting connector %s: %v", req.ConnectorName, err)
                return nil, status.Errorf(codes.NotFound, "connector not found: %v", err)
        }</span>

        <span class="cov0" title="0">affected, err := connector.Execute(ctx, req.Command, req.Args)
        if err != nil </span><span class="cov0" title="0">{
                log.Printf("Error executing command on %s: %v", req.ConnectorName, err)
                return nil, status.Errorf(codes.Internal, "command execution failed: %v", err)
        }</span>

        <span class="cov0" title="0">log.Printf("Successfully executed command on %s, affected %d rows", req.ConnectorName, affected)
        return &amp;grpc.CommandResponse{AffectedRows: affected}, nil</span>
}

// func (s *DataSourceServer) GetConnectors(ctx context.Context, req *grpc.GetConnectorsRequest) (*grpc.GetConnectorsResponse, error) {
//         log.Printf("Received GetConnectors request")

//         connectorNames, err := s.manager.GetConnector()
//         log.Printf("Retrieved %d connectors", len(connectorNames))
//         return &amp;grpc.GetConnectorsResponse{ConnectorNames: connectorNames}, nil
// }

func (s *DataSourceServer) AddConnector(ctx context.Context, req *grpc.AddConnectorRequest) (*grpc.AddConnectorResponse, error) <span class="cov0" title="0">{
        log.Printf("Received AddConnector request for connector: %s", req.Name)

        config := &amp;connectors.Config{
                Type:     req.Config.Type,
                Host:     req.Config.Host,
                Port:     int(req.Config.Port),
                Username: req.Config.Username,
                Password: req.Config.Password,
                Database: req.Config.Database,
        }

        for k, v := range req.Config.Options </span><span class="cov0" title="0">{
                if config.Options == nil </span><span class="cov0" title="0">{
                        config.Options = make(map[string]interface{})
                }</span>
                <span class="cov0" title="0">config.Options[k] = v</span>
        }

        <span class="cov0" title="0">err := s.manager.AddConnector(req.Name, config)
        if err != nil </span><span class="cov0" title="0">{
                log.Printf("Error adding connector %s: %v", req.Name, err)
                return &amp;grpc.AddConnectorResponse{Success: false, Error: err.Error()}, nil
        }</span>

        <span class="cov0" title="0">log.Printf("Successfully added connector: %s", req.Name)
        return &amp;grpc.AddConnectorResponse{Success: true}, nil</span>
}

func (s *DataSourceServer) RemoveConnector(ctx context.Context, req *grpc.RemoveConnectorRequest) (*grpc.RemoveConnectorResponse, error) <span class="cov0" title="0">{
        log.Printf("Received RemoveConnector request for connector: %s", req.Name)

        err := s.manager.RemoveConnector(req.Name)
        if err != nil </span><span class="cov0" title="0">{
                log.Printf("Error removing connector %s: %v", req.Name, err)
                return &amp;grpc.RemoveConnectorResponse{Success: false, Error: err.Error()}, nil
        }</span>

        <span class="cov0" title="0">log.Printf("Successfully removed connector: %s", req.Name)
        return &amp;grpc.RemoveConnectorResponse{Success: true}, nil</span>
}

func (s *DataSourceServer) validateConnectorConfig(config *grpc.ConnectorConfig) error <span class="cov0" title="0">{
        if config.Type == "" </span><span class="cov0" title="0">{
                return fmt.Errorf("connector type is required")
        }</span>
        <span class="cov0" title="0">if config.Host == "" </span><span class="cov0" title="0">{
                return fmt.Errorf("host is required")
        }</span>
        <span class="cov0" title="0">if config.Port == 0 </span><span class="cov0" title="0">{
                return fmt.Errorf("port is required")
        }</span>
        // Add more validation as needed
        <span class="cov0" title="0">return nil</span>
}
</pre>
		
		<pre class="file" id="file62" style="display: none">package manager

import (
        "context"
        "fmt"
        "sync"

        "datasource/connectors"
        "pkg/common/errors"
)

// ConnectorManager manages multiple data source connectors.
type ConnectorManager struct {
        connectors map[string]connectors.Connector
        mu         sync.RWMutex
}

// NewConnectorManager creates a new ConnectorManager.
func NewConnectorManager() *ConnectorManager <span class="cov0" title="0">{
        return &amp;ConnectorManager{
                connectors: make(map[string]connectors.Connector),
        }
}</span>

// AddConnector adds a new connector with the given name.
func (m *ConnectorManager) AddConnector(name string, config *connectors.Config) error <span class="cov0" title="0">{
        m.mu.Lock()
        defer m.mu.Unlock()

        if _, exists := m.connectors[name]; exists </span><span class="cov0" title="0">{
                return errors.NewError(errors.ErrorTypeConfiguration, "connector with this name already exists", nil)
        }</span>

        <span class="cov0" title="0">connector, err := connectors.ConnectorFactory(config)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">m.connectors[name] = connector
        return nil</span>
}

// GetConnector retrieves a connector by name.
func (m *ConnectorManager) GetConnector(name string) (connectors.Connector, error) <span class="cov0" title="0">{
        m.mu.RLock()
        defer m.mu.RUnlock()

        connector, exists := m.connectors[name]
        if !exists </span><span class="cov0" title="0">{
                return nil, errors.NewError(errors.ErrorTypeNotFound, fmt.Sprintf("connector '%s' not found", name), nil)
        }</span>

        <span class="cov0" title="0">return connector, nil</span>
}

// RemoveConnector removes a connector by name.
func (m *ConnectorManager) RemoveConnector(name string) error <span class="cov0" title="0">{
        m.mu.Lock()
        defer m.mu.Unlock()

        if _, exists := m.connectors[name]; !exists </span><span class="cov0" title="0">{
                return errors.NewError(errors.ErrorTypeNotFound, fmt.Sprintf("connector '%s' not found", name), nil)
        }</span>

        <span class="cov0" title="0">delete(m.connectors, name)
        return nil</span>
}

// ConnectAll connects all managed connectors.
func (m *ConnectorManager) ConnectAll(ctx context.Context) error <span class="cov0" title="0">{
        m.mu.RLock()
        defer m.mu.RUnlock()

        for name, connector := range m.connectors </span><span class="cov0" title="0">{
                if err := connector.Connect(ctx); err != nil </span><span class="cov0" title="0">{
                        return errors.NewError(errors.ErrorTypeConnection, fmt.Sprintf("failed to connect '%s'", name), err)
                }</span>
        }

        <span class="cov0" title="0">return nil</span>
}

// CloseAll closes all managed connectors.
func (m *ConnectorManager) CloseAll(ctx context.Context) error <span class="cov0" title="0">{
        m.mu.RLock()
        defer m.mu.RUnlock()

        for name, connector := range m.connectors </span><span class="cov0" title="0">{
                if err := connector.Close(ctx); err != nil </span><span class="cov0" title="0">{
                        return errors.NewError(errors.ErrorTypeConnection, fmt.Sprintf("failed to close '%s'", name), err)
                }</span>
        }

        <span class="cov0" title="0">return nil</span>
}
</pre>
		
		<pre class="file" id="file63" style="display: none">package query

import (
        "context"
        "encoding/json"
        "fmt"
        "strings"

        "datasource/connectors"
        "pkg/common/errors"
)

// QueryType represents the type of query operation
type QueryType string

const (
        Select QueryType = "SELECT"
        Insert QueryType = "INSERT"
        Update QueryType = "UPDATE"
        Delete QueryType = "DELETE"
)

// Query represents a unified query structure
type Query struct {
        Type       QueryType              `json:"type"`
        Collection string                 `json:"collection"`
        Fields     []string               `json:"fields,omitempty"`
        Conditions map[string]interface{} `json:"conditions,omitempty"`
        Data       map[string]interface{} `json:"data,omitempty"`
        Limit      int                    `json:"limit,omitempty"`
        Offset     int                    `json:"offset,omitempty"`
}

// QueryExecutor handles query execution across different connector types
type QueryExecutor struct {
        connector connectors.Connector
}

// NewQueryExecutor creates a new QueryExecutor
func NewQueryExecutor(connector connectors.Connector) *QueryExecutor <span class="cov0" title="0">{
        return &amp;QueryExecutor{connector: connector}
}</span>

// Execute executes the given query on the appropriate connector
func (qe *QueryExecutor) Execute(ctx context.Context, query Query) ([]map[string]interface{}, error) <span class="cov0" title="0">{
        switch c := qe.connector.(type) </span>{
        case *connectors.SQLConnector:<span class="cov0" title="0">
                return qe.executeSQL(ctx, c, query)</span>
        case *connectors.MongoConnector:<span class="cov0" title="0">
                return qe.executeMongo(ctx, c, query)</span>
        case *connectors.RedisConnector:<span class="cov0" title="0">
                return qe.executeRedis(ctx, c, query)</span>
        case *connectors.FileConnector:<span class="cov0" title="0">
                return qe.executeFile(ctx, c, query)</span>
        default:<span class="cov0" title="0">
                return nil, errors.NewError(errors.ErrorTypeUnsupported, "unsupported connector type", nil)</span>
        }
}

func (qe *QueryExecutor) executeSQL(ctx context.Context, connector *connectors.SQLConnector, query Query) ([]map[string]interface{}, error) <span class="cov0" title="0">{
        sqlQuery, args := buildSQLQuery(query)
        if query.Type == Select </span><span class="cov0" title="0">{
                return connector.Query(ctx, sqlQuery, args...)
        }</span>
        <span class="cov0" title="0">affected, err := connector.Execute(ctx, sqlQuery, args...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return []map[string]interface{}{{"affected_rows": affected}}, nil</span>
}

func (qe *QueryExecutor) executeMongo(ctx context.Context, connector *connectors.MongoConnector, query Query) ([]map[string]interface{}, error) <span class="cov0" title="0">{
        switch query.Type </span>{
        case Select:<span class="cov0" title="0">
                filterJSON, err := json.Marshal(query.Conditions)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, errors.NewError(errors.ErrorTypeQuery, "failed to marshal query conditions", err)
                }</span>
                <span class="cov0" title="0">return connector.Query(ctx, string(filterJSON), query.Collection)</span>
        case Insert:<span class="cov0" title="0">
                affected, err := connector.Execute(ctx, "insert", query.Collection, query.Data)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">return []map[string]interface{}{{"affected_documents": affected}}, nil</span>
        case Update:<span class="cov0" title="0">
                affected, err := connector.Execute(ctx, "update", query.Collection, query.Conditions, query.Data)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">return []map[string]interface{}{{"affected_documents": affected}}, nil</span>
        case Delete:<span class="cov0" title="0">
                affected, err := connector.Execute(ctx, "delete", query.Collection, query.Conditions)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">return []map[string]interface{}{{"affected_documents": affected}}, nil</span>
        default:<span class="cov0" title="0">
                return nil, errors.NewError(errors.ErrorTypeUnsupported, "unsupported query type for MongoDB", nil)</span>
        }
}

func (qe *QueryExecutor) executeRedis(ctx context.Context, connector *connectors.RedisConnector, query Query) ([]map[string]interface{}, error) <span class="cov0" title="0">{
        switch query.Type </span>{
        case Select:<span class="cov0" title="0">
                return connector.Query(ctx, query.Collection)</span>
        case Insert, Update:<span class="cov0" title="0">
                value, err := json.Marshal(query.Data)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, errors.NewError(errors.ErrorTypeQuery, "failed to marshal Redis data", err)
                }</span>
                <span class="cov0" title="0">affected, err := connector.Execute(ctx, "SET", query.Collection, string(value))
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">return []map[string]interface{}{{"affected_keys": affected}}, nil</span>
        case Delete:<span class="cov0" title="0">
                affected, err := connector.Execute(ctx, "DEL", query.Collection)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">return []map[string]interface{}{{"affected_keys": affected}}, nil</span>
        default:<span class="cov0" title="0">
                return nil, errors.NewError(errors.ErrorTypeUnsupported, "unsupported query type for Redis", nil)</span>
        }
}

func (qe *QueryExecutor) executeFile(ctx context.Context, connector *connectors.FileConnector, query Query) ([]map[string]interface{}, error) <span class="cov0" title="0">{
        if query.Type != Select </span><span class="cov0" title="0">{
                return nil, errors.NewError(errors.ErrorTypeUnsupported, "only SELECT queries are supported for file connector", nil)
        }</span>
        <span class="cov0" title="0">return connector.Query(ctx, query.Collection)</span>
}

func buildSQLQuery(query Query) (string, []interface{}) <span class="cov0" title="0">{
        var sqlQuery strings.Builder
        var args []interface{}

        switch query.Type </span>{
        case Select:<span class="cov0" title="0">
                sqlQuery.WriteString("SELECT ")
                if len(query.Fields) &gt; 0 </span><span class="cov0" title="0">{
                        sqlQuery.WriteString(strings.Join(query.Fields, ", "))
                }</span> else<span class="cov0" title="0"> {
                        sqlQuery.WriteString("*")
                }</span>
                <span class="cov0" title="0">sqlQuery.WriteString(" FROM ")
                sqlQuery.WriteString(query.Collection)</span>
        case Insert:<span class="cov0" title="0">
                sqlQuery.WriteString("INSERT INTO ")
                sqlQuery.WriteString(query.Collection)
                sqlQuery.WriteString(" (")
                var columns []string
                var values []string
                for k, v := range query.Data </span><span class="cov0" title="0">{
                        columns = append(columns, k)
                        values = append(values, "?")
                        args = append(args, v)
                }</span>
                <span class="cov0" title="0">sqlQuery.WriteString(strings.Join(columns, ", "))
                sqlQuery.WriteString(") VALUES (")
                sqlQuery.WriteString(strings.Join(values, ", "))
                sqlQuery.WriteString(")")</span>
        case Update:<span class="cov0" title="0">
                sqlQuery.WriteString("UPDATE ")
                sqlQuery.WriteString(query.Collection)
                sqlQuery.WriteString(" SET ")
                var sets []string
                for k, v := range query.Data </span><span class="cov0" title="0">{
                        sets = append(sets, k+" = ?")
                        args = append(args, v)
                }</span>
                <span class="cov0" title="0">sqlQuery.WriteString(strings.Join(sets, ", "))</span>
        case Delete:<span class="cov0" title="0">
                sqlQuery.WriteString("DELETE FROM ")
                sqlQuery.WriteString(query.Collection)</span>
        }

        <span class="cov0" title="0">if len(query.Conditions) &gt; 0 &amp;&amp; (query.Type == Select || query.Type == Update || query.Type == Delete) </span><span class="cov0" title="0">{
                sqlQuery.WriteString(" WHERE ")
                var conditions []string
                for k, v := range query.Conditions </span><span class="cov0" title="0">{
                        conditions = append(conditions, k+" = ?")
                        args = append(args, v)
                }</span>
                <span class="cov0" title="0">sqlQuery.WriteString(strings.Join(conditions, " AND "))</span>
        }

        <span class="cov0" title="0">if query.Type == Select </span><span class="cov0" title="0">{
                if query.Limit &gt; 0 </span><span class="cov0" title="0">{
                        sqlQuery.WriteString(fmt.Sprintf(" LIMIT %d", query.Limit))
                }</span>
                <span class="cov0" title="0">if query.Offset &gt; 0 </span><span class="cov0" title="0">{
                        sqlQuery.WriteString(fmt.Sprintf(" OFFSET %d", query.Offset))
                }</span>
        }

        <span class="cov0" title="0">return sqlQuery.String(), args</span>
}
</pre>
		
		<pre class="file" id="file64" style="display: none">package transform

import (
        "encoding/json"
        "fmt"
        "reflect"
        "strconv"
        "strings"
        "time"

        "pkg/common/errors"
)

// Transformer is responsible for data transformations
type Transformer struct{}

// NewTransformer creates a new Transformer
// ```
// Example:
//                 transformer := transform.NewTransformer()

//     // Example map data
//     data := map[string]interface{}{
//         "name": "John Doe",
//         "age":  30,
//         "address": map[string]interface{}{
//             "street": "123 Main St",
//             "city":   "New York",
//             "zip":    "10001",
//         },
//         "hobbies": []string{"reading", "swimming"},
//     }

//     // Convert to struct
//     result, err := transformer.TransformData(data, "struct")
//     if err != nil {
//         log.Fatalf("Failed to convert to struct: %v", err)
//     }

//     // Print the resulting struct
//     fmt.Printf("%+v\n", result)

//     // You can now access fields like this:
//     resultValue := reflect.ValueOf(result)
//     fmt.Printf("Name: %v\n", resultValue.FieldByName("Name").Interface())
//     fmt.Printf("Age: %v\n", resultValue.FieldByName("Age").Interface())

//         // Access nested struct
//         address := resultValue.FieldByName("Address").Interface()
//         addressValue := reflect.ValueOf(address)
//         fmt.Printf("City: %v\n", addressValue.FieldByName("City").Interface())
//        fmt.Printf("Zip: %v\n", addressValue.FieldByName("Zip").Interface())
//
// ```
func NewTransformer() *Transformer <span class="cov0" title="0">{
        return &amp;Transformer{}
}</span>

// TransformData converts data from one format to another
func (t *Transformer) TransformData(data interface{}, targetFormat string) (interface{}, error) <span class="cov0" title="0">{
        switch targetFormat </span>{
        case "json":<span class="cov0" title="0">
                return t.toJSON(data)</span>
        case "map":<span class="cov0" title="0">
                return t.toMap(data)</span>
        case "struct":<span class="cov0" title="0">
                return t.toStruct(data)</span>
        case "array":<span class="cov0" title="0">
                return t.toArray(data)</span>
        default:<span class="cov0" title="0">
                return nil, errors.NewError(errors.ErrorTypeUnsupported, fmt.Sprintf("unsupported target format: %s", targetFormat), nil)</span>
        }
}

// toStruct converts data to a struct using reflection
func (t *Transformer) toStruct(data interface{}) (interface{}, error) <span class="cov0" title="0">{
        dataValue := reflect.ValueOf(data)
        if dataValue.Kind() == reflect.Ptr </span><span class="cov0" title="0">{
                dataValue = dataValue.Elem()
        }</span>

        <span class="cov0" title="0">switch dataValue.Kind() </span>{
        case reflect.Struct:<span class="cov0" title="0">
                return data, nil</span> // Already a struct
        case reflect.Map:<span class="cov0" title="0">
                return t.mapToStruct(dataValue)</span>
        default:<span class="cov0" title="0">
                return nil, errors.NewError(errors.ErrorTypeTransformation, "unsupported data type for struct conversion", nil)</span>
        }
}

// mapToStruct converts a map to a struct
func (t *Transformer) mapToStruct(mapValue reflect.Value) (interface{}, error) <span class="cov0" title="0">{
        if mapValue.Kind() != reflect.Map </span><span class="cov0" title="0">{
                return nil, errors.NewError(errors.ErrorTypeTransformation, "input is not a map", nil)
        }</span>

        <span class="cov0" title="0">structType := reflect.StructOf(t.mapToStructFields(mapValue))
        structValue := reflect.New(structType).Elem()

        for _, key := range mapValue.MapKeys() </span><span class="cov0" title="0">{
                fieldName := t.normalizeFieldName(key.String())
                fieldValue := mapValue.MapIndex(key)

                if structValue.FieldByName(fieldName).IsValid() </span><span class="cov0" title="0">{
                        if err := t.setStructField(structValue.FieldByName(fieldName), fieldValue); err != nil </span><span class="cov0" title="0">{
                                return nil, err
                        }</span>
                }
        }

        <span class="cov0" title="0">return structValue.Interface(), nil</span>
}

// mapToStructFields creates struct fields from a map
func (t *Transformer) mapToStructFields(mapValue reflect.Value) []reflect.StructField <span class="cov0" title="0">{
        var fields []reflect.StructField

        for _, key := range mapValue.MapKeys() </span><span class="cov0" title="0">{
                fieldName := t.normalizeFieldName(key.String())
                fieldValue := mapValue.MapIndex(key)
                fieldType := fieldValue.Type()

                // Handle nested maps
                if fieldValue.Kind() == reflect.Map </span><span class="cov0" title="0">{
                        nestedFields := t.mapToStructFields(fieldValue)
                        fieldType = reflect.StructOf(nestedFields)
                }</span>

                <span class="cov0" title="0">fields = append(fields, reflect.StructField{
                        Name: fieldName,
                        Type: fieldType,
                })</span>
        }

        <span class="cov0" title="0">return fields</span>
}

// setStructField sets the value of a struct field
func (t *Transformer) setStructField(field reflect.Value, value reflect.Value) error <span class="cov0" title="0">{
        if !field.CanSet() </span><span class="cov0" title="0">{
                return errors.NewError(errors.ErrorTypeTransformation, "cannot set field value", nil)
        }</span>

        <span class="cov0" title="0">if field.Kind() == reflect.Struct &amp;&amp; value.Kind() == reflect.Map </span><span class="cov0" title="0">{
                nestedStruct, err := t.mapToStruct(value)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov0" title="0">field.Set(reflect.ValueOf(nestedStruct))
                return nil</span>
        }

        <span class="cov0" title="0">if field.Type() != value.Type() </span><span class="cov0" title="0">{
                if value.Type().ConvertibleTo(field.Type()) </span><span class="cov0" title="0">{
                        value = value.Convert(field.Type())
                }</span> else<span class="cov0" title="0"> {
                        return errors.NewError(errors.ErrorTypeTransformation, "incompatible types for field assignment", nil)
                }</span>
        }

        <span class="cov0" title="0">field.Set(value)
        return nil</span>
}

// normalizeFieldName converts a string to a valid Go struct field name
func (t *Transformer) normalizeFieldName(name string) string <span class="cov0" title="0">{
        // Capitalize the first letter
        name = strings.Title(name)
        // Remove any characters that are not letters, numbers, or underscores
        name = strings.Map(func(r rune) rune </span><span class="cov0" title="0">{
                if (r &gt;= 'A' &amp;&amp; r &lt;= 'Z') || (r &gt;= 'a' &amp;&amp; r &lt;= 'z') || (r &gt;= '0' &amp;&amp; r &lt;= '9') || r == '_' </span><span class="cov0" title="0">{
                        return r
                }</span>
                <span class="cov0" title="0">return -1</span>
        }, name)
        // Ensure the field name starts with a letter
        <span class="cov0" title="0">if len(name) &gt; 0 &amp;&amp; (name[0] &gt;= '0' &amp;&amp; name[0] &lt;= '9') </span><span class="cov0" title="0">{
                name = "F" + name
        }</span>
        <span class="cov0" title="0">return name</span>
}

// toJSON converts data to JSON format
func (t *Transformer) toJSON(data interface{}) (string, error) <span class="cov0" title="0">{
        jsonData, err := json.Marshal(data)
        if err != nil </span><span class="cov0" title="0">{
                return "", errors.NewError(errors.ErrorTypeTransformation, "failed to convert data to JSON", err)
        }</span>
        <span class="cov0" title="0">return string(jsonData), nil</span>
}

// toMap converts data to a map[string]interface{}
func (t *Transformer) toMap(data interface{}) (map[string]interface{}, error) <span class="cov0" title="0">{
        var result map[string]interface{}

        switch v := data.(type) </span>{
        case map[string]interface{}:<span class="cov0" title="0">
                return v, nil</span>
        case string:<span class="cov0" title="0">
                if err := json.Unmarshal([]byte(v), &amp;result); err != nil </span><span class="cov0" title="0">{
                        return nil, errors.NewError(errors.ErrorTypeTransformation, "failed to convert string to map", err)
                }</span>
                <span class="cov0" title="0">return result, nil</span>
        default:<span class="cov0" title="0">
                jsonData, err := json.Marshal(data)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, errors.NewError(errors.ErrorTypeTransformation, "failed to marshal data to JSON", err)
                }</span>
                <span class="cov0" title="0">if err := json.Unmarshal(jsonData, &amp;result); err != nil </span><span class="cov0" title="0">{
                        return nil, errors.NewError(errors.ErrorTypeTransformation, "failed to unmarshal JSON to map", err)
                }</span>
                <span class="cov0" title="0">return result, nil</span>
        }
}

// toArray converts data to an array ([]interface{})
func (t *Transformer) toArray(data interface{}) ([]interface{}, error) <span class="cov0" title="0">{
        switch v := data.(type) </span>{
        case []interface{}:<span class="cov0" title="0">
                return v, nil</span>
        case string:<span class="cov0" title="0">
                var result []interface{}
                if err := json.Unmarshal([]byte(v), &amp;result); err != nil </span><span class="cov0" title="0">{
                        return nil, errors.NewError(errors.ErrorTypeTransformation, "failed to convert string to array", err)
                }</span>
                <span class="cov0" title="0">return result, nil</span>
        default:<span class="cov0" title="0">
                value := reflect.ValueOf(data)
                if value.Kind() != reflect.Slice &amp;&amp; value.Kind() != reflect.Array </span><span class="cov0" title="0">{
                        return nil, errors.NewError(errors.ErrorTypeTransformation, "data is not a slice or array", nil)
                }</span>
                <span class="cov0" title="0">result := make([]interface{}, value.Len())
                for i := 0; i &lt; value.Len(); i++ </span><span class="cov0" title="0">{
                        result[i] = value.Index(i).Interface()
                }</span>
                <span class="cov0" title="0">return result, nil</span>
        }
}

// ConvertType converts a value to the specified type
func (t *Transformer) ConvertType(value interface{}, targetType string) (interface{}, error) <span class="cov0" title="0">{
        switch targetType </span>{
        case "string":<span class="cov0" title="0">
                return fmt.Sprintf("%v", value), nil</span>
        case "int":<span class="cov0" title="0">
                switch v := value.(type) </span>{
                case string:<span class="cov0" title="0">
                        return strconv.Atoi(v)</span>
                case float64:<span class="cov0" title="0">
                        return int(v), nil</span>
                default:<span class="cov0" title="0">
                        return 0, errors.NewError(errors.ErrorTypeTransformation, "unable to convert to int", nil)</span>
                }
        case "float":<span class="cov0" title="0">
                switch v := value.(type) </span>{
                case string:<span class="cov0" title="0">
                        return strconv.ParseFloat(v, 64)</span>
                case int:<span class="cov0" title="0">
                        return float64(v), nil</span>
                default:<span class="cov0" title="0">
                        return 0.0, errors.NewError(errors.ErrorTypeTransformation, "unable to convert to float", nil)</span>
                }
        case "bool":<span class="cov0" title="0">
                switch v := value.(type) </span>{
                case string:<span class="cov0" title="0">
                        return strconv.ParseBool(v)</span>
                case int:<span class="cov0" title="0">
                        return v != 0, nil</span>
                default:<span class="cov0" title="0">
                        return false, errors.NewError(errors.ErrorTypeTransformation, "unable to convert to bool", nil)</span>
                }
        case "time":<span class="cov0" title="0">
                switch v := value.(type) </span>{
                case string:<span class="cov0" title="0">
                        return time.Parse(time.RFC3339, v)</span>
                case int64:<span class="cov0" title="0">
                        return time.Unix(v, 0), nil</span>
                default:<span class="cov0" title="0">
                        return time.Time{}, errors.NewError(errors.ErrorTypeTransformation, "unable to convert to time", nil)</span>
                }
        default:<span class="cov0" title="0">
                return nil, errors.NewError(errors.ErrorTypeUnsupported, fmt.Sprintf("unsupported target type: %s", targetType), nil)</span>
        }
}

// FlattenMap flattens a nested map structure
func (t *Transformer) FlattenMap(data map[string]interface{}, prefix string) map[string]interface{} <span class="cov0" title="0">{
        result := make(map[string]interface{})
        for k, v := range data </span><span class="cov0" title="0">{
                key := k
                if prefix != "" </span><span class="cov0" title="0">{
                        key = prefix + "." + k
                }</span>
                <span class="cov0" title="0">switch child := v.(type) </span>{
                case map[string]interface{}:<span class="cov0" title="0">
                        childMap := t.FlattenMap(child, key)
                        for ck, cv := range childMap </span><span class="cov0" title="0">{
                                result[ck] = cv
                        }</span>
                case []interface{}:<span class="cov0" title="0">
                        for i, item := range child </span><span class="cov0" title="0">{
                                if childMap, ok := item.(map[string]interface{}); ok </span><span class="cov0" title="0">{
                                        childFlat := t.FlattenMap(childMap, fmt.Sprintf("%s[%d]", key, i))
                                        for ck, cv := range childFlat </span><span class="cov0" title="0">{
                                                result[ck] = cv
                                        }</span>
                                } else<span class="cov0" title="0"> {
                                        result[fmt.Sprintf("%s[%d]", key, i)] = item
                                }</span>
                        }
                default:<span class="cov0" title="0">
                        result[key] = v</span>
                }
        }
        <span class="cov0" title="0">return result</span>
}

// UnflattenMap reverses the flattening process
func (t *Transformer) UnflattenMap(data map[string]interface{}) map[string]interface{} <span class="cov0" title="0">{
        result := make(map[string]interface{})
        for k, v := range data </span><span class="cov0" title="0">{
                parts := strings.Split(k, ".")
                m := result
                for _, part := range parts[:len(parts)-1] </span><span class="cov0" title="0">{
                        if _, ok := m[part]; !ok </span><span class="cov0" title="0">{
                                m[part] = make(map[string]interface{})
                        }</span>
                        <span class="cov0" title="0">m = m[part].(map[string]interface{})</span>
                }
                <span class="cov0" title="0">m[parts[len(parts)-1]] = v</span>
        }
        <span class="cov0" title="0">return result</span>
}
</pre>
		
		<pre class="file" id="file65" style="display: none">package transform

import (
        "fmt"
        "strings"

        "pkg/common/errors"
)

// ExtractField extracts a nested field from a map using dot notation
func ExtractField(data map[string]interface{}, field string) (interface{}, error) <span class="cov0" title="0">{
        parts := strings.Split(field, ".")
        current := data
        for i, part := range parts </span><span class="cov0" title="0">{
                if i == len(parts)-1 </span><span class="cov0" title="0">{
                        if val, ok := current[part]; ok </span><span class="cov0" title="0">{
                                return val, nil
                        }</span>
                        <span class="cov0" title="0">return nil, errors.NewError(errors.ErrorTypeNotFound, "field not found", nil)</span>
                }
                <span class="cov0" title="0">if val, ok := current[part]; ok </span><span class="cov0" title="0">{
                        if nextMap, ok := val.(map[string]interface{}); ok </span><span class="cov0" title="0">{
                                current = nextMap
                        }</span> else<span class="cov0" title="0"> {
                                return nil, errors.NewError(errors.ErrorTypeTransformation, "invalid path", nil)
                        }</span>
                } else<span class="cov0" title="0"> {
                        return nil, errors.NewError(errors.ErrorTypeNotFound, "field not found", nil)
                }</span>
        }
        <span class="cov0" title="0">return nil, errors.NewError(errors.ErrorTypeTransformation, "invalid path", nil)</span>
}

// SetField sets a nested field in a map using dot notation
func SetField(data map[string]interface{}, field string, value interface{}) error <span class="cov0" title="0">{
        parts := strings.Split(field, ".")
        current := data
        for i, part := range parts </span><span class="cov0" title="0">{
                if i == len(parts)-1 </span><span class="cov0" title="0">{
                        current[part] = value
                        return nil
                }</span>
                <span class="cov0" title="0">if val, ok := current[part]; ok </span><span class="cov0" title="0">{
                        if nextMap, ok := val.(map[string]interface{}); ok </span><span class="cov0" title="0">{
                                current = nextMap
                        }</span> else<span class="cov0" title="0"> {
                                newMap := make(map[string]interface{})
                                current[part] = newMap
                                current = newMap
                        }</span>
                } else<span class="cov0" title="0"> {
                        newMap := make(map[string]interface{})
                        current[part] = newMap
                        current = newMap
                }</span>
        }
        <span class="cov0" title="0">return errors.NewError(errors.ErrorTypeTransformation, "invalid path", nil)</span>
}

// MergeMap merges two maps, with the second map taking precedence
func MergeMap(m1, m2 map[string]interface{}) map[string]interface{} <span class="cov0" title="0">{
        result := make(map[string]interface{})
        for k, v := range m1 </span><span class="cov0" title="0">{
                result[k] = v
        }</span>
        <span class="cov0" title="0">for k, v := range m2 </span><span class="cov0" title="0">{
                if v1, ok := result[k]; ok </span><span class="cov0" title="0">{
                        if map1, isMap1 := v1.(map[string]interface{}); isMap1 </span><span class="cov0" title="0">{
                                if map2, isMap2 := v.(map[string]interface{}); isMap2 </span><span class="cov0" title="0">{
                                        result[k] = MergeMap(map1, map2)
                                        continue</span>
                                }
                        }
                }
                <span class="cov0" title="0">result[k] = v</span>
        }
        <span class="cov0" title="0">return result</span>
}

// GroupBy groups a slice of maps by a specified key
func GroupBy(data []map[string]interface{}, key string) (map[string][]map[string]interface{}, error) <span class="cov0" title="0">{
        result := make(map[string][]map[string]interface{})
        for _, item := range data </span><span class="cov0" title="0">{
                value, err := ExtractField(item, key)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">strValue := fmt.Sprintf("%v", value)
                result[strValue] = append(result[strValue], item)</span>
        }
        <span class="cov0" title="0">return result, nil</span>
}

// FilterSlice filters a slice of maps based on a condition function
func FilterSlice(data []map[string]interface{}, condition func(map[string]interface{}) bool) []map[string]interface{} <span class="cov0" title="0">{
        var result []map[string]interface{}
        for _, item := range data </span><span class="cov0" title="0">{
                if condition(item) </span><span class="cov0" title="0">{
                        result = append(result, item)
                }</span>
        }
        <span class="cov0" title="0">return result</span>
}
</pre>
		
		<pre class="file" id="file66" style="display: none">package encoder

import "encoding/base64"

// Base64Encoder is a helper struct for encoding and decoding Base64 strings.
type Base64Encoder struct{}

// NewBase64Encoder creates a new Base64Encoder.
//
// Usage:
//
//        encoder := NewBase64Encoder()
func NewBase64Encoder() *Base64Encoder <span class="cov6" title="4">{
        return &amp;Base64Encoder{}
}</span>

// Encode encodes a string to Base64.
//
// Parameters:
//   - data: The string to encode.
//
// Returns:
//   - The Base64 encoded string.
//
// Usage:
//
//        encoded := encoder.Encode("Hello, World!")
func (b *Base64Encoder) Encode(data string) string <span class="cov9" title="9">{
        return base64.StdEncoding.EncodeToString([]byte(data))
}</span>

// Decode decodes a Base64 string.
//
// Parameters:
//   - encodedData: The Base64 encoded string to decode.
//
// Returns:
//   - The decoded string and an error if decoding fails.
//
// Usage:
//
//        decoded, err := encoder.Decode(encodedString)
func (b *Base64Encoder) Decode(encodedData string) (string, error) <span class="cov10" title="10">{
        data, err := base64.StdEncoding.DecodeString(encodedData)
        if err != nil </span><span class="cov1" title="1">{
                return "", err
        }</span>
        <span class="cov9" title="9">return string(data), nil</span>
}
</pre>
		
		<pre class="file" id="file67" style="display: none">// Package errors provides custom error types and error checking functions
// for common error scenarios in the DataVinci project.
package errors

import (
        "context"
        "errors"
        "fmt"
        "net"
        "runtime"
        "strings"
)

// ErrorType represents the type of error.
type ErrorType uint

const (
        ErrorTypeUnknown ErrorType = iota
        ErrorTypeDatabaseConnection
        ErrorTypeTimeout
        ErrorTypePermission
        ErrorTypeQuery
        ErrorTypeExecution
        ErrorTypeTransaction
        ErrorTypeConfiguration
        ErrorTypeAPIConnection
        ErrorTypeUnsupported
        ErrorTypeFileConnection
        ErrorTypeNotFound
        ErrorTypeConnection
        ErrorTypeTransformation
        ErrorTypeEmptyPassword
        ErrorTypeInvalidCost
        ErrorTypeValidation
        ErrorTypeResourceExhausted
        ErrorTypeDataIntegrity
)

// ErrorMessages maps error types to human-readable messages.
var ErrorMessages = map[ErrorType]string{
        ErrorTypeUnknown:            "Unknown error occurred",
        ErrorTypeDatabaseConnection: "Database connection not established",
        ErrorTypeTimeout:            "Operation timed out",
        ErrorTypePermission:         "Permission denied",
        ErrorTypeQuery:              "Query execution failed",
        ErrorTypeExecution:          "Execution error",
        ErrorTypeTransaction:        "Transaction error",
        ErrorTypeConfiguration:      "Configuration error",
        ErrorTypeAPIConnection:      "API connection failed",
        ErrorTypeUnsupported:        "Unsupported operation",
        ErrorTypeFileConnection:     "File connection error",
        ErrorTypeNotFound:           "Resource not found",
        ErrorTypeConnection:         "Connection error",
        ErrorTypeTransformation:     "Data transformation error",
        ErrorTypeEmptyPassword:      "Empty password provided",
        ErrorTypeInvalidCost:        "Invalid bcrypt cost",
        ErrorTypeValidation:         "Validation error",
        ErrorTypeResourceExhausted:  "Resource exhausted",
        ErrorTypeDataIntegrity:      "Data integrity violation",
}

// GetErrorMessage returns the error message for a given ErrorType.
// If the ErrorType is not found in ErrorMessages, it returns a default message.
func GetErrorMessage(errType ErrorType) string <span class="cov5" title="13">{
        if msg, ok := ErrorMessages[errType]; ok </span><span class="cov5" title="11">{
                return msg
        }</span>
        <span class="cov2" title="2">return fmt.Sprintf("Unknown error type (%d)", errType)</span>
}

// Error represents a custom error with additional context.
type Error struct {
        Type    ErrorType         // The type of the error
        Message string            // A human-readable error message
        Err     error             // The underlying error, if any
        Cause   error             // The cause of the error, if any
        Stack   string            // The stack trace of the error
        Context map[string]string // Additional context for the error
}

// Error returns the error message.
// It implements the error interface.
func (e *Error) Error() string <span class="cov4" title="7">{
        message := e.Message
        if message == "" </span><span class="cov0" title="0">{
                message = GetErrorMessage(e.Type)
        }</span>
        <span class="cov4" title="7">if e.Err != nil </span><span class="cov2" title="3">{
                return fmt.Sprintf("%s: %v", message, e.Err)
        }</span>
        <span class="cov3" title="4">return message</span>
}

// Unwrap returns the wrapped error.
// It allows Error to work with errors.Is and errors.As.
func (e *Error) Unwrap() error <span class="cov3" title="5">{
        return e.Err
}</span>

// Is checks if the given error is of the given type.
// It allows Error to work with errors.Is and errors.As.
func (e *Error) Is(target error) bool <span class="cov3" title="5">{
        if target == nil </span><span class="cov0" title="0">{
                return false
        }</span>
        <span class="cov3" title="5">t, ok := target.(*Error)
        if !ok </span><span class="cov2" title="2">{
                return errors.Is(e.Err, target)
        }</span>
        <span class="cov2" title="3">return e.Type == t.Type</span>
}

// NewError creates a new Error with the given type, message, and underlying error.
func NewError(errType ErrorType, message string, err error) *Error <span class="cov7" title="37">{
        return NewErrorWithContext(errType, message, err, nil)
}</span>

// NewErrorWithContext creates a new Error with the given type, message, underlying error, and context.
func NewErrorWithContext(errType ErrorType, message string, err error, context map[string]string) *Error <span class="cov7" title="38">{
        if message == "" </span><span class="cov4" title="7">{
                message = GetErrorMessage(errType)
        }</span>
        <span class="cov7" title="38">newError := &amp;Error{
                Type:    errType,
                Message: message,
                Err:     err,
                Cause:   err,
                Context: context,
        }

        var sb strings.Builder
        for i := 1; ; i++ </span><span class="cov10" title="191">{
                pc, file, line, ok := runtime.Caller(i)
                if !ok </span><span class="cov7" title="38">{
                        break</span>
                }
                <span class="cov9" title="153">fn := runtime.FuncForPC(pc)
                sb.WriteString(fmt.Sprintf("%s:%d %s\n", file, line, fn.Name()))</span>
        }
        <span class="cov7" title="38">newError.Stack = sb.String()

        return newError</span>
}

// IsErrorType checks if the error is of the given type.
func IsErrorType(err error, errType ErrorType) bool <span class="cov3" title="4">{
        var customErr *Error
        if errors.As(err, &amp;customErr) </span><span class="cov2" title="2">{
                return customErr.Type == errType
        }</span>
        <span class="cov2" title="2">return false</span>
}

// IsConnectionError checks if the given error is a connection error.
func IsConnectionError(err error) bool <span class="cov4" title="8">{
        if err == nil </span><span class="cov1" title="1">{
                return false
        }</span>
        <span class="cov4" title="7">var e *Error
        if errors.As(err, &amp;e) </span><span class="cov2" title="3">{
                return e.Type == ErrorTypeDatabaseConnection || e.Type == ErrorTypeConnection || e.Type == ErrorTypeAPIConnection
        }</span>
        <span class="cov3" title="4">var netErr *net.OpError
        var dnsErr *net.DNSError
        return errors.As(err, &amp;netErr) || errors.As(err, &amp;dnsErr) || isNetworkError(err)</span>
}

// IsTimeoutError checks if the given error is a timeout error.
func IsTimeoutError(err error) bool <span class="cov4" title="8">{
        if err == nil </span><span class="cov1" title="1">{
                return false
        }</span>
        <span class="cov4" title="7">var e *Error
        if errors.As(err, &amp;e) </span><span class="cov2" title="3">{
                return e.Type == ErrorTypeTimeout
        }</span>
        <span class="cov3" title="4">var netErr *net.OpError
        if errors.As(err, &amp;netErr) </span><span class="cov1" title="1">{
                return netErr.Timeout()
        }</span>
        <span class="cov2" title="3">return errors.Is(err, context.DeadlineExceeded) ||
                strings.Contains(strings.ToLower(err.Error()), "timeout") ||
                strings.Contains(strings.ToLower(err.Error()), "deadline exceeded")</span>
}

// IsPermissionError checks if the given error is a permission error.
func IsPermissionError(err error) bool <span class="cov4" title="8">{
        if err == nil </span><span class="cov1" title="1">{
                return false
        }</span>
        <span class="cov4" title="7">var e *Error
        if errors.As(err, &amp;e) </span><span class="cov2" title="3">{
                return e.Type == ErrorTypePermission
        }</span>
        <span class="cov3" title="4">errLower := strings.ToLower(err.Error())
        return strings.Contains(errLower, "permission") ||
                strings.Contains(errLower, "access denied")</span>
}

// isNetworkError checks if the error is a known network error.
func isNetworkError(err error) bool <span class="cov2" title="2">{
        return errors.Is(err, net.ErrClosed) || errors.Is(err, net.ErrWriteToConnected)
}</span>

// AddErrorContext adds additional context to an existing Error.
func AddErrorContext(err *Error, key, value string) *Error <span class="cov0" title="0">{
        if err.Context == nil </span><span class="cov0" title="0">{
                err.Context = make(map[string]string)
        }</span>
        <span class="cov0" title="0">err.Context[key] = value
        return err</span>
}

// GetErrorContext retrieves the context from an Error.
func GetErrorContext(err error) map[string]string <span class="cov2" title="3">{
        var e *Error
        if errors.As(err, &amp;e) </span><span class="cov1" title="1">{
                return e.Context
        }</span>
        <span class="cov2" title="2">return nil</span>
}

// WrapError wraps an existing error with a new Error type and message.
func WrapError(err error, errType ErrorType, message string) *Error <span class="cov2" title="2">{
        return NewError(errType, message, err)
}</span>
</pre>
		
		<pre class="file" id="file68" style="display: none">// Package retry provides a configurable mechanism for retrying operations
// that may fail due to transient errors.
package retry

import (
        "context"
        "time"

        "pkg/common/errors"
)

// Config represents the configuration for the retry mechanism.
type Config struct {
        // MaxAttempts is the maximum number of attempts to make before giving up.
        MaxAttempts int
        // InitialBackoff is the duration to wait before the first retry.
        InitialBackoff time.Duration
        // MaxBackoff is the maximum duration to wait between retries.
        MaxBackoff time.Duration
        // BackoffFactor is the factor by which to increase the backoff duration after each retry.
        BackoffFactor float64
        // RetryableErrors is a list of functions that determine if an error is retryable.
        RetryableErrors []func(error) bool
        // NonRetryableErrors is a list of functions that determine if an error should not be retried.
        NonRetryableErrors []func(error) bool
}

// DefaultConfig returns a default retry configuration.
// It sets up sensible defaults for retry attempts, backoff durations,
// and includes common retryable and non-retryable error checks.
func DefaultConfig() *Config <span class="cov6" title="4">{
        return &amp;Config{
                MaxAttempts:    5,
                InitialBackoff: 100 * time.Millisecond,
                MaxBackoff:     10 * time.Second,
                BackoffFactor:  2,
                RetryableErrors: []func(error) bool{
                        errors.IsConnectionError,
                        errors.IsTimeoutError,
                },
                NonRetryableErrors: []func(error) bool{
                        errors.IsPermissionError,
                },
        }
}</span>

// Retry executes the given function with retries based on the provided configuration.
// It will retry the function until it succeeds, the maximum number of attempts is reached,
// or the context is canceled.
//
// The function respects the context's cancellation and will return early if the context
// is canceled.
//
// If the function returns a non-retryable error, Retry will return immediately without
// further attempts.
func Retry(ctx context.Context, fn func() error, config *Config) error <span class="cov6" title="4">{
        var err error
        attempt := 0
        backoff := config.InitialBackoff

        for attempt &lt; config.MaxAttempts </span><span class="cov10" title="10">{
                err = fn()
                if err == nil </span><span class="cov3" title="2">{
                        return nil
                }</span>

                <span class="cov9" title="8">if isNonRetryableError(err, config.NonRetryableErrors) </span><span class="cov1" title="1">{
                        return err
                }</span>

                <span class="cov8" title="7">if !isRetryableError(err, config.RetryableErrors) </span><span class="cov0" title="0">{
                        return err
                }</span>

                <span class="cov8" title="7">select </span>{
                case &lt;-ctx.Done():<span class="cov0" title="0">
                        return ctx.Err()</span>
                case &lt;-time.After(backoff):<span class="cov8" title="7">
                        attempt++
                        backoff = calculateNextBackoff(backoff, config)</span>
                }
        }

        <span class="cov1" title="1">return errors.NewError(errors.ErrorTypeUnknown, "max retry attempts reached", err)</span>
}

// isRetryableError checks if the given error is retryable based on the provided list of check functions.
func isRetryableError(err error, retryableErrors []func(error) bool) bool <span class="cov8" title="7">{
        for _, isRetryable := range retryableErrors </span><span class="cov8" title="7">{
                if isRetryable(err) </span><span class="cov8" title="7">{
                        return true
                }</span>
        }
        <span class="cov0" title="0">return false</span>
}

// isNonRetryableError checks if the given error is non-retryable based on the provided list of check functions.
func isNonRetryableError(err error, nonRetryableErrors []func(error) bool) bool <span class="cov9" title="8">{
        for _, isNonRetryable := range nonRetryableErrors </span><span class="cov9" title="8">{
                if isNonRetryable(err) </span><span class="cov1" title="1">{
                        return true
                }</span>
        }
        <span class="cov8" title="7">return false</span>
}

// calculateNextBackoff calculates the next backoff duration using exponential backoff.
// It ensures that the backoff duration does not exceed the maximum specified in the config.
func calculateNextBackoff(currentBackoff time.Duration, config *Config) time.Duration <span class="cov8" title="7">{
        nextBackoff := time.Duration(float64(currentBackoff) * config.BackoffFactor)
        if nextBackoff &gt; config.MaxBackoff </span><span class="cov0" title="0">{
                return config.MaxBackoff
        }</span>
        <span class="cov8" title="7">return nextBackoff</span>
}
</pre>
		
		<pre class="file" id="file69" style="display: none">package config

import (
        "github.com/spf13/viper"
)

type Config struct {
        DatabaseURL      string
        AuthServiceAddr  string
        AuthzServiceAddr string
        JWTSecret        string
}

func Load() (*Config, error) <span class="cov0" title="0">{
        viper.SetConfigName("config")
        viper.SetConfigType("yaml")
        viper.AddConfigPath(".")
        viper.AddConfigPath("./config")

        if err := viper.ReadInConfig(); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">var cfg Config
        if err := viper.Unmarshal(&amp;cfg); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">return &amp;cfg, nil</span>
}
</pre>
		
		<pre class="file" id="file70" style="display: none">package main

func main() <span class="cov0" title="0">{
        println("Hello, world!")
}</span>
</pre>
		
		<pre class="file" id="file71" style="display: none">package main

func main() <span class="cov0" title="0">{
        println("Hello, world!")
}</span>
</pre>
		
		<pre class="file" id="file72" style="display: none">// Code generated by protoc-gen-go. DO NOT EDIT.
// versions:
//         protoc-gen-go v1.34.2
//         protoc        v3.21.12
// source: api/proto/visualization.proto

package grpc

import (
        reflect "reflect"
        sync "sync"

        protoreflect "google.golang.org/protobuf/reflect/protoreflect"
        protoimpl "google.golang.org/protobuf/runtime/protoimpl"
)

const (
        // Verify that this generated code is sufficiently up-to-date.
        _ = protoimpl.EnforceVersion(20 - protoimpl.MinVersion)
        // Verify that runtime/protoimpl is sufficiently up-to-date.
        _ = protoimpl.EnforceVersion(protoimpl.MaxVersion - 20)
)

type CreateVisualizationRequest struct {
        state         protoimpl.MessageState
        sizeCache     protoimpl.SizeCache
        unknownFields protoimpl.UnknownFields

        DataSourceId      string            `protobuf:"bytes,1,opt,name=data_source_id,json=dataSourceId,proto3" json:"data_source_id,omitempty"`
        VisualizationType string            `protobuf:"bytes,2,opt,name=visualization_type,json=visualizationType,proto3" json:"visualization_type,omitempty"`
        Dimensions        []string          `protobuf:"bytes,3,rep,name=dimensions,proto3" json:"dimensions,omitempty"`
        Measures          []string          `protobuf:"bytes,4,rep,name=measures,proto3" json:"measures,omitempty"`
        Filters           map[string]string `protobuf:"bytes,5,rep,name=filters,proto3" json:"filters,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
        Options           map[string]string `protobuf:"bytes,6,rep,name=options,proto3" json:"options,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
}

func (x *CreateVisualizationRequest) Reset() <span class="cov0" title="0">{
        *x = CreateVisualizationRequest{}
        if protoimpl.UnsafeEnabled </span><span class="cov0" title="0">{
                mi := &amp;file_api_proto_visualization_proto_msgTypes[0]
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                ms.StoreMessageInfo(mi)
        }</span>
}

func (x *CreateVisualizationRequest) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*CreateVisualizationRequest) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *CreateVisualizationRequest) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_api_proto_visualization_proto_msgTypes[0]
        if protoimpl.UnsafeEnabled &amp;&amp; x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use CreateVisualizationRequest.ProtoReflect.Descriptor instead.
func (*CreateVisualizationRequest) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_api_proto_visualization_proto_rawDescGZIP(), []int{0}
}</span>

func (x *CreateVisualizationRequest) GetDataSourceId() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.DataSourceId
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *CreateVisualizationRequest) GetVisualizationType() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.VisualizationType
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *CreateVisualizationRequest) GetDimensions() []string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Dimensions
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (x *CreateVisualizationRequest) GetMeasures() []string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Measures
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (x *CreateVisualizationRequest) GetFilters() map[string]string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Filters
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (x *CreateVisualizationRequest) GetOptions() map[string]string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Options
        }</span>
        <span class="cov0" title="0">return nil</span>
}

type UpdateVisualizationRequest struct {
        state         protoimpl.MessageState
        sizeCache     protoimpl.SizeCache
        unknownFields protoimpl.UnknownFields

        VisualizationId string                      `protobuf:"bytes,1,opt,name=visualization_id,json=visualizationId,proto3" json:"visualization_id,omitempty"`
        UpdateData      *CreateVisualizationRequest `protobuf:"bytes,2,opt,name=update_data,json=updateData,proto3" json:"update_data,omitempty"`
}

func (x *UpdateVisualizationRequest) Reset() <span class="cov0" title="0">{
        *x = UpdateVisualizationRequest{}
        if protoimpl.UnsafeEnabled </span><span class="cov0" title="0">{
                mi := &amp;file_api_proto_visualization_proto_msgTypes[1]
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                ms.StoreMessageInfo(mi)
        }</span>
}

func (x *UpdateVisualizationRequest) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*UpdateVisualizationRequest) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *UpdateVisualizationRequest) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_api_proto_visualization_proto_msgTypes[1]
        if protoimpl.UnsafeEnabled &amp;&amp; x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use UpdateVisualizationRequest.ProtoReflect.Descriptor instead.
func (*UpdateVisualizationRequest) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_api_proto_visualization_proto_rawDescGZIP(), []int{1}
}</span>

func (x *UpdateVisualizationRequest) GetVisualizationId() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.VisualizationId
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *UpdateVisualizationRequest) GetUpdateData() *CreateVisualizationRequest <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.UpdateData
        }</span>
        <span class="cov0" title="0">return nil</span>
}

type GetVisualizationRequest struct {
        state         protoimpl.MessageState
        sizeCache     protoimpl.SizeCache
        unknownFields protoimpl.UnknownFields

        VisualizationId string `protobuf:"bytes,1,opt,name=visualization_id,json=visualizationId,proto3" json:"visualization_id,omitempty"`
}

func (x *GetVisualizationRequest) Reset() <span class="cov0" title="0">{
        *x = GetVisualizationRequest{}
        if protoimpl.UnsafeEnabled </span><span class="cov0" title="0">{
                mi := &amp;file_api_proto_visualization_proto_msgTypes[2]
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                ms.StoreMessageInfo(mi)
        }</span>
}

func (x *GetVisualizationRequest) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*GetVisualizationRequest) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *GetVisualizationRequest) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_api_proto_visualization_proto_msgTypes[2]
        if protoimpl.UnsafeEnabled &amp;&amp; x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use GetVisualizationRequest.ProtoReflect.Descriptor instead.
func (*GetVisualizationRequest) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_api_proto_visualization_proto_rawDescGZIP(), []int{2}
}</span>

func (x *GetVisualizationRequest) GetVisualizationId() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.VisualizationId
        }</span>
        <span class="cov0" title="0">return ""</span>
}

type ListVisualizationsRequest struct {
        state         protoimpl.MessageState
        sizeCache     protoimpl.SizeCache
        unknownFields protoimpl.UnknownFields

        Page     int32 `protobuf:"varint,1,opt,name=page,proto3" json:"page,omitempty"`
        PageSize int32 `protobuf:"varint,2,opt,name=page_size,json=pageSize,proto3" json:"page_size,omitempty"`
}

func (x *ListVisualizationsRequest) Reset() <span class="cov0" title="0">{
        *x = ListVisualizationsRequest{}
        if protoimpl.UnsafeEnabled </span><span class="cov0" title="0">{
                mi := &amp;file_api_proto_visualization_proto_msgTypes[3]
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                ms.StoreMessageInfo(mi)
        }</span>
}

func (x *ListVisualizationsRequest) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*ListVisualizationsRequest) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *ListVisualizationsRequest) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_api_proto_visualization_proto_msgTypes[3]
        if protoimpl.UnsafeEnabled &amp;&amp; x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use ListVisualizationsRequest.ProtoReflect.Descriptor instead.
func (*ListVisualizationsRequest) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_api_proto_visualization_proto_rawDescGZIP(), []int{3}
}</span>

func (x *ListVisualizationsRequest) GetPage() int32 <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Page
        }</span>
        <span class="cov0" title="0">return 0</span>
}

func (x *ListVisualizationsRequest) GetPageSize() int32 <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.PageSize
        }</span>
        <span class="cov0" title="0">return 0</span>
}

type DeleteVisualizationRequest struct {
        state         protoimpl.MessageState
        sizeCache     protoimpl.SizeCache
        unknownFields protoimpl.UnknownFields

        VisualizationId string `protobuf:"bytes,1,opt,name=visualization_id,json=visualizationId,proto3" json:"visualization_id,omitempty"`
}

func (x *DeleteVisualizationRequest) Reset() <span class="cov0" title="0">{
        *x = DeleteVisualizationRequest{}
        if protoimpl.UnsafeEnabled </span><span class="cov0" title="0">{
                mi := &amp;file_api_proto_visualization_proto_msgTypes[4]
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                ms.StoreMessageInfo(mi)
        }</span>
}

func (x *DeleteVisualizationRequest) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*DeleteVisualizationRequest) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *DeleteVisualizationRequest) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_api_proto_visualization_proto_msgTypes[4]
        if protoimpl.UnsafeEnabled &amp;&amp; x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use DeleteVisualizationRequest.ProtoReflect.Descriptor instead.
func (*DeleteVisualizationRequest) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_api_proto_visualization_proto_rawDescGZIP(), []int{4}
}</span>

func (x *DeleteVisualizationRequest) GetVisualizationId() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.VisualizationId
        }</span>
        <span class="cov0" title="0">return ""</span>
}

type ExportVisualizationRequest struct {
        state         protoimpl.MessageState
        sizeCache     protoimpl.SizeCache
        unknownFields protoimpl.UnknownFields

        VisualizationId string `protobuf:"bytes,1,opt,name=visualization_id,json=visualizationId,proto3" json:"visualization_id,omitempty"`
        Format          string `protobuf:"bytes,2,opt,name=format,proto3" json:"format,omitempty"`
}

func (x *ExportVisualizationRequest) Reset() <span class="cov0" title="0">{
        *x = ExportVisualizationRequest{}
        if protoimpl.UnsafeEnabled </span><span class="cov0" title="0">{
                mi := &amp;file_api_proto_visualization_proto_msgTypes[5]
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                ms.StoreMessageInfo(mi)
        }</span>
}

func (x *ExportVisualizationRequest) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*ExportVisualizationRequest) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *ExportVisualizationRequest) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_api_proto_visualization_proto_msgTypes[5]
        if protoimpl.UnsafeEnabled &amp;&amp; x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use ExportVisualizationRequest.ProtoReflect.Descriptor instead.
func (*ExportVisualizationRequest) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_api_proto_visualization_proto_rawDescGZIP(), []int{5}
}</span>

func (x *ExportVisualizationRequest) GetVisualizationId() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.VisualizationId
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *ExportVisualizationRequest) GetFormat() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Format
        }</span>
        <span class="cov0" title="0">return ""</span>
}

type VisualizationResponse struct {
        state         protoimpl.MessageState
        sizeCache     protoimpl.SizeCache
        unknownFields protoimpl.UnknownFields

        VisualizationId   string            `protobuf:"bytes,1,opt,name=visualization_id,json=visualizationId,proto3" json:"visualization_id,omitempty"`
        VisualizationData []byte            `protobuf:"bytes,2,opt,name=visualization_data,json=visualizationData,proto3" json:"visualization_data,omitempty"`
        Metadata          map[string]string `protobuf:"bytes,3,rep,name=metadata,proto3" json:"metadata,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
}

func (x *VisualizationResponse) Reset() <span class="cov0" title="0">{
        *x = VisualizationResponse{}
        if protoimpl.UnsafeEnabled </span><span class="cov0" title="0">{
                mi := &amp;file_api_proto_visualization_proto_msgTypes[6]
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                ms.StoreMessageInfo(mi)
        }</span>
}

func (x *VisualizationResponse) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*VisualizationResponse) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *VisualizationResponse) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_api_proto_visualization_proto_msgTypes[6]
        if protoimpl.UnsafeEnabled &amp;&amp; x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use VisualizationResponse.ProtoReflect.Descriptor instead.
func (*VisualizationResponse) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_api_proto_visualization_proto_rawDescGZIP(), []int{6}
}</span>

func (x *VisualizationResponse) GetVisualizationId() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.VisualizationId
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *VisualizationResponse) GetVisualizationData() []byte <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.VisualizationData
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (x *VisualizationResponse) GetMetadata() map[string]string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Metadata
        }</span>
        <span class="cov0" title="0">return nil</span>
}

type ListVisualizationsResponse struct {
        state         protoimpl.MessageState
        sizeCache     protoimpl.SizeCache
        unknownFields protoimpl.UnknownFields

        Visualizations []*VisualizationResponse `protobuf:"bytes,1,rep,name=visualizations,proto3" json:"visualizations,omitempty"`
        TotalCount     int32                    `protobuf:"varint,2,opt,name=total_count,json=totalCount,proto3" json:"total_count,omitempty"`
}

func (x *ListVisualizationsResponse) Reset() <span class="cov0" title="0">{
        *x = ListVisualizationsResponse{}
        if protoimpl.UnsafeEnabled </span><span class="cov0" title="0">{
                mi := &amp;file_api_proto_visualization_proto_msgTypes[7]
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                ms.StoreMessageInfo(mi)
        }</span>
}

func (x *ListVisualizationsResponse) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*ListVisualizationsResponse) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *ListVisualizationsResponse) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_api_proto_visualization_proto_msgTypes[7]
        if protoimpl.UnsafeEnabled &amp;&amp; x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use ListVisualizationsResponse.ProtoReflect.Descriptor instead.
func (*ListVisualizationsResponse) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_api_proto_visualization_proto_rawDescGZIP(), []int{7}
}</span>

func (x *ListVisualizationsResponse) GetVisualizations() []*VisualizationResponse <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Visualizations
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (x *ListVisualizationsResponse) GetTotalCount() int32 <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.TotalCount
        }</span>
        <span class="cov0" title="0">return 0</span>
}

type DeleteVisualizationResponse struct {
        state         protoimpl.MessageState
        sizeCache     protoimpl.SizeCache
        unknownFields protoimpl.UnknownFields

        Success bool `protobuf:"varint,1,opt,name=success,proto3" json:"success,omitempty"`
}

func (x *DeleteVisualizationResponse) Reset() <span class="cov0" title="0">{
        *x = DeleteVisualizationResponse{}
        if protoimpl.UnsafeEnabled </span><span class="cov0" title="0">{
                mi := &amp;file_api_proto_visualization_proto_msgTypes[8]
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                ms.StoreMessageInfo(mi)
        }</span>
}

func (x *DeleteVisualizationResponse) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*DeleteVisualizationResponse) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *DeleteVisualizationResponse) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_api_proto_visualization_proto_msgTypes[8]
        if protoimpl.UnsafeEnabled &amp;&amp; x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use DeleteVisualizationResponse.ProtoReflect.Descriptor instead.
func (*DeleteVisualizationResponse) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_api_proto_visualization_proto_rawDescGZIP(), []int{8}
}</span>

func (x *DeleteVisualizationResponse) GetSuccess() bool <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Success
        }</span>
        <span class="cov0" title="0">return false</span>
}

type ExportVisualizationResponse struct {
        state         protoimpl.MessageState
        sizeCache     protoimpl.SizeCache
        unknownFields protoimpl.UnknownFields

        ExportedData []byte `protobuf:"bytes,1,opt,name=exported_data,json=exportedData,proto3" json:"exported_data,omitempty"`
        Format       string `protobuf:"bytes,2,opt,name=format,proto3" json:"format,omitempty"`
}

func (x *ExportVisualizationResponse) Reset() <span class="cov0" title="0">{
        *x = ExportVisualizationResponse{}
        if protoimpl.UnsafeEnabled </span><span class="cov0" title="0">{
                mi := &amp;file_api_proto_visualization_proto_msgTypes[9]
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                ms.StoreMessageInfo(mi)
        }</span>
}

func (x *ExportVisualizationResponse) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*ExportVisualizationResponse) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *ExportVisualizationResponse) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_api_proto_visualization_proto_msgTypes[9]
        if protoimpl.UnsafeEnabled &amp;&amp; x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use ExportVisualizationResponse.ProtoReflect.Descriptor instead.
func (*ExportVisualizationResponse) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_api_proto_visualization_proto_rawDescGZIP(), []int{9}
}</span>

func (x *ExportVisualizationResponse) GetExportedData() []byte <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.ExportedData
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (x *ExportVisualizationResponse) GetFormat() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Format
        }</span>
        <span class="cov0" title="0">return ""</span>
}

var File_api_proto_visualization_proto protoreflect.FileDescriptor

var file_api_proto_visualization_proto_rawDesc = []byte{
        0x0a, 0x1d, 0x61, 0x70, 0x69, 0x2f, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x2f, 0x76, 0x69, 0x73, 0x75,
        0x61, 0x6c, 0x69, 0x7a, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x2e, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x12,
        0x0d, 0x76, 0x69, 0x73, 0x75, 0x61, 0x6c, 0x69, 0x7a, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x22, 0xc9,
        0x03, 0x0a, 0x1a, 0x43, 0x72, 0x65, 0x61, 0x74, 0x65, 0x56, 0x69, 0x73, 0x75, 0x61, 0x6c, 0x69,
        0x7a, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x52, 0x65, 0x71, 0x75, 0x65, 0x73, 0x74, 0x12, 0x24, 0x0a,
        0x0e, 0x64, 0x61, 0x74, 0x61, 0x5f, 0x73, 0x6f, 0x75, 0x72, 0x63, 0x65, 0x5f, 0x69, 0x64, 0x18,
        0x01, 0x20, 0x01, 0x28, 0x09, 0x52, 0x0c, 0x64, 0x61, 0x74, 0x61, 0x53, 0x6f, 0x75, 0x72, 0x63,
        0x65, 0x49, 0x64, 0x12, 0x2d, 0x0a, 0x12, 0x76, 0x69, 0x73, 0x75, 0x61, 0x6c, 0x69, 0x7a, 0x61,
        0x74, 0x69, 0x6f, 0x6e, 0x5f, 0x74, 0x79, 0x70, 0x65, 0x18, 0x02, 0x20, 0x01, 0x28, 0x09, 0x52,
        0x11, 0x76, 0x69, 0x73, 0x75, 0x61, 0x6c, 0x69, 0x7a, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x54, 0x79,
        0x70, 0x65, 0x12, 0x1e, 0x0a, 0x0a, 0x64, 0x69, 0x6d, 0x65, 0x6e, 0x73, 0x69, 0x6f, 0x6e, 0x73,
        0x18, 0x03, 0x20, 0x03, 0x28, 0x09, 0x52, 0x0a, 0x64, 0x69, 0x6d, 0x65, 0x6e, 0x73, 0x69, 0x6f,
        0x6e, 0x73, 0x12, 0x1a, 0x0a, 0x08, 0x6d, 0x65, 0x61, 0x73, 0x75, 0x72, 0x65, 0x73, 0x18, 0x04,
        0x20, 0x03, 0x28, 0x09, 0x52, 0x08, 0x6d, 0x65, 0x61, 0x73, 0x75, 0x72, 0x65, 0x73, 0x12, 0x50,
        0x0a, 0x07, 0x66, 0x69, 0x6c, 0x74, 0x65, 0x72, 0x73, 0x18, 0x05, 0x20, 0x03, 0x28, 0x0b, 0x32,
        0x36, 0x2e, 0x76, 0x69, 0x73, 0x75, 0x61, 0x6c, 0x69, 0x7a, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x2e,
        0x43, 0x72, 0x65, 0x61, 0x74, 0x65, 0x56, 0x69, 0x73, 0x75, 0x61, 0x6c, 0x69, 0x7a, 0x61, 0x74,
        0x69, 0x6f, 0x6e, 0x52, 0x65, 0x71, 0x75, 0x65, 0x73, 0x74, 0x2e, 0x46, 0x69, 0x6c, 0x74, 0x65,
        0x72, 0x73, 0x45, 0x6e, 0x74, 0x72, 0x79, 0x52, 0x07, 0x66, 0x69, 0x6c, 0x74, 0x65, 0x72, 0x73,
        0x12, 0x50, 0x0a, 0x07, 0x6f, 0x70, 0x74, 0x69, 0x6f, 0x6e, 0x73, 0x18, 0x06, 0x20, 0x03, 0x28,
        0x0b, 0x32, 0x36, 0x2e, 0x76, 0x69, 0x73, 0x75, 0x61, 0x6c, 0x69, 0x7a, 0x61, 0x74, 0x69, 0x6f,
        0x6e, 0x2e, 0x43, 0x72, 0x65, 0x61, 0x74, 0x65, 0x56, 0x69, 0x73, 0x75, 0x61, 0x6c, 0x69, 0x7a,
        0x61, 0x74, 0x69, 0x6f, 0x6e, 0x52, 0x65, 0x71, 0x75, 0x65, 0x73, 0x74, 0x2e, 0x4f, 0x70, 0x74,
        0x69, 0x6f, 0x6e, 0x73, 0x45, 0x6e, 0x74, 0x72, 0x79, 0x52, 0x07, 0x6f, 0x70, 0x74, 0x69, 0x6f,
        0x6e, 0x73, 0x1a, 0x3a, 0x0a, 0x0c, 0x46, 0x69, 0x6c, 0x74, 0x65, 0x72, 0x73, 0x45, 0x6e, 0x74,
        0x72, 0x79, 0x12, 0x10, 0x0a, 0x03, 0x6b, 0x65, 0x79, 0x18, 0x01, 0x20, 0x01, 0x28, 0x09, 0x52,
        0x03, 0x6b, 0x65, 0x79, 0x12, 0x14, 0x0a, 0x05, 0x76, 0x61, 0x6c, 0x75, 0x65, 0x18, 0x02, 0x20,
        0x01, 0x28, 0x09, 0x52, 0x05, 0x76, 0x61, 0x6c, 0x75, 0x65, 0x3a, 0x02, 0x38, 0x01, 0x1a, 0x3a,
        0x0a, 0x0c, 0x4f, 0x70, 0x74, 0x69, 0x6f, 0x6e, 0x73, 0x45, 0x6e, 0x74, 0x72, 0x79, 0x12, 0x10,
        0x0a, 0x03, 0x6b, 0x65, 0x79, 0x18, 0x01, 0x20, 0x01, 0x28, 0x09, 0x52, 0x03, 0x6b, 0x65, 0x79,
        0x12, 0x14, 0x0a, 0x05, 0x76, 0x61, 0x6c, 0x75, 0x65, 0x18, 0x02, 0x20, 0x01, 0x28, 0x09, 0x52,
        0x05, 0x76, 0x61, 0x6c, 0x75, 0x65, 0x3a, 0x02, 0x38, 0x01, 0x22, 0x93, 0x01, 0x0a, 0x1a, 0x55,
        0x70, 0x64, 0x61, 0x74, 0x65, 0x56, 0x69, 0x73, 0x75, 0x61, 0x6c, 0x69, 0x7a, 0x61, 0x74, 0x69,
        0x6f, 0x6e, 0x52, 0x65, 0x71, 0x75, 0x65, 0x73, 0x74, 0x12, 0x29, 0x0a, 0x10, 0x76, 0x69, 0x73,
        0x75, 0x61, 0x6c, 0x69, 0x7a, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x5f, 0x69, 0x64, 0x18, 0x01, 0x20,
        0x01, 0x28, 0x09, 0x52, 0x0f, 0x76, 0x69, 0x73, 0x75, 0x61, 0x6c, 0x69, 0x7a, 0x61, 0x74, 0x69,
        0x6f, 0x6e, 0x49, 0x64, 0x12, 0x4a, 0x0a, 0x0b, 0x75, 0x70, 0x64, 0x61, 0x74, 0x65, 0x5f, 0x64,
        0x61, 0x74, 0x61, 0x18, 0x02, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x29, 0x2e, 0x76, 0x69, 0x73, 0x75,
        0x61, 0x6c, 0x69, 0x7a, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x2e, 0x43, 0x72, 0x65, 0x61, 0x74, 0x65,
        0x56, 0x69, 0x73, 0x75, 0x61, 0x6c, 0x69, 0x7a, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x52, 0x65, 0x71,
        0x75, 0x65, 0x73, 0x74, 0x52, 0x0a, 0x75, 0x70, 0x64, 0x61, 0x74, 0x65, 0x44, 0x61, 0x74, 0x61,
        0x22, 0x44, 0x0a, 0x17, 0x47, 0x65, 0x74, 0x56, 0x69, 0x73, 0x75, 0x61, 0x6c, 0x69, 0x7a, 0x61,
        0x74, 0x69, 0x6f, 0x6e, 0x52, 0x65, 0x71, 0x75, 0x65, 0x73, 0x74, 0x12, 0x29, 0x0a, 0x10, 0x76,
        0x69, 0x73, 0x75, 0x61, 0x6c, 0x69, 0x7a, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x5f, 0x69, 0x64, 0x18,
        0x01, 0x20, 0x01, 0x28, 0x09, 0x52, 0x0f, 0x76, 0x69, 0x73, 0x75, 0x61, 0x6c, 0x69, 0x7a, 0x61,
        0x74, 0x69, 0x6f, 0x6e, 0x49, 0x64, 0x22, 0x4c, 0x0a, 0x19, 0x4c, 0x69, 0x73, 0x74, 0x56, 0x69,
        0x73, 0x75, 0x61, 0x6c, 0x69, 0x7a, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x73, 0x52, 0x65, 0x71, 0x75,
        0x65, 0x73, 0x74, 0x12, 0x12, 0x0a, 0x04, 0x70, 0x61, 0x67, 0x65, 0x18, 0x01, 0x20, 0x01, 0x28,
        0x05, 0x52, 0x04, 0x70, 0x61, 0x67, 0x65, 0x12, 0x1b, 0x0a, 0x09, 0x70, 0x61, 0x67, 0x65, 0x5f,
        0x73, 0x69, 0x7a, 0x65, 0x18, 0x02, 0x20, 0x01, 0x28, 0x05, 0x52, 0x08, 0x70, 0x61, 0x67, 0x65,
        0x53, 0x69, 0x7a, 0x65, 0x22, 0x47, 0x0a, 0x1a, 0x44, 0x65, 0x6c, 0x65, 0x74, 0x65, 0x56, 0x69,
        0x73, 0x75, 0x61, 0x6c, 0x69, 0x7a, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x52, 0x65, 0x71, 0x75, 0x65,
        0x73, 0x74, 0x12, 0x29, 0x0a, 0x10, 0x76, 0x69, 0x73, 0x75, 0x61, 0x6c, 0x69, 0x7a, 0x61, 0x74,
        0x69, 0x6f, 0x6e, 0x5f, 0x69, 0x64, 0x18, 0x01, 0x20, 0x01, 0x28, 0x09, 0x52, 0x0f, 0x76, 0x69,
        0x73, 0x75, 0x61, 0x6c, 0x69, 0x7a, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x49, 0x64, 0x22, 0x5f, 0x0a,
        0x1a, 0x45, 0x78, 0x70, 0x6f, 0x72, 0x74, 0x56, 0x69, 0x73, 0x75, 0x61, 0x6c, 0x69, 0x7a, 0x61,
        0x74, 0x69, 0x6f, 0x6e, 0x52, 0x65, 0x71, 0x75, 0x65, 0x73, 0x74, 0x12, 0x29, 0x0a, 0x10, 0x76,
        0x69, 0x73, 0x75, 0x61, 0x6c, 0x69, 0x7a, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x5f, 0x69, 0x64, 0x18,
        0x01, 0x20, 0x01, 0x28, 0x09, 0x52, 0x0f, 0x76, 0x69, 0x73, 0x75, 0x61, 0x6c, 0x69, 0x7a, 0x61,
        0x74, 0x69, 0x6f, 0x6e, 0x49, 0x64, 0x12, 0x16, 0x0a, 0x06, 0x66, 0x6f, 0x72, 0x6d, 0x61, 0x74,
        0x18, 0x02, 0x20, 0x01, 0x28, 0x09, 0x52, 0x06, 0x66, 0x6f, 0x72, 0x6d, 0x61, 0x74, 0x22, 0xfe,
        0x01, 0x0a, 0x15, 0x56, 0x69, 0x73, 0x75, 0x61, 0x6c, 0x69, 0x7a, 0x61, 0x74, 0x69, 0x6f, 0x6e,
        0x52, 0x65, 0x73, 0x70, 0x6f, 0x6e, 0x73, 0x65, 0x12, 0x29, 0x0a, 0x10, 0x76, 0x69, 0x73, 0x75,
        0x61, 0x6c, 0x69, 0x7a, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x5f, 0x69, 0x64, 0x18, 0x01, 0x20, 0x01,
        0x28, 0x09, 0x52, 0x0f, 0x76, 0x69, 0x73, 0x75, 0x61, 0x6c, 0x69, 0x7a, 0x61, 0x74, 0x69, 0x6f,
        0x6e, 0x49, 0x64, 0x12, 0x2d, 0x0a, 0x12, 0x76, 0x69, 0x73, 0x75, 0x61, 0x6c, 0x69, 0x7a, 0x61,
        0x74, 0x69, 0x6f, 0x6e, 0x5f, 0x64, 0x61, 0x74, 0x61, 0x18, 0x02, 0x20, 0x01, 0x28, 0x0c, 0x52,
        0x11, 0x76, 0x69, 0x73, 0x75, 0x61, 0x6c, 0x69, 0x7a, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x44, 0x61,
        0x74, 0x61, 0x12, 0x4e, 0x0a, 0x08, 0x6d, 0x65, 0x74, 0x61, 0x64, 0x61, 0x74, 0x61, 0x18, 0x03,
        0x20, 0x03, 0x28, 0x0b, 0x32, 0x32, 0x2e, 0x76, 0x69, 0x73, 0x75, 0x61, 0x6c, 0x69, 0x7a, 0x61,
        0x74, 0x69, 0x6f, 0x6e, 0x2e, 0x56, 0x69, 0x73, 0x75, 0x61, 0x6c, 0x69, 0x7a, 0x61, 0x74, 0x69,
        0x6f, 0x6e, 0x52, 0x65, 0x73, 0x70, 0x6f, 0x6e, 0x73, 0x65, 0x2e, 0x4d, 0x65, 0x74, 0x61, 0x64,
        0x61, 0x74, 0x61, 0x45, 0x6e, 0x74, 0x72, 0x79, 0x52, 0x08, 0x6d, 0x65, 0x74, 0x61, 0x64, 0x61,
        0x74, 0x61, 0x1a, 0x3b, 0x0a, 0x0d, 0x4d, 0x65, 0x74, 0x61, 0x64, 0x61, 0x74, 0x61, 0x45, 0x6e,
        0x74, 0x72, 0x79, 0x12, 0x10, 0x0a, 0x03, 0x6b, 0x65, 0x79, 0x18, 0x01, 0x20, 0x01, 0x28, 0x09,
        0x52, 0x03, 0x6b, 0x65, 0x79, 0x12, 0x14, 0x0a, 0x05, 0x76, 0x61, 0x6c, 0x75, 0x65, 0x18, 0x02,
        0x20, 0x01, 0x28, 0x09, 0x52, 0x05, 0x76, 0x61, 0x6c, 0x75, 0x65, 0x3a, 0x02, 0x38, 0x01, 0x22,
        0x8b, 0x01, 0x0a, 0x1a, 0x4c, 0x69, 0x73, 0x74, 0x56, 0x69, 0x73, 0x75, 0x61, 0x6c, 0x69, 0x7a,
        0x61, 0x74, 0x69, 0x6f, 0x6e, 0x73, 0x52, 0x65, 0x73, 0x70, 0x6f, 0x6e, 0x73, 0x65, 0x12, 0x4c,
        0x0a, 0x0e, 0x76, 0x69, 0x73, 0x75, 0x61, 0x6c, 0x69, 0x7a, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x73,
        0x18, 0x01, 0x20, 0x03, 0x28, 0x0b, 0x32, 0x24, 0x2e, 0x76, 0x69, 0x73, 0x75, 0x61, 0x6c, 0x69,
        0x7a, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x2e, 0x56, 0x69, 0x73, 0x75, 0x61, 0x6c, 0x69, 0x7a, 0x61,
        0x74, 0x69, 0x6f, 0x6e, 0x52, 0x65, 0x73, 0x70, 0x6f, 0x6e, 0x73, 0x65, 0x52, 0x0e, 0x76, 0x69,
        0x73, 0x75, 0x61, 0x6c, 0x69, 0x7a, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x73, 0x12, 0x1f, 0x0a, 0x0b,
        0x74, 0x6f, 0x74, 0x61, 0x6c, 0x5f, 0x63, 0x6f, 0x75, 0x6e, 0x74, 0x18, 0x02, 0x20, 0x01, 0x28,
        0x05, 0x52, 0x0a, 0x74, 0x6f, 0x74, 0x61, 0x6c, 0x43, 0x6f, 0x75, 0x6e, 0x74, 0x22, 0x37, 0x0a,
        0x1b, 0x44, 0x65, 0x6c, 0x65, 0x74, 0x65, 0x56, 0x69, 0x73, 0x75, 0x61, 0x6c, 0x69, 0x7a, 0x61,
        0x74, 0x69, 0x6f, 0x6e, 0x52, 0x65, 0x73, 0x70, 0x6f, 0x6e, 0x73, 0x65, 0x12, 0x18, 0x0a, 0x07,
        0x73, 0x75, 0x63, 0x63, 0x65, 0x73, 0x73, 0x18, 0x01, 0x20, 0x01, 0x28, 0x08, 0x52, 0x07, 0x73,
        0x75, 0x63, 0x63, 0x65, 0x73, 0x73, 0x22, 0x5a, 0x0a, 0x1b, 0x45, 0x78, 0x70, 0x6f, 0x72, 0x74,
        0x56, 0x69, 0x73, 0x75, 0x61, 0x6c, 0x69, 0x7a, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x52, 0x65, 0x73,
        0x70, 0x6f, 0x6e, 0x73, 0x65, 0x12, 0x23, 0x0a, 0x0d, 0x65, 0x78, 0x70, 0x6f, 0x72, 0x74, 0x65,
        0x64, 0x5f, 0x64, 0x61, 0x74, 0x61, 0x18, 0x01, 0x20, 0x01, 0x28, 0x0c, 0x52, 0x0c, 0x65, 0x78,
        0x70, 0x6f, 0x72, 0x74, 0x65, 0x64, 0x44, 0x61, 0x74, 0x61, 0x12, 0x16, 0x0a, 0x06, 0x66, 0x6f,
        0x72, 0x6d, 0x61, 0x74, 0x18, 0x02, 0x20, 0x01, 0x28, 0x09, 0x52, 0x06, 0x66, 0x6f, 0x72, 0x6d,
        0x61, 0x74, 0x32, 0x9b, 0x05, 0x0a, 0x14, 0x56, 0x69, 0x73, 0x75, 0x61, 0x6c, 0x69, 0x7a, 0x61,
        0x74, 0x69, 0x6f, 0x6e, 0x53, 0x65, 0x72, 0x76, 0x69, 0x63, 0x65, 0x12, 0x68, 0x0a, 0x13, 0x43,
        0x72, 0x65, 0x61, 0x74, 0x65, 0x56, 0x69, 0x73, 0x75, 0x61, 0x6c, 0x69, 0x7a, 0x61, 0x74, 0x69,
        0x6f, 0x6e, 0x12, 0x29, 0x2e, 0x76, 0x69, 0x73, 0x75, 0x61, 0x6c, 0x69, 0x7a, 0x61, 0x74, 0x69,
        0x6f, 0x6e, 0x2e, 0x43, 0x72, 0x65, 0x61, 0x74, 0x65, 0x56, 0x69, 0x73, 0x75, 0x61, 0x6c, 0x69,
        0x7a, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x52, 0x65, 0x71, 0x75, 0x65, 0x73, 0x74, 0x1a, 0x24, 0x2e,
        0x76, 0x69, 0x73, 0x75, 0x61, 0x6c, 0x69, 0x7a, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x2e, 0x56, 0x69,
        0x73, 0x75, 0x61, 0x6c, 0x69, 0x7a, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x52, 0x65, 0x73, 0x70, 0x6f,
        0x6e, 0x73, 0x65, 0x22, 0x00, 0x12, 0x68, 0x0a, 0x13, 0x55, 0x70, 0x64, 0x61, 0x74, 0x65, 0x56,
        0x69, 0x73, 0x75, 0x61, 0x6c, 0x69, 0x7a, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x12, 0x29, 0x2e, 0x76,
        0x69, 0x73, 0x75, 0x61, 0x6c, 0x69, 0x7a, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x2e, 0x55, 0x70, 0x64,
        0x61, 0x74, 0x65, 0x56, 0x69, 0x73, 0x75, 0x61, 0x6c, 0x69, 0x7a, 0x61, 0x74, 0x69, 0x6f, 0x6e,
        0x52, 0x65, 0x71, 0x75, 0x65, 0x73, 0x74, 0x1a, 0x24, 0x2e, 0x76, 0x69, 0x73, 0x75, 0x61, 0x6c,
        0x69, 0x7a, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x2e, 0x56, 0x69, 0x73, 0x75, 0x61, 0x6c, 0x69, 0x7a,
        0x61, 0x74, 0x69, 0x6f, 0x6e, 0x52, 0x65, 0x73, 0x70, 0x6f, 0x6e, 0x73, 0x65, 0x22, 0x00, 0x12,
        0x62, 0x0a, 0x10, 0x47, 0x65, 0x74, 0x56, 0x69, 0x73, 0x75, 0x61, 0x6c, 0x69, 0x7a, 0x61, 0x74,
        0x69, 0x6f, 0x6e, 0x12, 0x26, 0x2e, 0x76, 0x69, 0x73, 0x75, 0x61, 0x6c, 0x69, 0x7a, 0x61, 0x74,
        0x69, 0x6f, 0x6e, 0x2e, 0x47, 0x65, 0x74, 0x56, 0x69, 0x73, 0x75, 0x61, 0x6c, 0x69, 0x7a, 0x61,
        0x74, 0x69, 0x6f, 0x6e, 0x52, 0x65, 0x71, 0x75, 0x65, 0x73, 0x74, 0x1a, 0x24, 0x2e, 0x76, 0x69,
        0x73, 0x75, 0x61, 0x6c, 0x69, 0x7a, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x2e, 0x56, 0x69, 0x73, 0x75,
        0x61, 0x6c, 0x69, 0x7a, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x52, 0x65, 0x73, 0x70, 0x6f, 0x6e, 0x73,
        0x65, 0x22, 0x00, 0x12, 0x6b, 0x0a, 0x12, 0x4c, 0x69, 0x73, 0x74, 0x56, 0x69, 0x73, 0x75, 0x61,
        0x6c, 0x69, 0x7a, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x73, 0x12, 0x28, 0x2e, 0x76, 0x69, 0x73, 0x75,
        0x61, 0x6c, 0x69, 0x7a, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x2e, 0x4c, 0x69, 0x73, 0x74, 0x56, 0x69,
        0x73, 0x75, 0x61, 0x6c, 0x69, 0x7a, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x73, 0x52, 0x65, 0x71, 0x75,
        0x65, 0x73, 0x74, 0x1a, 0x29, 0x2e, 0x76, 0x69, 0x73, 0x75, 0x61, 0x6c, 0x69, 0x7a, 0x61, 0x74,
        0x69, 0x6f, 0x6e, 0x2e, 0x4c, 0x69, 0x73, 0x74, 0x56, 0x69, 0x73, 0x75, 0x61, 0x6c, 0x69, 0x7a,
        0x61, 0x74, 0x69, 0x6f, 0x6e, 0x73, 0x52, 0x65, 0x73, 0x70, 0x6f, 0x6e, 0x73, 0x65, 0x22, 0x00,
        0x12, 0x6e, 0x0a, 0x13, 0x44, 0x65, 0x6c, 0x65, 0x74, 0x65, 0x56, 0x69, 0x73, 0x75, 0x61, 0x6c,
        0x69, 0x7a, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x12, 0x29, 0x2e, 0x76, 0x69, 0x73, 0x75, 0x61, 0x6c,
        0x69, 0x7a, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x2e, 0x44, 0x65, 0x6c, 0x65, 0x74, 0x65, 0x56, 0x69,
        0x73, 0x75, 0x61, 0x6c, 0x69, 0x7a, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x52, 0x65, 0x71, 0x75, 0x65,
        0x73, 0x74, 0x1a, 0x2a, 0x2e, 0x76, 0x69, 0x73, 0x75, 0x61, 0x6c, 0x69, 0x7a, 0x61, 0x74, 0x69,
        0x6f, 0x6e, 0x2e, 0x44, 0x65, 0x6c, 0x65, 0x74, 0x65, 0x56, 0x69, 0x73, 0x75, 0x61, 0x6c, 0x69,
        0x7a, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x52, 0x65, 0x73, 0x70, 0x6f, 0x6e, 0x73, 0x65, 0x22, 0x00,
        0x12, 0x6e, 0x0a, 0x13, 0x45, 0x78, 0x70, 0x6f, 0x72, 0x74, 0x56, 0x69, 0x73, 0x75, 0x61, 0x6c,
        0x69, 0x7a, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x12, 0x29, 0x2e, 0x76, 0x69, 0x73, 0x75, 0x61, 0x6c,
        0x69, 0x7a, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x2e, 0x45, 0x78, 0x70, 0x6f, 0x72, 0x74, 0x56, 0x69,
        0x73, 0x75, 0x61, 0x6c, 0x69, 0x7a, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x52, 0x65, 0x71, 0x75, 0x65,
        0x73, 0x74, 0x1a, 0x2a, 0x2e, 0x76, 0x69, 0x73, 0x75, 0x61, 0x6c, 0x69, 0x7a, 0x61, 0x74, 0x69,
        0x6f, 0x6e, 0x2e, 0x45, 0x78, 0x70, 0x6f, 0x72, 0x74, 0x56, 0x69, 0x73, 0x75, 0x61, 0x6c, 0x69,
        0x7a, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x52, 0x65, 0x73, 0x70, 0x6f, 0x6e, 0x73, 0x65, 0x22, 0x00,
        0x42, 0x27, 0x5a, 0x25, 0x64, 0x61, 0x74, 0x61, 0x76, 0x69, 0x6e, 0x63, 0x69, 0x2f, 0x69, 0x6e,
        0x74, 0x65, 0x72, 0x6e, 0x61, 0x6c, 0x2f, 0x76, 0x69, 0x73, 0x75, 0x61, 0x6c, 0x69, 0x7a, 0x61,
        0x74, 0x69, 0x6f, 0x6e, 0x2f, 0x67, 0x72, 0x70, 0x63, 0x62, 0x06, 0x70, 0x72, 0x6f, 0x74, 0x6f,
        0x33,
}

var (
        file_api_proto_visualization_proto_rawDescOnce sync.Once
        file_api_proto_visualization_proto_rawDescData = file_api_proto_visualization_proto_rawDesc
)

func file_api_proto_visualization_proto_rawDescGZIP() []byte <span class="cov0" title="0">{
        file_api_proto_visualization_proto_rawDescOnce.Do(func() </span><span class="cov0" title="0">{
                file_api_proto_visualization_proto_rawDescData = protoimpl.X.CompressGZIP(file_api_proto_visualization_proto_rawDescData)
        }</span>)
        <span class="cov0" title="0">return file_api_proto_visualization_proto_rawDescData</span>
}

var file_api_proto_visualization_proto_msgTypes = make([]protoimpl.MessageInfo, 13)
var file_api_proto_visualization_proto_goTypes = []any{
        (*CreateVisualizationRequest)(nil),  // 0: visualization.CreateVisualizationRequest
        (*UpdateVisualizationRequest)(nil),  // 1: visualization.UpdateVisualizationRequest
        (*GetVisualizationRequest)(nil),     // 2: visualization.GetVisualizationRequest
        (*ListVisualizationsRequest)(nil),   // 3: visualization.ListVisualizationsRequest
        (*DeleteVisualizationRequest)(nil),  // 4: visualization.DeleteVisualizationRequest
        (*ExportVisualizationRequest)(nil),  // 5: visualization.ExportVisualizationRequest
        (*VisualizationResponse)(nil),       // 6: visualization.VisualizationResponse
        (*ListVisualizationsResponse)(nil),  // 7: visualization.ListVisualizationsResponse
        (*DeleteVisualizationResponse)(nil), // 8: visualization.DeleteVisualizationResponse
        (*ExportVisualizationResponse)(nil), // 9: visualization.ExportVisualizationResponse
        nil,                                 // 10: visualization.CreateVisualizationRequest.FiltersEntry
        nil,                                 // 11: visualization.CreateVisualizationRequest.OptionsEntry
        nil,                                 // 12: visualization.VisualizationResponse.MetadataEntry
}
var file_api_proto_visualization_proto_depIdxs = []int32{
        10, // 0: visualization.CreateVisualizationRequest.filters:type_name -&gt; visualization.CreateVisualizationRequest.FiltersEntry
        11, // 1: visualization.CreateVisualizationRequest.options:type_name -&gt; visualization.CreateVisualizationRequest.OptionsEntry
        0,  // 2: visualization.UpdateVisualizationRequest.update_data:type_name -&gt; visualization.CreateVisualizationRequest
        12, // 3: visualization.VisualizationResponse.metadata:type_name -&gt; visualization.VisualizationResponse.MetadataEntry
        6,  // 4: visualization.ListVisualizationsResponse.visualizations:type_name -&gt; visualization.VisualizationResponse
        0,  // 5: visualization.VisualizationService.CreateVisualization:input_type -&gt; visualization.CreateVisualizationRequest
        1,  // 6: visualization.VisualizationService.UpdateVisualization:input_type -&gt; visualization.UpdateVisualizationRequest
        2,  // 7: visualization.VisualizationService.GetVisualization:input_type -&gt; visualization.GetVisualizationRequest
        3,  // 8: visualization.VisualizationService.ListVisualizations:input_type -&gt; visualization.ListVisualizationsRequest
        4,  // 9: visualization.VisualizationService.DeleteVisualization:input_type -&gt; visualization.DeleteVisualizationRequest
        5,  // 10: visualization.VisualizationService.ExportVisualization:input_type -&gt; visualization.ExportVisualizationRequest
        6,  // 11: visualization.VisualizationService.CreateVisualization:output_type -&gt; visualization.VisualizationResponse
        6,  // 12: visualization.VisualizationService.UpdateVisualization:output_type -&gt; visualization.VisualizationResponse
        6,  // 13: visualization.VisualizationService.GetVisualization:output_type -&gt; visualization.VisualizationResponse
        7,  // 14: visualization.VisualizationService.ListVisualizations:output_type -&gt; visualization.ListVisualizationsResponse
        8,  // 15: visualization.VisualizationService.DeleteVisualization:output_type -&gt; visualization.DeleteVisualizationResponse
        9,  // 16: visualization.VisualizationService.ExportVisualization:output_type -&gt; visualization.ExportVisualizationResponse
        11, // [11:17] is the sub-list for method output_type
        5,  // [5:11] is the sub-list for method input_type
        5,  // [5:5] is the sub-list for extension type_name
        5,  // [5:5] is the sub-list for extension extendee
        0,  // [0:5] is the sub-list for field type_name
}

func init() <span class="cov0" title="0">{ file_api_proto_visualization_proto_init() }</span>
func file_api_proto_visualization_proto_init() <span class="cov0" title="0">{
        if File_api_proto_visualization_proto != nil </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov0" title="0">if !protoimpl.UnsafeEnabled </span><span class="cov0" title="0">{
                file_api_proto_visualization_proto_msgTypes[0].Exporter = func(v any, i int) any </span><span class="cov0" title="0">{
                        switch v := v.(*CreateVisualizationRequest); i </span>{
                        case 0:<span class="cov0" title="0">
                                return &amp;v.state</span>
                        case 1:<span class="cov0" title="0">
                                return &amp;v.sizeCache</span>
                        case 2:<span class="cov0" title="0">
                                return &amp;v.unknownFields</span>
                        default:<span class="cov0" title="0">
                                return nil</span>
                        }
                }
                <span class="cov0" title="0">file_api_proto_visualization_proto_msgTypes[1].Exporter = func(v any, i int) any </span><span class="cov0" title="0">{
                        switch v := v.(*UpdateVisualizationRequest); i </span>{
                        case 0:<span class="cov0" title="0">
                                return &amp;v.state</span>
                        case 1:<span class="cov0" title="0">
                                return &amp;v.sizeCache</span>
                        case 2:<span class="cov0" title="0">
                                return &amp;v.unknownFields</span>
                        default:<span class="cov0" title="0">
                                return nil</span>
                        }
                }
                <span class="cov0" title="0">file_api_proto_visualization_proto_msgTypes[2].Exporter = func(v any, i int) any </span><span class="cov0" title="0">{
                        switch v := v.(*GetVisualizationRequest); i </span>{
                        case 0:<span class="cov0" title="0">
                                return &amp;v.state</span>
                        case 1:<span class="cov0" title="0">
                                return &amp;v.sizeCache</span>
                        case 2:<span class="cov0" title="0">
                                return &amp;v.unknownFields</span>
                        default:<span class="cov0" title="0">
                                return nil</span>
                        }
                }
                <span class="cov0" title="0">file_api_proto_visualization_proto_msgTypes[3].Exporter = func(v any, i int) any </span><span class="cov0" title="0">{
                        switch v := v.(*ListVisualizationsRequest); i </span>{
                        case 0:<span class="cov0" title="0">
                                return &amp;v.state</span>
                        case 1:<span class="cov0" title="0">
                                return &amp;v.sizeCache</span>
                        case 2:<span class="cov0" title="0">
                                return &amp;v.unknownFields</span>
                        default:<span class="cov0" title="0">
                                return nil</span>
                        }
                }
                <span class="cov0" title="0">file_api_proto_visualization_proto_msgTypes[4].Exporter = func(v any, i int) any </span><span class="cov0" title="0">{
                        switch v := v.(*DeleteVisualizationRequest); i </span>{
                        case 0:<span class="cov0" title="0">
                                return &amp;v.state</span>
                        case 1:<span class="cov0" title="0">
                                return &amp;v.sizeCache</span>
                        case 2:<span class="cov0" title="0">
                                return &amp;v.unknownFields</span>
                        default:<span class="cov0" title="0">
                                return nil</span>
                        }
                }
                <span class="cov0" title="0">file_api_proto_visualization_proto_msgTypes[5].Exporter = func(v any, i int) any </span><span class="cov0" title="0">{
                        switch v := v.(*ExportVisualizationRequest); i </span>{
                        case 0:<span class="cov0" title="0">
                                return &amp;v.state</span>
                        case 1:<span class="cov0" title="0">
                                return &amp;v.sizeCache</span>
                        case 2:<span class="cov0" title="0">
                                return &amp;v.unknownFields</span>
                        default:<span class="cov0" title="0">
                                return nil</span>
                        }
                }
                <span class="cov0" title="0">file_api_proto_visualization_proto_msgTypes[6].Exporter = func(v any, i int) any </span><span class="cov0" title="0">{
                        switch v := v.(*VisualizationResponse); i </span>{
                        case 0:<span class="cov0" title="0">
                                return &amp;v.state</span>
                        case 1:<span class="cov0" title="0">
                                return &amp;v.sizeCache</span>
                        case 2:<span class="cov0" title="0">
                                return &amp;v.unknownFields</span>
                        default:<span class="cov0" title="0">
                                return nil</span>
                        }
                }
                <span class="cov0" title="0">file_api_proto_visualization_proto_msgTypes[7].Exporter = func(v any, i int) any </span><span class="cov0" title="0">{
                        switch v := v.(*ListVisualizationsResponse); i </span>{
                        case 0:<span class="cov0" title="0">
                                return &amp;v.state</span>
                        case 1:<span class="cov0" title="0">
                                return &amp;v.sizeCache</span>
                        case 2:<span class="cov0" title="0">
                                return &amp;v.unknownFields</span>
                        default:<span class="cov0" title="0">
                                return nil</span>
                        }
                }
                <span class="cov0" title="0">file_api_proto_visualization_proto_msgTypes[8].Exporter = func(v any, i int) any </span><span class="cov0" title="0">{
                        switch v := v.(*DeleteVisualizationResponse); i </span>{
                        case 0:<span class="cov0" title="0">
                                return &amp;v.state</span>
                        case 1:<span class="cov0" title="0">
                                return &amp;v.sizeCache</span>
                        case 2:<span class="cov0" title="0">
                                return &amp;v.unknownFields</span>
                        default:<span class="cov0" title="0">
                                return nil</span>
                        }
                }
                <span class="cov0" title="0">file_api_proto_visualization_proto_msgTypes[9].Exporter = func(v any, i int) any </span><span class="cov0" title="0">{
                        switch v := v.(*ExportVisualizationResponse); i </span>{
                        case 0:<span class="cov0" title="0">
                                return &amp;v.state</span>
                        case 1:<span class="cov0" title="0">
                                return &amp;v.sizeCache</span>
                        case 2:<span class="cov0" title="0">
                                return &amp;v.unknownFields</span>
                        default:<span class="cov0" title="0">
                                return nil</span>
                        }
                }
        }
        <span class="cov0" title="0">type x struct{}
        out := protoimpl.TypeBuilder{
                File: protoimpl.DescBuilder{
                        GoPackagePath: reflect.TypeOf(x{}).PkgPath(),
                        RawDescriptor: file_api_proto_visualization_proto_rawDesc,
                        NumEnums:      0,
                        NumMessages:   13,
                        NumExtensions: 0,
                        NumServices:   1,
                },
                GoTypes:           file_api_proto_visualization_proto_goTypes,
                DependencyIndexes: file_api_proto_visualization_proto_depIdxs,
                MessageInfos:      file_api_proto_visualization_proto_msgTypes,
        }.Build()
        File_api_proto_visualization_proto = out.File
        file_api_proto_visualization_proto_rawDesc = nil
        file_api_proto_visualization_proto_goTypes = nil
        file_api_proto_visualization_proto_depIdxs = nil</span>
}
</pre>
		
		<pre class="file" id="file73" style="display: none">// Code generated by protoc-gen-go-grpc. DO NOT EDIT.
// versions:
// - protoc-gen-go-grpc v1.4.0
// - protoc             v3.21.12
// source: api/proto/visualization.proto

package grpc

import (
        context "context"

        grpc "google.golang.org/grpc"
        codes "google.golang.org/grpc/codes"
        status "google.golang.org/grpc/status"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
// Requires gRPC-Go v1.62.0 or later.
const _ = grpc.SupportPackageIsVersion8

const (
        VisualizationService_CreateVisualization_FullMethodName = "/visualization.VisualizationService/CreateVisualization"
        VisualizationService_UpdateVisualization_FullMethodName = "/visualization.VisualizationService/UpdateVisualization"
        VisualizationService_GetVisualization_FullMethodName    = "/visualization.VisualizationService/GetVisualization"
        VisualizationService_ListVisualizations_FullMethodName  = "/visualization.VisualizationService/ListVisualizations"
        VisualizationService_DeleteVisualization_FullMethodName = "/visualization.VisualizationService/DeleteVisualization"
        VisualizationService_ExportVisualization_FullMethodName = "/visualization.VisualizationService/ExportVisualization"
)

// VisualizationServiceClient is the client API for VisualizationService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type VisualizationServiceClient interface {
        CreateVisualization(ctx context.Context, in *CreateVisualizationRequest, opts ...grpc.CallOption) (*VisualizationResponse, error)
        UpdateVisualization(ctx context.Context, in *UpdateVisualizationRequest, opts ...grpc.CallOption) (*VisualizationResponse, error)
        GetVisualization(ctx context.Context, in *GetVisualizationRequest, opts ...grpc.CallOption) (*VisualizationResponse, error)
        ListVisualizations(ctx context.Context, in *ListVisualizationsRequest, opts ...grpc.CallOption) (*ListVisualizationsResponse, error)
        DeleteVisualization(ctx context.Context, in *DeleteVisualizationRequest, opts ...grpc.CallOption) (*DeleteVisualizationResponse, error)
        ExportVisualization(ctx context.Context, in *ExportVisualizationRequest, opts ...grpc.CallOption) (*ExportVisualizationResponse, error)
}

type visualizationServiceClient struct {
        cc grpc.ClientConnInterface
}

func NewVisualizationServiceClient(cc grpc.ClientConnInterface) VisualizationServiceClient <span class="cov0" title="0">{
        return &amp;visualizationServiceClient{cc}
}</span>

func (c *visualizationServiceClient) CreateVisualization(ctx context.Context, in *CreateVisualizationRequest, opts ...grpc.CallOption) (*VisualizationResponse, error) <span class="cov0" title="0">{
        cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
        out := new(VisualizationResponse)
        err := c.cc.Invoke(ctx, VisualizationService_CreateVisualization_FullMethodName, in, out, cOpts...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return out, nil</span>
}

func (c *visualizationServiceClient) UpdateVisualization(ctx context.Context, in *UpdateVisualizationRequest, opts ...grpc.CallOption) (*VisualizationResponse, error) <span class="cov0" title="0">{
        cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
        out := new(VisualizationResponse)
        err := c.cc.Invoke(ctx, VisualizationService_UpdateVisualization_FullMethodName, in, out, cOpts...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return out, nil</span>
}

func (c *visualizationServiceClient) GetVisualization(ctx context.Context, in *GetVisualizationRequest, opts ...grpc.CallOption) (*VisualizationResponse, error) <span class="cov0" title="0">{
        cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
        out := new(VisualizationResponse)
        err := c.cc.Invoke(ctx, VisualizationService_GetVisualization_FullMethodName, in, out, cOpts...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return out, nil</span>
}

func (c *visualizationServiceClient) ListVisualizations(ctx context.Context, in *ListVisualizationsRequest, opts ...grpc.CallOption) (*ListVisualizationsResponse, error) <span class="cov0" title="0">{
        cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
        out := new(ListVisualizationsResponse)
        err := c.cc.Invoke(ctx, VisualizationService_ListVisualizations_FullMethodName, in, out, cOpts...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return out, nil</span>
}

func (c *visualizationServiceClient) DeleteVisualization(ctx context.Context, in *DeleteVisualizationRequest, opts ...grpc.CallOption) (*DeleteVisualizationResponse, error) <span class="cov0" title="0">{
        cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
        out := new(DeleteVisualizationResponse)
        err := c.cc.Invoke(ctx, VisualizationService_DeleteVisualization_FullMethodName, in, out, cOpts...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return out, nil</span>
}

func (c *visualizationServiceClient) ExportVisualization(ctx context.Context, in *ExportVisualizationRequest, opts ...grpc.CallOption) (*ExportVisualizationResponse, error) <span class="cov0" title="0">{
        cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
        out := new(ExportVisualizationResponse)
        err := c.cc.Invoke(ctx, VisualizationService_ExportVisualization_FullMethodName, in, out, cOpts...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return out, nil</span>
}

// VisualizationServiceServer is the server API for VisualizationService service.
// All implementations must embed UnimplementedVisualizationServiceServer
// for forward compatibility
type VisualizationServiceServer interface {
        CreateVisualization(context.Context, *CreateVisualizationRequest) (*VisualizationResponse, error)
        UpdateVisualization(context.Context, *UpdateVisualizationRequest) (*VisualizationResponse, error)
        GetVisualization(context.Context, *GetVisualizationRequest) (*VisualizationResponse, error)
        ListVisualizations(context.Context, *ListVisualizationsRequest) (*ListVisualizationsResponse, error)
        DeleteVisualization(context.Context, *DeleteVisualizationRequest) (*DeleteVisualizationResponse, error)
        ExportVisualization(context.Context, *ExportVisualizationRequest) (*ExportVisualizationResponse, error)
        mustEmbedUnimplementedVisualizationServiceServer()
}

// UnimplementedVisualizationServiceServer must be embedded to have forward compatible implementations.
type UnimplementedVisualizationServiceServer struct {
}

func (UnimplementedVisualizationServiceServer) CreateVisualization(context.Context, *CreateVisualizationRequest) (*VisualizationResponse, error) <span class="cov0" title="0">{
        return nil, status.Errorf(codes.Unimplemented, "method CreateVisualization not implemented")
}</span>
func (UnimplementedVisualizationServiceServer) UpdateVisualization(context.Context, *UpdateVisualizationRequest) (*VisualizationResponse, error) <span class="cov0" title="0">{
        return nil, status.Errorf(codes.Unimplemented, "method UpdateVisualization not implemented")
}</span>
func (UnimplementedVisualizationServiceServer) GetVisualization(context.Context, *GetVisualizationRequest) (*VisualizationResponse, error) <span class="cov0" title="0">{
        return nil, status.Errorf(codes.Unimplemented, "method GetVisualization not implemented")
}</span>
func (UnimplementedVisualizationServiceServer) ListVisualizations(context.Context, *ListVisualizationsRequest) (*ListVisualizationsResponse, error) <span class="cov0" title="0">{
        return nil, status.Errorf(codes.Unimplemented, "method ListVisualizations not implemented")
}</span>
func (UnimplementedVisualizationServiceServer) DeleteVisualization(context.Context, *DeleteVisualizationRequest) (*DeleteVisualizationResponse, error) <span class="cov0" title="0">{
        return nil, status.Errorf(codes.Unimplemented, "method DeleteVisualization not implemented")
}</span>
func (UnimplementedVisualizationServiceServer) ExportVisualization(context.Context, *ExportVisualizationRequest) (*ExportVisualizationResponse, error) <span class="cov0" title="0">{
        return nil, status.Errorf(codes.Unimplemented, "method ExportVisualization not implemented")
}</span>
func (UnimplementedVisualizationServiceServer) mustEmbedUnimplementedVisualizationServiceServer() {<span class="cov0" title="0">}</span>

// UnsafeVisualizationServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to VisualizationServiceServer will
// result in compilation errors.
type UnsafeVisualizationServiceServer interface {
        mustEmbedUnimplementedVisualizationServiceServer()
}

func RegisterVisualizationServiceServer(s grpc.ServiceRegistrar, srv VisualizationServiceServer) <span class="cov0" title="0">{
        s.RegisterService(&amp;VisualizationService_ServiceDesc, srv)
}</span>

func _VisualizationService_CreateVisualization_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) <span class="cov0" title="0">{
        in := new(CreateVisualizationRequest)
        if err := dec(in); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">if interceptor == nil </span><span class="cov0" title="0">{
                return srv.(VisualizationServiceServer).CreateVisualization(ctx, in)
        }</span>
        <span class="cov0" title="0">info := &amp;grpc.UnaryServerInfo{
                Server:     srv,
                FullMethod: VisualizationService_CreateVisualization_FullMethodName,
        }
        handler := func(ctx context.Context, req interface{}) (interface{}, error) </span><span class="cov0" title="0">{
                return srv.(VisualizationServiceServer).CreateVisualization(ctx, req.(*CreateVisualizationRequest))
        }</span>
        <span class="cov0" title="0">return interceptor(ctx, in, info, handler)</span>
}

func _VisualizationService_UpdateVisualization_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) <span class="cov0" title="0">{
        in := new(UpdateVisualizationRequest)
        if err := dec(in); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">if interceptor == nil </span><span class="cov0" title="0">{
                return srv.(VisualizationServiceServer).UpdateVisualization(ctx, in)
        }</span>
        <span class="cov0" title="0">info := &amp;grpc.UnaryServerInfo{
                Server:     srv,
                FullMethod: VisualizationService_UpdateVisualization_FullMethodName,
        }
        handler := func(ctx context.Context, req interface{}) (interface{}, error) </span><span class="cov0" title="0">{
                return srv.(VisualizationServiceServer).UpdateVisualization(ctx, req.(*UpdateVisualizationRequest))
        }</span>
        <span class="cov0" title="0">return interceptor(ctx, in, info, handler)</span>
}

func _VisualizationService_GetVisualization_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) <span class="cov0" title="0">{
        in := new(GetVisualizationRequest)
        if err := dec(in); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">if interceptor == nil </span><span class="cov0" title="0">{
                return srv.(VisualizationServiceServer).GetVisualization(ctx, in)
        }</span>
        <span class="cov0" title="0">info := &amp;grpc.UnaryServerInfo{
                Server:     srv,
                FullMethod: VisualizationService_GetVisualization_FullMethodName,
        }
        handler := func(ctx context.Context, req interface{}) (interface{}, error) </span><span class="cov0" title="0">{
                return srv.(VisualizationServiceServer).GetVisualization(ctx, req.(*GetVisualizationRequest))
        }</span>
        <span class="cov0" title="0">return interceptor(ctx, in, info, handler)</span>
}

func _VisualizationService_ListVisualizations_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) <span class="cov0" title="0">{
        in := new(ListVisualizationsRequest)
        if err := dec(in); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">if interceptor == nil </span><span class="cov0" title="0">{
                return srv.(VisualizationServiceServer).ListVisualizations(ctx, in)
        }</span>
        <span class="cov0" title="0">info := &amp;grpc.UnaryServerInfo{
                Server:     srv,
                FullMethod: VisualizationService_ListVisualizations_FullMethodName,
        }
        handler := func(ctx context.Context, req interface{}) (interface{}, error) </span><span class="cov0" title="0">{
                return srv.(VisualizationServiceServer).ListVisualizations(ctx, req.(*ListVisualizationsRequest))
        }</span>
        <span class="cov0" title="0">return interceptor(ctx, in, info, handler)</span>
}

func _VisualizationService_DeleteVisualization_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) <span class="cov0" title="0">{
        in := new(DeleteVisualizationRequest)
        if err := dec(in); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">if interceptor == nil </span><span class="cov0" title="0">{
                return srv.(VisualizationServiceServer).DeleteVisualization(ctx, in)
        }</span>
        <span class="cov0" title="0">info := &amp;grpc.UnaryServerInfo{
                Server:     srv,
                FullMethod: VisualizationService_DeleteVisualization_FullMethodName,
        }
        handler := func(ctx context.Context, req interface{}) (interface{}, error) </span><span class="cov0" title="0">{
                return srv.(VisualizationServiceServer).DeleteVisualization(ctx, req.(*DeleteVisualizationRequest))
        }</span>
        <span class="cov0" title="0">return interceptor(ctx, in, info, handler)</span>
}

func _VisualizationService_ExportVisualization_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) <span class="cov0" title="0">{
        in := new(ExportVisualizationRequest)
        if err := dec(in); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">if interceptor == nil </span><span class="cov0" title="0">{
                return srv.(VisualizationServiceServer).ExportVisualization(ctx, in)
        }</span>
        <span class="cov0" title="0">info := &amp;grpc.UnaryServerInfo{
                Server:     srv,
                FullMethod: VisualizationService_ExportVisualization_FullMethodName,
        }
        handler := func(ctx context.Context, req interface{}) (interface{}, error) </span><span class="cov0" title="0">{
                return srv.(VisualizationServiceServer).ExportVisualization(ctx, req.(*ExportVisualizationRequest))
        }</span>
        <span class="cov0" title="0">return interceptor(ctx, in, info, handler)</span>
}

// VisualizationService_ServiceDesc is the grpc.ServiceDesc for VisualizationService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var VisualizationService_ServiceDesc = grpc.ServiceDesc{
        ServiceName: "visualization.VisualizationService",
        HandlerType: (*VisualizationServiceServer)(nil),
        Methods: []grpc.MethodDesc{
                {
                        MethodName: "CreateVisualization",
                        Handler:    _VisualizationService_CreateVisualization_Handler,
                },
                {
                        MethodName: "UpdateVisualization",
                        Handler:    _VisualizationService_UpdateVisualization_Handler,
                },
                {
                        MethodName: "GetVisualization",
                        Handler:    _VisualizationService_GetVisualization_Handler,
                },
                {
                        MethodName: "ListVisualizations",
                        Handler:    _VisualizationService_ListVisualizations_Handler,
                },
                {
                        MethodName: "DeleteVisualization",
                        Handler:    _VisualizationService_DeleteVisualization_Handler,
                },
                {
                        MethodName: "ExportVisualization",
                        Handler:    _VisualizationService_ExportVisualization_Handler,
                },
        },
        Streams:  []grpc.StreamDesc{},
        Metadata: "api/proto/visualization.proto",
}
</pre>
		
		<pre class="file" id="file74" style="display: none">package main

func main() <span class="cov0" title="0">{
        println("Hello, world!")
}</span>
</pre>
		
		<pre class="file" id="file75" style="display: none">package client

import (
        "context"
        "encoding/json"
        "fmt"

        "datasource/managers/query"
        pb "visualization/data/client"

        "google.golang.org/grpc"
        "google.golang.org/grpc/credentials/insecure"
)

// DataSourceClient is a gRPC client for the DataSource service
type DataSourceClient struct {
        conn   *grpc.ClientConn
        client pb.DataSourceServiceClient
}

// NewDataSourceClient creates a new DataSourceClient
func NewDataSourceClient(address string) (*DataSourceClient, error) <span class="cov0" title="0">{
        conn, err := grpc.NewClient(address, grpc.WithTransportCredentials(insecure.NewCredentials()))
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to connect to DataSource service: %w", err)
        }</span>

        <span class="cov0" title="0">client := pb.NewDataSourceServiceClient(conn)
        return &amp;DataSourceClient{
                conn:   conn,
                client: client,
        }, nil</span>
}

// Close closes the gRPC connection
func (c *DataSourceClient) Close() error <span class="cov0" title="0">{
        return c.conn.Close()
}</span>

// Connect connects to a specific connector
func (c *DataSourceClient) Connect(ctx context.Context, connectorName string) error <span class="cov0" title="0">{
        resp, err := c.client.Connect(ctx, &amp;pb.ConnectRequest{ConnectorName: connectorName})
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to connect: %w", err)
        }</span>
        <span class="cov0" title="0">if !resp.Success </span><span class="cov0" title="0">{
                return fmt.Errorf("connection failed: %s", resp.Error)
        }</span>
        <span class="cov0" title="0">return nil</span>
}

// Disconnect disconnects from a specific connector
func (c *DataSourceClient) Disconnect(ctx context.Context, connectorName string) error <span class="cov0" title="0">{
        resp, err := c.client.Disconnect(ctx, &amp;pb.DisconnectRequest{ConnectorName: connectorName})
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to disconnect: %w", err)
        }</span>
        <span class="cov0" title="0">if !resp.Success </span><span class="cov0" title="0">{
                return fmt.Errorf("disconnection failed: %s", resp.Error)
        }</span>
        <span class="cov0" title="0">return nil</span>
}

// ExecuteQuery executes a query on a specific connector
func (c *DataSourceClient) ExecuteQuery(ctx context.Context, connectorName string, q query.Query) ([]map[string]interface{}, error) <span class="cov0" title="0">{
        queryJSON, err := json.Marshal(q)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to marshal query: %w", err)
        }</span>

        <span class="cov0" title="0">resp, err := c.client.ExecuteQuery(ctx, &amp;pb.QueryRequest{
                ConnectorName: connectorName,
                Query:         string(queryJSON),
        })
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to execute query: %w", err)
        }</span>

        <span class="cov0" title="0">var results []map[string]interface{}
        for _, row := range resp.Rows </span><span class="cov0" title="0">{
                var result map[string]interface{}
                if err := json.Unmarshal(row, &amp;result); err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("failed to unmarshal result: %w", err)
                }</span>
                <span class="cov0" title="0">results = append(results, result)</span>
        }

        <span class="cov0" title="0">return results, nil</span>
}

// ExecuteCommand executes a command on a specific connector
func (c *DataSourceClient) ExecuteCommand(ctx context.Context, connectorName, command string, args ...string) (int64, error) <span class="cov0" title="0">{
        resp, err := c.client.ExecuteCommand(ctx, &amp;pb.CommandRequest{
                ConnectorName: connectorName,
                Command:       command,
                Args:          args,
        })
        if err != nil </span><span class="cov0" title="0">{
                return 0, fmt.Errorf("failed to execute command: %w", err)
        }</span>
        <span class="cov0" title="0">return resp.AffectedRows, nil</span>
}

// GetConnectors retrieves a list of available connectors
func (c *DataSourceClient) GetConnectors(ctx context.Context) ([]string, error) <span class="cov0" title="0">{
        resp, err := c.client.GetConnectors(ctx, &amp;pb.GetConnectorsRequest{})
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to get connectors: %w", err)
        }</span>
        <span class="cov0" title="0">return resp.ConnectorNames, nil</span>
}

// AddConnector adds a new connector
func (c *DataSourceClient) AddConnector(ctx context.Context, name string, config *pb.ConnectorConfig) error <span class="cov0" title="0">{
        resp, err := c.client.AddConnector(ctx, &amp;pb.AddConnectorRequest{
                Name:   name,
                Config: config,
        })
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to add connector: %w", err)
        }</span>
        <span class="cov0" title="0">if !resp.Success </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to add connector: %s", resp.Error)
        }</span>
        <span class="cov0" title="0">return nil</span>
}

// RemoveConnector removes a connector
func (c *DataSourceClient) RemoveConnector(ctx context.Context, name string) error <span class="cov0" title="0">{
        resp, err := c.client.RemoveConnector(ctx, &amp;pb.RemoveConnectorRequest{Name: name})
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to remove connector: %w", err)
        }</span>
        <span class="cov0" title="0">if !resp.Success </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to remove connector: %s", resp.Error)
        }</span>
        <span class="cov0" title="0">return nil</span>
}
</pre>
		
		<pre class="file" id="file76" style="display: none">// Code generated by protoc-gen-go. DO NOT EDIT.
// versions:
//         protoc-gen-go v1.34.2
//         protoc        v3.21.12
// source: connector.proto

package grpc

import (
        reflect "reflect"
        sync "sync"

        protoreflect "google.golang.org/protobuf/reflect/protoreflect"
        protoimpl "google.golang.org/protobuf/runtime/protoimpl"
)

const (
        // Verify that this generated code is sufficiently up-to-date.
        _ = protoimpl.EnforceVersion(20 - protoimpl.MinVersion)
        // Verify that runtime/protoimpl is sufficiently up-to-date.
        _ = protoimpl.EnforceVersion(protoimpl.MaxVersion - 20)
)

type ConnectRequest struct {
        state         protoimpl.MessageState
        sizeCache     protoimpl.SizeCache
        unknownFields protoimpl.UnknownFields

        ConnectorName string `protobuf:"bytes,1,opt,name=connector_name,json=connectorName,proto3" json:"connector_name,omitempty"`
}

func (x *ConnectRequest) Reset() <span class="cov0" title="0">{
        *x = ConnectRequest{}
        if protoimpl.UnsafeEnabled </span><span class="cov0" title="0">{
                mi := &amp;file_connector_proto_msgTypes[0]
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                ms.StoreMessageInfo(mi)
        }</span>
}

func (x *ConnectRequest) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*ConnectRequest) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *ConnectRequest) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_connector_proto_msgTypes[0]
        if protoimpl.UnsafeEnabled &amp;&amp; x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use ConnectRequest.ProtoReflect.Descriptor instead.
func (*ConnectRequest) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_connector_proto_rawDescGZIP(), []int{0}
}</span>

func (x *ConnectRequest) GetConnectorName() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.ConnectorName
        }</span>
        <span class="cov0" title="0">return ""</span>
}

type ConnectResponse struct {
        state         protoimpl.MessageState
        sizeCache     protoimpl.SizeCache
        unknownFields protoimpl.UnknownFields

        Success bool   `protobuf:"varint,1,opt,name=success,proto3" json:"success,omitempty"`
        Error   string `protobuf:"bytes,2,opt,name=error,proto3" json:"error,omitempty"`
}

func (x *ConnectResponse) Reset() <span class="cov0" title="0">{
        *x = ConnectResponse{}
        if protoimpl.UnsafeEnabled </span><span class="cov0" title="0">{
                mi := &amp;file_connector_proto_msgTypes[1]
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                ms.StoreMessageInfo(mi)
        }</span>
}

func (x *ConnectResponse) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*ConnectResponse) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *ConnectResponse) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_connector_proto_msgTypes[1]
        if protoimpl.UnsafeEnabled &amp;&amp; x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use ConnectResponse.ProtoReflect.Descriptor instead.
func (*ConnectResponse) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_connector_proto_rawDescGZIP(), []int{1}
}</span>

func (x *ConnectResponse) GetSuccess() bool <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Success
        }</span>
        <span class="cov0" title="0">return false</span>
}

func (x *ConnectResponse) GetError() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Error
        }</span>
        <span class="cov0" title="0">return ""</span>
}

type DisconnectRequest struct {
        state         protoimpl.MessageState
        sizeCache     protoimpl.SizeCache
        unknownFields protoimpl.UnknownFields

        ConnectorName string `protobuf:"bytes,1,opt,name=connector_name,json=connectorName,proto3" json:"connector_name,omitempty"`
}

func (x *DisconnectRequest) Reset() <span class="cov0" title="0">{
        *x = DisconnectRequest{}
        if protoimpl.UnsafeEnabled </span><span class="cov0" title="0">{
                mi := &amp;file_connector_proto_msgTypes[2]
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                ms.StoreMessageInfo(mi)
        }</span>
}

func (x *DisconnectRequest) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*DisconnectRequest) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *DisconnectRequest) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_connector_proto_msgTypes[2]
        if protoimpl.UnsafeEnabled &amp;&amp; x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use DisconnectRequest.ProtoReflect.Descriptor instead.
func (*DisconnectRequest) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_connector_proto_rawDescGZIP(), []int{2}
}</span>

func (x *DisconnectRequest) GetConnectorName() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.ConnectorName
        }</span>
        <span class="cov0" title="0">return ""</span>
}

type DisconnectResponse struct {
        state         protoimpl.MessageState
        sizeCache     protoimpl.SizeCache
        unknownFields protoimpl.UnknownFields

        Success bool   `protobuf:"varint,1,opt,name=success,proto3" json:"success,omitempty"`
        Error   string `protobuf:"bytes,2,opt,name=error,proto3" json:"error,omitempty"`
}

func (x *DisconnectResponse) Reset() <span class="cov0" title="0">{
        *x = DisconnectResponse{}
        if protoimpl.UnsafeEnabled </span><span class="cov0" title="0">{
                mi := &amp;file_connector_proto_msgTypes[3]
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                ms.StoreMessageInfo(mi)
        }</span>
}

func (x *DisconnectResponse) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*DisconnectResponse) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *DisconnectResponse) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_connector_proto_msgTypes[3]
        if protoimpl.UnsafeEnabled &amp;&amp; x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use DisconnectResponse.ProtoReflect.Descriptor instead.
func (*DisconnectResponse) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_connector_proto_rawDescGZIP(), []int{3}
}</span>

func (x *DisconnectResponse) GetSuccess() bool <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Success
        }</span>
        <span class="cov0" title="0">return false</span>
}

func (x *DisconnectResponse) GetError() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Error
        }</span>
        <span class="cov0" title="0">return ""</span>
}

type QueryRequest struct {
        state         protoimpl.MessageState
        sizeCache     protoimpl.SizeCache
        unknownFields protoimpl.UnknownFields

        ConnectorName string   `protobuf:"bytes,1,opt,name=connector_name,json=connectorName,proto3" json:"connector_name,omitempty"`
        Query         string   `protobuf:"bytes,2,opt,name=query,proto3" json:"query,omitempty"`
        Args          []string `protobuf:"bytes,3,rep,name=args,proto3" json:"args,omitempty"`
}

func (x *QueryRequest) Reset() <span class="cov0" title="0">{
        *x = QueryRequest{}
        if protoimpl.UnsafeEnabled </span><span class="cov0" title="0">{
                mi := &amp;file_connector_proto_msgTypes[4]
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                ms.StoreMessageInfo(mi)
        }</span>
}

func (x *QueryRequest) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*QueryRequest) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *QueryRequest) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_connector_proto_msgTypes[4]
        if protoimpl.UnsafeEnabled &amp;&amp; x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use QueryRequest.ProtoReflect.Descriptor instead.
func (*QueryRequest) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_connector_proto_rawDescGZIP(), []int{4}
}</span>

func (x *QueryRequest) GetConnectorName() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.ConnectorName
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *QueryRequest) GetQuery() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Query
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *QueryRequest) GetArgs() []string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Args
        }</span>
        <span class="cov0" title="0">return nil</span>
}

type QueryResponse struct {
        state         protoimpl.MessageState
        sizeCache     protoimpl.SizeCache
        unknownFields protoimpl.UnknownFields

        Rows  [][]byte `protobuf:"bytes,1,rep,name=rows,proto3" json:"rows,omitempty"`
        Error string   `protobuf:"bytes,2,opt,name=error,proto3" json:"error,omitempty"`
}

func (x *QueryResponse) Reset() <span class="cov0" title="0">{
        *x = QueryResponse{}
        if protoimpl.UnsafeEnabled </span><span class="cov0" title="0">{
                mi := &amp;file_connector_proto_msgTypes[5]
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                ms.StoreMessageInfo(mi)
        }</span>
}

func (x *QueryResponse) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*QueryResponse) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *QueryResponse) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_connector_proto_msgTypes[5]
        if protoimpl.UnsafeEnabled &amp;&amp; x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use QueryResponse.ProtoReflect.Descriptor instead.
func (*QueryResponse) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_connector_proto_rawDescGZIP(), []int{5}
}</span>

func (x *QueryResponse) GetRows() [][]byte <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Rows
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (x *QueryResponse) GetError() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Error
        }</span>
        <span class="cov0" title="0">return ""</span>
}

type CommandRequest struct {
        state         protoimpl.MessageState
        sizeCache     protoimpl.SizeCache
        unknownFields protoimpl.UnknownFields

        ConnectorName string   `protobuf:"bytes,1,opt,name=connector_name,json=connectorName,proto3" json:"connector_name,omitempty"`
        Command       string   `protobuf:"bytes,2,opt,name=command,proto3" json:"command,omitempty"`
        Args          []string `protobuf:"bytes,3,rep,name=args,proto3" json:"args,omitempty"`
}

func (x *CommandRequest) Reset() <span class="cov0" title="0">{
        *x = CommandRequest{}
        if protoimpl.UnsafeEnabled </span><span class="cov0" title="0">{
                mi := &amp;file_connector_proto_msgTypes[6]
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                ms.StoreMessageInfo(mi)
        }</span>
}

func (x *CommandRequest) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*CommandRequest) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *CommandRequest) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_connector_proto_msgTypes[6]
        if protoimpl.UnsafeEnabled &amp;&amp; x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use CommandRequest.ProtoReflect.Descriptor instead.
func (*CommandRequest) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_connector_proto_rawDescGZIP(), []int{6}
}</span>

func (x *CommandRequest) GetConnectorName() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.ConnectorName
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *CommandRequest) GetCommand() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Command
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *CommandRequest) GetArgs() []string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Args
        }</span>
        <span class="cov0" title="0">return nil</span>
}

type CommandResponse struct {
        state         protoimpl.MessageState
        sizeCache     protoimpl.SizeCache
        unknownFields protoimpl.UnknownFields

        AffectedRows int64  `protobuf:"varint,1,opt,name=affected_rows,json=affectedRows,proto3" json:"affected_rows,omitempty"`
        Error        string `protobuf:"bytes,2,opt,name=error,proto3" json:"error,omitempty"`
}

func (x *CommandResponse) Reset() <span class="cov0" title="0">{
        *x = CommandResponse{}
        if protoimpl.UnsafeEnabled </span><span class="cov0" title="0">{
                mi := &amp;file_connector_proto_msgTypes[7]
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                ms.StoreMessageInfo(mi)
        }</span>
}

func (x *CommandResponse) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*CommandResponse) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *CommandResponse) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_connector_proto_msgTypes[7]
        if protoimpl.UnsafeEnabled &amp;&amp; x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use CommandResponse.ProtoReflect.Descriptor instead.
func (*CommandResponse) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_connector_proto_rawDescGZIP(), []int{7}
}</span>

func (x *CommandResponse) GetAffectedRows() int64 <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.AffectedRows
        }</span>
        <span class="cov0" title="0">return 0</span>
}

func (x *CommandResponse) GetError() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Error
        }</span>
        <span class="cov0" title="0">return ""</span>
}

type GetConnectorsRequest struct {
        state         protoimpl.MessageState
        sizeCache     protoimpl.SizeCache
        unknownFields protoimpl.UnknownFields
}

func (x *GetConnectorsRequest) Reset() <span class="cov0" title="0">{
        *x = GetConnectorsRequest{}
        if protoimpl.UnsafeEnabled </span><span class="cov0" title="0">{
                mi := &amp;file_connector_proto_msgTypes[8]
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                ms.StoreMessageInfo(mi)
        }</span>
}

func (x *GetConnectorsRequest) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*GetConnectorsRequest) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *GetConnectorsRequest) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_connector_proto_msgTypes[8]
        if protoimpl.UnsafeEnabled &amp;&amp; x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use GetConnectorsRequest.ProtoReflect.Descriptor instead.
func (*GetConnectorsRequest) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_connector_proto_rawDescGZIP(), []int{8}
}</span>

type GetConnectorsResponse struct {
        state         protoimpl.MessageState
        sizeCache     protoimpl.SizeCache
        unknownFields protoimpl.UnknownFields

        ConnectorNames []string `protobuf:"bytes,1,rep,name=connector_names,json=connectorNames,proto3" json:"connector_names,omitempty"`
}

func (x *GetConnectorsResponse) Reset() <span class="cov0" title="0">{
        *x = GetConnectorsResponse{}
        if protoimpl.UnsafeEnabled </span><span class="cov0" title="0">{
                mi := &amp;file_connector_proto_msgTypes[9]
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                ms.StoreMessageInfo(mi)
        }</span>
}

func (x *GetConnectorsResponse) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*GetConnectorsResponse) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *GetConnectorsResponse) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_connector_proto_msgTypes[9]
        if protoimpl.UnsafeEnabled &amp;&amp; x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use GetConnectorsResponse.ProtoReflect.Descriptor instead.
func (*GetConnectorsResponse) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_connector_proto_rawDescGZIP(), []int{9}
}</span>

func (x *GetConnectorsResponse) GetConnectorNames() []string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.ConnectorNames
        }</span>
        <span class="cov0" title="0">return nil</span>
}

type AddConnectorRequest struct {
        state         protoimpl.MessageState
        sizeCache     protoimpl.SizeCache
        unknownFields protoimpl.UnknownFields

        Name   string           `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
        Config *ConnectorConfig `protobuf:"bytes,2,opt,name=config,proto3" json:"config,omitempty"`
}

func (x *AddConnectorRequest) Reset() <span class="cov0" title="0">{
        *x = AddConnectorRequest{}
        if protoimpl.UnsafeEnabled </span><span class="cov0" title="0">{
                mi := &amp;file_connector_proto_msgTypes[10]
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                ms.StoreMessageInfo(mi)
        }</span>
}

func (x *AddConnectorRequest) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*AddConnectorRequest) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *AddConnectorRequest) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_connector_proto_msgTypes[10]
        if protoimpl.UnsafeEnabled &amp;&amp; x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use AddConnectorRequest.ProtoReflect.Descriptor instead.
func (*AddConnectorRequest) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_connector_proto_rawDescGZIP(), []int{10}
}</span>

func (x *AddConnectorRequest) GetName() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Name
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *AddConnectorRequest) GetConfig() *ConnectorConfig <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Config
        }</span>
        <span class="cov0" title="0">return nil</span>
}

type ConnectorConfig struct {
        state         protoimpl.MessageState
        sizeCache     protoimpl.SizeCache
        unknownFields protoimpl.UnknownFields

        Type     string            `protobuf:"bytes,1,opt,name=type,proto3" json:"type,omitempty"`
        Host     string            `protobuf:"bytes,2,opt,name=host,proto3" json:"host,omitempty"`
        Port     int32             `protobuf:"varint,3,opt,name=port,proto3" json:"port,omitempty"`
        Username string            `protobuf:"bytes,4,opt,name=username,proto3" json:"username,omitempty"`
        Password string            `protobuf:"bytes,5,opt,name=password,proto3" json:"password,omitempty"`
        Database string            `protobuf:"bytes,6,opt,name=database,proto3" json:"database,omitempty"`
        Options  map[string]string `protobuf:"bytes,7,rep,name=options,proto3" json:"options,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
}

func (x *ConnectorConfig) Reset() <span class="cov0" title="0">{
        *x = ConnectorConfig{}
        if protoimpl.UnsafeEnabled </span><span class="cov0" title="0">{
                mi := &amp;file_connector_proto_msgTypes[11]
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                ms.StoreMessageInfo(mi)
        }</span>
}

func (x *ConnectorConfig) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*ConnectorConfig) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *ConnectorConfig) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_connector_proto_msgTypes[11]
        if protoimpl.UnsafeEnabled &amp;&amp; x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use ConnectorConfig.ProtoReflect.Descriptor instead.
func (*ConnectorConfig) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_connector_proto_rawDescGZIP(), []int{11}
}</span>

func (x *ConnectorConfig) GetType() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Type
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *ConnectorConfig) GetHost() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Host
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *ConnectorConfig) GetPort() int32 <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Port
        }</span>
        <span class="cov0" title="0">return 0</span>
}

func (x *ConnectorConfig) GetUsername() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Username
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *ConnectorConfig) GetPassword() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Password
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *ConnectorConfig) GetDatabase() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Database
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *ConnectorConfig) GetOptions() map[string]string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Options
        }</span>
        <span class="cov0" title="0">return nil</span>
}

type AddConnectorResponse struct {
        state         protoimpl.MessageState
        sizeCache     protoimpl.SizeCache
        unknownFields protoimpl.UnknownFields

        Success bool   `protobuf:"varint,1,opt,name=success,proto3" json:"success,omitempty"`
        Error   string `protobuf:"bytes,2,opt,name=error,proto3" json:"error,omitempty"`
}

func (x *AddConnectorResponse) Reset() <span class="cov0" title="0">{
        *x = AddConnectorResponse{}
        if protoimpl.UnsafeEnabled </span><span class="cov0" title="0">{
                mi := &amp;file_connector_proto_msgTypes[12]
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                ms.StoreMessageInfo(mi)
        }</span>
}

func (x *AddConnectorResponse) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*AddConnectorResponse) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *AddConnectorResponse) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_connector_proto_msgTypes[12]
        if protoimpl.UnsafeEnabled &amp;&amp; x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use AddConnectorResponse.ProtoReflect.Descriptor instead.
func (*AddConnectorResponse) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_connector_proto_rawDescGZIP(), []int{12}
}</span>

func (x *AddConnectorResponse) GetSuccess() bool <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Success
        }</span>
        <span class="cov0" title="0">return false</span>
}

func (x *AddConnectorResponse) GetError() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Error
        }</span>
        <span class="cov0" title="0">return ""</span>
}

type RemoveConnectorRequest struct {
        state         protoimpl.MessageState
        sizeCache     protoimpl.SizeCache
        unknownFields protoimpl.UnknownFields

        Name string `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
}

func (x *RemoveConnectorRequest) Reset() <span class="cov0" title="0">{
        *x = RemoveConnectorRequest{}
        if protoimpl.UnsafeEnabled </span><span class="cov0" title="0">{
                mi := &amp;file_connector_proto_msgTypes[13]
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                ms.StoreMessageInfo(mi)
        }</span>
}

func (x *RemoveConnectorRequest) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*RemoveConnectorRequest) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *RemoveConnectorRequest) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_connector_proto_msgTypes[13]
        if protoimpl.UnsafeEnabled &amp;&amp; x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use RemoveConnectorRequest.ProtoReflect.Descriptor instead.
func (*RemoveConnectorRequest) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_connector_proto_rawDescGZIP(), []int{13}
}</span>

func (x *RemoveConnectorRequest) GetName() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Name
        }</span>
        <span class="cov0" title="0">return ""</span>
}

type RemoveConnectorResponse struct {
        state         protoimpl.MessageState
        sizeCache     protoimpl.SizeCache
        unknownFields protoimpl.UnknownFields

        Success bool   `protobuf:"varint,1,opt,name=success,proto3" json:"success,omitempty"`
        Error   string `protobuf:"bytes,2,opt,name=error,proto3" json:"error,omitempty"`
}

func (x *RemoveConnectorResponse) Reset() <span class="cov0" title="0">{
        *x = RemoveConnectorResponse{}
        if protoimpl.UnsafeEnabled </span><span class="cov0" title="0">{
                mi := &amp;file_connector_proto_msgTypes[14]
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                ms.StoreMessageInfo(mi)
        }</span>
}

func (x *RemoveConnectorResponse) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*RemoveConnectorResponse) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *RemoveConnectorResponse) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_connector_proto_msgTypes[14]
        if protoimpl.UnsafeEnabled &amp;&amp; x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use RemoveConnectorResponse.ProtoReflect.Descriptor instead.
func (*RemoveConnectorResponse) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_connector_proto_rawDescGZIP(), []int{14}
}</span>

func (x *RemoveConnectorResponse) GetSuccess() bool <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Success
        }</span>
        <span class="cov0" title="0">return false</span>
}

func (x *RemoveConnectorResponse) GetError() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Error
        }</span>
        <span class="cov0" title="0">return ""</span>
}

var File_connector_proto protoreflect.FileDescriptor

var file_connector_proto_rawDesc = []byte{
        0x0a, 0x0f, 0x63, 0x6f, 0x6e, 0x6e, 0x65, 0x63, 0x74, 0x6f, 0x72, 0x2e, 0x70, 0x72, 0x6f, 0x74,
        0x6f, 0x12, 0x0a, 0x64, 0x61, 0x74, 0x61, 0x73, 0x6f, 0x75, 0x72, 0x63, 0x65, 0x22, 0x37, 0x0a,
        0x0e, 0x43, 0x6f, 0x6e, 0x6e, 0x65, 0x63, 0x74, 0x52, 0x65, 0x71, 0x75, 0x65, 0x73, 0x74, 0x12,
        0x25, 0x0a, 0x0e, 0x63, 0x6f, 0x6e, 0x6e, 0x65, 0x63, 0x74, 0x6f, 0x72, 0x5f, 0x6e, 0x61, 0x6d,
        0x65, 0x18, 0x01, 0x20, 0x01, 0x28, 0x09, 0x52, 0x0d, 0x63, 0x6f, 0x6e, 0x6e, 0x65, 0x63, 0x74,
        0x6f, 0x72, 0x4e, 0x61, 0x6d, 0x65, 0x22, 0x41, 0x0a, 0x0f, 0x43, 0x6f, 0x6e, 0x6e, 0x65, 0x63,
        0x74, 0x52, 0x65, 0x73, 0x70, 0x6f, 0x6e, 0x73, 0x65, 0x12, 0x18, 0x0a, 0x07, 0x73, 0x75, 0x63,
        0x63, 0x65, 0x73, 0x73, 0x18, 0x01, 0x20, 0x01, 0x28, 0x08, 0x52, 0x07, 0x73, 0x75, 0x63, 0x63,
        0x65, 0x73, 0x73, 0x12, 0x14, 0x0a, 0x05, 0x65, 0x72, 0x72, 0x6f, 0x72, 0x18, 0x02, 0x20, 0x01,
        0x28, 0x09, 0x52, 0x05, 0x65, 0x72, 0x72, 0x6f, 0x72, 0x22, 0x3a, 0x0a, 0x11, 0x44, 0x69, 0x73,
        0x63, 0x6f, 0x6e, 0x6e, 0x65, 0x63, 0x74, 0x52, 0x65, 0x71, 0x75, 0x65, 0x73, 0x74, 0x12, 0x25,
        0x0a, 0x0e, 0x63, 0x6f, 0x6e, 0x6e, 0x65, 0x63, 0x74, 0x6f, 0x72, 0x5f, 0x6e, 0x61, 0x6d, 0x65,
        0x18, 0x01, 0x20, 0x01, 0x28, 0x09, 0x52, 0x0d, 0x63, 0x6f, 0x6e, 0x6e, 0x65, 0x63, 0x74, 0x6f,
        0x72, 0x4e, 0x61, 0x6d, 0x65, 0x22, 0x44, 0x0a, 0x12, 0x44, 0x69, 0x73, 0x63, 0x6f, 0x6e, 0x6e,
        0x65, 0x63, 0x74, 0x52, 0x65, 0x73, 0x70, 0x6f, 0x6e, 0x73, 0x65, 0x12, 0x18, 0x0a, 0x07, 0x73,
        0x75, 0x63, 0x63, 0x65, 0x73, 0x73, 0x18, 0x01, 0x20, 0x01, 0x28, 0x08, 0x52, 0x07, 0x73, 0x75,
        0x63, 0x63, 0x65, 0x73, 0x73, 0x12, 0x14, 0x0a, 0x05, 0x65, 0x72, 0x72, 0x6f, 0x72, 0x18, 0x02,
        0x20, 0x01, 0x28, 0x09, 0x52, 0x05, 0x65, 0x72, 0x72, 0x6f, 0x72, 0x22, 0x5f, 0x0a, 0x0c, 0x51,
        0x75, 0x65, 0x72, 0x79, 0x52, 0x65, 0x71, 0x75, 0x65, 0x73, 0x74, 0x12, 0x25, 0x0a, 0x0e, 0x63,
        0x6f, 0x6e, 0x6e, 0x65, 0x63, 0x74, 0x6f, 0x72, 0x5f, 0x6e, 0x61, 0x6d, 0x65, 0x18, 0x01, 0x20,
        0x01, 0x28, 0x09, 0x52, 0x0d, 0x63, 0x6f, 0x6e, 0x6e, 0x65, 0x63, 0x74, 0x6f, 0x72, 0x4e, 0x61,
        0x6d, 0x65, 0x12, 0x14, 0x0a, 0x05, 0x71, 0x75, 0x65, 0x72, 0x79, 0x18, 0x02, 0x20, 0x01, 0x28,
        0x09, 0x52, 0x05, 0x71, 0x75, 0x65, 0x72, 0x79, 0x12, 0x12, 0x0a, 0x04, 0x61, 0x72, 0x67, 0x73,
        0x18, 0x03, 0x20, 0x03, 0x28, 0x09, 0x52, 0x04, 0x61, 0x72, 0x67, 0x73, 0x22, 0x39, 0x0a, 0x0d,
        0x51, 0x75, 0x65, 0x72, 0x79, 0x52, 0x65, 0x73, 0x70, 0x6f, 0x6e, 0x73, 0x65, 0x12, 0x12, 0x0a,
        0x04, 0x72, 0x6f, 0x77, 0x73, 0x18, 0x01, 0x20, 0x03, 0x28, 0x0c, 0x52, 0x04, 0x72, 0x6f, 0x77,
        0x73, 0x12, 0x14, 0x0a, 0x05, 0x65, 0x72, 0x72, 0x6f, 0x72, 0x18, 0x02, 0x20, 0x01, 0x28, 0x09,
        0x52, 0x05, 0x65, 0x72, 0x72, 0x6f, 0x72, 0x22, 0x65, 0x0a, 0x0e, 0x43, 0x6f, 0x6d, 0x6d, 0x61,
        0x6e, 0x64, 0x52, 0x65, 0x71, 0x75, 0x65, 0x73, 0x74, 0x12, 0x25, 0x0a, 0x0e, 0x63, 0x6f, 0x6e,
        0x6e, 0x65, 0x63, 0x74, 0x6f, 0x72, 0x5f, 0x6e, 0x61, 0x6d, 0x65, 0x18, 0x01, 0x20, 0x01, 0x28,
        0x09, 0x52, 0x0d, 0x63, 0x6f, 0x6e, 0x6e, 0x65, 0x63, 0x74, 0x6f, 0x72, 0x4e, 0x61, 0x6d, 0x65,
        0x12, 0x18, 0x0a, 0x07, 0x63, 0x6f, 0x6d, 0x6d, 0x61, 0x6e, 0x64, 0x18, 0x02, 0x20, 0x01, 0x28,
        0x09, 0x52, 0x07, 0x63, 0x6f, 0x6d, 0x6d, 0x61, 0x6e, 0x64, 0x12, 0x12, 0x0a, 0x04, 0x61, 0x72,
        0x67, 0x73, 0x18, 0x03, 0x20, 0x03, 0x28, 0x09, 0x52, 0x04, 0x61, 0x72, 0x67, 0x73, 0x22, 0x4c,
        0x0a, 0x0f, 0x43, 0x6f, 0x6d, 0x6d, 0x61, 0x6e, 0x64, 0x52, 0x65, 0x73, 0x70, 0x6f, 0x6e, 0x73,
        0x65, 0x12, 0x23, 0x0a, 0x0d, 0x61, 0x66, 0x66, 0x65, 0x63, 0x74, 0x65, 0x64, 0x5f, 0x72, 0x6f,
        0x77, 0x73, 0x18, 0x01, 0x20, 0x01, 0x28, 0x03, 0x52, 0x0c, 0x61, 0x66, 0x66, 0x65, 0x63, 0x74,
        0x65, 0x64, 0x52, 0x6f, 0x77, 0x73, 0x12, 0x14, 0x0a, 0x05, 0x65, 0x72, 0x72, 0x6f, 0x72, 0x18,
        0x02, 0x20, 0x01, 0x28, 0x09, 0x52, 0x05, 0x65, 0x72, 0x72, 0x6f, 0x72, 0x22, 0x16, 0x0a, 0x14,
        0x47, 0x65, 0x74, 0x43, 0x6f, 0x6e, 0x6e, 0x65, 0x63, 0x74, 0x6f, 0x72, 0x73, 0x52, 0x65, 0x71,
        0x75, 0x65, 0x73, 0x74, 0x22, 0x40, 0x0a, 0x15, 0x47, 0x65, 0x74, 0x43, 0x6f, 0x6e, 0x6e, 0x65,
        0x63, 0x74, 0x6f, 0x72, 0x73, 0x52, 0x65, 0x73, 0x70, 0x6f, 0x6e, 0x73, 0x65, 0x12, 0x27, 0x0a,
        0x0f, 0x63, 0x6f, 0x6e, 0x6e, 0x65, 0x63, 0x74, 0x6f, 0x72, 0x5f, 0x6e, 0x61, 0x6d, 0x65, 0x73,
        0x18, 0x01, 0x20, 0x03, 0x28, 0x09, 0x52, 0x0e, 0x63, 0x6f, 0x6e, 0x6e, 0x65, 0x63, 0x74, 0x6f,
        0x72, 0x4e, 0x61, 0x6d, 0x65, 0x73, 0x22, 0x5e, 0x0a, 0x13, 0x41, 0x64, 0x64, 0x43, 0x6f, 0x6e,
        0x6e, 0x65, 0x63, 0x74, 0x6f, 0x72, 0x52, 0x65, 0x71, 0x75, 0x65, 0x73, 0x74, 0x12, 0x12, 0x0a,
        0x04, 0x6e, 0x61, 0x6d, 0x65, 0x18, 0x01, 0x20, 0x01, 0x28, 0x09, 0x52, 0x04, 0x6e, 0x61, 0x6d,
        0x65, 0x12, 0x33, 0x0a, 0x06, 0x63, 0x6f, 0x6e, 0x66, 0x69, 0x67, 0x18, 0x02, 0x20, 0x01, 0x28,
        0x0b, 0x32, 0x1b, 0x2e, 0x64, 0x61, 0x74, 0x61, 0x73, 0x6f, 0x75, 0x72, 0x63, 0x65, 0x2e, 0x43,
        0x6f, 0x6e, 0x6e, 0x65, 0x63, 0x74, 0x6f, 0x72, 0x43, 0x6f, 0x6e, 0x66, 0x69, 0x67, 0x52, 0x06,
        0x63, 0x6f, 0x6e, 0x66, 0x69, 0x67, 0x22, 0xa1, 0x02, 0x0a, 0x0f, 0x43, 0x6f, 0x6e, 0x6e, 0x65,
        0x63, 0x74, 0x6f, 0x72, 0x43, 0x6f, 0x6e, 0x66, 0x69, 0x67, 0x12, 0x12, 0x0a, 0x04, 0x74, 0x79,
        0x70, 0x65, 0x18, 0x01, 0x20, 0x01, 0x28, 0x09, 0x52, 0x04, 0x74, 0x79, 0x70, 0x65, 0x12, 0x12,
        0x0a, 0x04, 0x68, 0x6f, 0x73, 0x74, 0x18, 0x02, 0x20, 0x01, 0x28, 0x09, 0x52, 0x04, 0x68, 0x6f,
        0x73, 0x74, 0x12, 0x12, 0x0a, 0x04, 0x70, 0x6f, 0x72, 0x74, 0x18, 0x03, 0x20, 0x01, 0x28, 0x05,
        0x52, 0x04, 0x70, 0x6f, 0x72, 0x74, 0x12, 0x1a, 0x0a, 0x08, 0x75, 0x73, 0x65, 0x72, 0x6e, 0x61,
        0x6d, 0x65, 0x18, 0x04, 0x20, 0x01, 0x28, 0x09, 0x52, 0x08, 0x75, 0x73, 0x65, 0x72, 0x6e, 0x61,
        0x6d, 0x65, 0x12, 0x1a, 0x0a, 0x08, 0x70, 0x61, 0x73, 0x73, 0x77, 0x6f, 0x72, 0x64, 0x18, 0x05,
        0x20, 0x01, 0x28, 0x09, 0x52, 0x08, 0x70, 0x61, 0x73, 0x73, 0x77, 0x6f, 0x72, 0x64, 0x12, 0x1a,
        0x0a, 0x08, 0x64, 0x61, 0x74, 0x61, 0x62, 0x61, 0x73, 0x65, 0x18, 0x06, 0x20, 0x01, 0x28, 0x09,
        0x52, 0x08, 0x64, 0x61, 0x74, 0x61, 0x62, 0x61, 0x73, 0x65, 0x12, 0x42, 0x0a, 0x07, 0x6f, 0x70,
        0x74, 0x69, 0x6f, 0x6e, 0x73, 0x18, 0x07, 0x20, 0x03, 0x28, 0x0b, 0x32, 0x28, 0x2e, 0x64, 0x61,
        0x74, 0x61, 0x73, 0x6f, 0x75, 0x72, 0x63, 0x65, 0x2e, 0x43, 0x6f, 0x6e, 0x6e, 0x65, 0x63, 0x74,
        0x6f, 0x72, 0x43, 0x6f, 0x6e, 0x66, 0x69, 0x67, 0x2e, 0x4f, 0x70, 0x74, 0x69, 0x6f, 0x6e, 0x73,
        0x45, 0x6e, 0x74, 0x72, 0x79, 0x52, 0x07, 0x6f, 0x70, 0x74, 0x69, 0x6f, 0x6e, 0x73, 0x1a, 0x3a,
        0x0a, 0x0c, 0x4f, 0x70, 0x74, 0x69, 0x6f, 0x6e, 0x73, 0x45, 0x6e, 0x74, 0x72, 0x79, 0x12, 0x10,
        0x0a, 0x03, 0x6b, 0x65, 0x79, 0x18, 0x01, 0x20, 0x01, 0x28, 0x09, 0x52, 0x03, 0x6b, 0x65, 0x79,
        0x12, 0x14, 0x0a, 0x05, 0x76, 0x61, 0x6c, 0x75, 0x65, 0x18, 0x02, 0x20, 0x01, 0x28, 0x09, 0x52,
        0x05, 0x76, 0x61, 0x6c, 0x75, 0x65, 0x3a, 0x02, 0x38, 0x01, 0x22, 0x46, 0x0a, 0x14, 0x41, 0x64,
        0x64, 0x43, 0x6f, 0x6e, 0x6e, 0x65, 0x63, 0x74, 0x6f, 0x72, 0x52, 0x65, 0x73, 0x70, 0x6f, 0x6e,
        0x73, 0x65, 0x12, 0x18, 0x0a, 0x07, 0x73, 0x75, 0x63, 0x63, 0x65, 0x73, 0x73, 0x18, 0x01, 0x20,
        0x01, 0x28, 0x08, 0x52, 0x07, 0x73, 0x75, 0x63, 0x63, 0x65, 0x73, 0x73, 0x12, 0x14, 0x0a, 0x05,
        0x65, 0x72, 0x72, 0x6f, 0x72, 0x18, 0x02, 0x20, 0x01, 0x28, 0x09, 0x52, 0x05, 0x65, 0x72, 0x72,
        0x6f, 0x72, 0x22, 0x2c, 0x0a, 0x16, 0x52, 0x65, 0x6d, 0x6f, 0x76, 0x65, 0x43, 0x6f, 0x6e, 0x6e,
        0x65, 0x63, 0x74, 0x6f, 0x72, 0x52, 0x65, 0x71, 0x75, 0x65, 0x73, 0x74, 0x12, 0x12, 0x0a, 0x04,
        0x6e, 0x61, 0x6d, 0x65, 0x18, 0x01, 0x20, 0x01, 0x28, 0x09, 0x52, 0x04, 0x6e, 0x61, 0x6d, 0x65,
        0x22, 0x49, 0x0a, 0x17, 0x52, 0x65, 0x6d, 0x6f, 0x76, 0x65, 0x43, 0x6f, 0x6e, 0x6e, 0x65, 0x63,
        0x74, 0x6f, 0x72, 0x52, 0x65, 0x73, 0x70, 0x6f, 0x6e, 0x73, 0x65, 0x12, 0x18, 0x0a, 0x07, 0x73,
        0x75, 0x63, 0x63, 0x65, 0x73, 0x73, 0x18, 0x01, 0x20, 0x01, 0x28, 0x08, 0x52, 0x07, 0x73, 0x75,
        0x63, 0x63, 0x65, 0x73, 0x73, 0x12, 0x14, 0x0a, 0x05, 0x65, 0x72, 0x72, 0x6f, 0x72, 0x18, 0x02,
        0x20, 0x01, 0x28, 0x09, 0x52, 0x05, 0x65, 0x72, 0x72, 0x6f, 0x72, 0x32, 0xc7, 0x04, 0x0a, 0x11,
        0x44, 0x61, 0x74, 0x61, 0x53, 0x6f, 0x75, 0x72, 0x63, 0x65, 0x53, 0x65, 0x72, 0x76, 0x69, 0x63,
        0x65, 0x12, 0x44, 0x0a, 0x07, 0x43, 0x6f, 0x6e, 0x6e, 0x65, 0x63, 0x74, 0x12, 0x1a, 0x2e, 0x64,
        0x61, 0x74, 0x61, 0x73, 0x6f, 0x75, 0x72, 0x63, 0x65, 0x2e, 0x43, 0x6f, 0x6e, 0x6e, 0x65, 0x63,
        0x74, 0x52, 0x65, 0x71, 0x75, 0x65, 0x73, 0x74, 0x1a, 0x1b, 0x2e, 0x64, 0x61, 0x74, 0x61, 0x73,
        0x6f, 0x75, 0x72, 0x63, 0x65, 0x2e, 0x43, 0x6f, 0x6e, 0x6e, 0x65, 0x63, 0x74, 0x52, 0x65, 0x73,
        0x70, 0x6f, 0x6e, 0x73, 0x65, 0x22, 0x00, 0x12, 0x4d, 0x0a, 0x0a, 0x44, 0x69, 0x73, 0x63, 0x6f,
        0x6e, 0x6e, 0x65, 0x63, 0x74, 0x12, 0x1d, 0x2e, 0x64, 0x61, 0x74, 0x61, 0x73, 0x6f, 0x75, 0x72,
        0x63, 0x65, 0x2e, 0x44, 0x69, 0x73, 0x63, 0x6f, 0x6e, 0x6e, 0x65, 0x63, 0x74, 0x52, 0x65, 0x71,
        0x75, 0x65, 0x73, 0x74, 0x1a, 0x1e, 0x2e, 0x64, 0x61, 0x74, 0x61, 0x73, 0x6f, 0x75, 0x72, 0x63,
        0x65, 0x2e, 0x44, 0x69, 0x73, 0x63, 0x6f, 0x6e, 0x6e, 0x65, 0x63, 0x74, 0x52, 0x65, 0x73, 0x70,
        0x6f, 0x6e, 0x73, 0x65, 0x22, 0x00, 0x12, 0x45, 0x0a, 0x0c, 0x45, 0x78, 0x65, 0x63, 0x75, 0x74,
        0x65, 0x51, 0x75, 0x65, 0x72, 0x79, 0x12, 0x18, 0x2e, 0x64, 0x61, 0x74, 0x61, 0x73, 0x6f, 0x75,
        0x72, 0x63, 0x65, 0x2e, 0x51, 0x75, 0x65, 0x72, 0x79, 0x52, 0x65, 0x71, 0x75, 0x65, 0x73, 0x74,
        0x1a, 0x19, 0x2e, 0x64, 0x61, 0x74, 0x61, 0x73, 0x6f, 0x75, 0x72, 0x63, 0x65, 0x2e, 0x51, 0x75,
        0x65, 0x72, 0x79, 0x52, 0x65, 0x73, 0x70, 0x6f, 0x6e, 0x73, 0x65, 0x22, 0x00, 0x12, 0x4b, 0x0a,
        0x0e, 0x45, 0x78, 0x65, 0x63, 0x75, 0x74, 0x65, 0x43, 0x6f, 0x6d, 0x6d, 0x61, 0x6e, 0x64, 0x12,
        0x1a, 0x2e, 0x64, 0x61, 0x74, 0x61, 0x73, 0x6f, 0x75, 0x72, 0x63, 0x65, 0x2e, 0x43, 0x6f, 0x6d,
        0x6d, 0x61, 0x6e, 0x64, 0x52, 0x65, 0x71, 0x75, 0x65, 0x73, 0x74, 0x1a, 0x1b, 0x2e, 0x64, 0x61,
        0x74, 0x61, 0x73, 0x6f, 0x75, 0x72, 0x63, 0x65, 0x2e, 0x43, 0x6f, 0x6d, 0x6d, 0x61, 0x6e, 0x64,
        0x52, 0x65, 0x73, 0x70, 0x6f, 0x6e, 0x73, 0x65, 0x22, 0x00, 0x12, 0x56, 0x0a, 0x0d, 0x47, 0x65,
        0x74, 0x43, 0x6f, 0x6e, 0x6e, 0x65, 0x63, 0x74, 0x6f, 0x72, 0x73, 0x12, 0x20, 0x2e, 0x64, 0x61,
        0x74, 0x61, 0x73, 0x6f, 0x75, 0x72, 0x63, 0x65, 0x2e, 0x47, 0x65, 0x74, 0x43, 0x6f, 0x6e, 0x6e,
        0x65, 0x63, 0x74, 0x6f, 0x72, 0x73, 0x52, 0x65, 0x71, 0x75, 0x65, 0x73, 0x74, 0x1a, 0x21, 0x2e,
        0x64, 0x61, 0x74, 0x61, 0x73, 0x6f, 0x75, 0x72, 0x63, 0x65, 0x2e, 0x47, 0x65, 0x74, 0x43, 0x6f,
        0x6e, 0x6e, 0x65, 0x63, 0x74, 0x6f, 0x72, 0x73, 0x52, 0x65, 0x73, 0x70, 0x6f, 0x6e, 0x73, 0x65,
        0x22, 0x00, 0x12, 0x53, 0x0a, 0x0c, 0x41, 0x64, 0x64, 0x43, 0x6f, 0x6e, 0x6e, 0x65, 0x63, 0x74,
        0x6f, 0x72, 0x12, 0x1f, 0x2e, 0x64, 0x61, 0x74, 0x61, 0x73, 0x6f, 0x75, 0x72, 0x63, 0x65, 0x2e,
        0x41, 0x64, 0x64, 0x43, 0x6f, 0x6e, 0x6e, 0x65, 0x63, 0x74, 0x6f, 0x72, 0x52, 0x65, 0x71, 0x75,
        0x65, 0x73, 0x74, 0x1a, 0x20, 0x2e, 0x64, 0x61, 0x74, 0x61, 0x73, 0x6f, 0x75, 0x72, 0x63, 0x65,
        0x2e, 0x41, 0x64, 0x64, 0x43, 0x6f, 0x6e, 0x6e, 0x65, 0x63, 0x74, 0x6f, 0x72, 0x52, 0x65, 0x73,
        0x70, 0x6f, 0x6e, 0x73, 0x65, 0x22, 0x00, 0x12, 0x5c, 0x0a, 0x0f, 0x52, 0x65, 0x6d, 0x6f, 0x76,
        0x65, 0x43, 0x6f, 0x6e, 0x6e, 0x65, 0x63, 0x74, 0x6f, 0x72, 0x12, 0x22, 0x2e, 0x64, 0x61, 0x74,
        0x61, 0x73, 0x6f, 0x75, 0x72, 0x63, 0x65, 0x2e, 0x52, 0x65, 0x6d, 0x6f, 0x76, 0x65, 0x43, 0x6f,
        0x6e, 0x6e, 0x65, 0x63, 0x74, 0x6f, 0x72, 0x52, 0x65, 0x71, 0x75, 0x65, 0x73, 0x74, 0x1a, 0x23,
        0x2e, 0x64, 0x61, 0x74, 0x61, 0x73, 0x6f, 0x75, 0x72, 0x63, 0x65, 0x2e, 0x52, 0x65, 0x6d, 0x6f,
        0x76, 0x65, 0x43, 0x6f, 0x6e, 0x6e, 0x65, 0x63, 0x74, 0x6f, 0x72, 0x52, 0x65, 0x73, 0x70, 0x6f,
        0x6e, 0x73, 0x65, 0x22, 0x00, 0x42, 0x11, 0x5a, 0x0f, 0x64, 0x61, 0x74, 0x61, 0x73, 0x6f, 0x75,
        0x72, 0x63, 0x65, 0x2f, 0x67, 0x72, 0x70, 0x63, 0x62, 0x06, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x33,
}

var (
        file_connector_proto_rawDescOnce sync.Once
        file_connector_proto_rawDescData = file_connector_proto_rawDesc
)

func file_connector_proto_rawDescGZIP() []byte <span class="cov0" title="0">{
        file_connector_proto_rawDescOnce.Do(func() </span><span class="cov0" title="0">{
                file_connector_proto_rawDescData = protoimpl.X.CompressGZIP(file_connector_proto_rawDescData)
        }</span>)
        <span class="cov0" title="0">return file_connector_proto_rawDescData</span>
}

var file_connector_proto_msgTypes = make([]protoimpl.MessageInfo, 16)
var file_connector_proto_goTypes = []any{
        (*ConnectRequest)(nil),          // 0: datasource.ConnectRequest
        (*ConnectResponse)(nil),         // 1: datasource.ConnectResponse
        (*DisconnectRequest)(nil),       // 2: datasource.DisconnectRequest
        (*DisconnectResponse)(nil),      // 3: datasource.DisconnectResponse
        (*QueryRequest)(nil),            // 4: datasource.QueryRequest
        (*QueryResponse)(nil),           // 5: datasource.QueryResponse
        (*CommandRequest)(nil),          // 6: datasource.CommandRequest
        (*CommandResponse)(nil),         // 7: datasource.CommandResponse
        (*GetConnectorsRequest)(nil),    // 8: datasource.GetConnectorsRequest
        (*GetConnectorsResponse)(nil),   // 9: datasource.GetConnectorsResponse
        (*AddConnectorRequest)(nil),     // 10: datasource.AddConnectorRequest
        (*ConnectorConfig)(nil),         // 11: datasource.ConnectorConfig
        (*AddConnectorResponse)(nil),    // 12: datasource.AddConnectorResponse
        (*RemoveConnectorRequest)(nil),  // 13: datasource.RemoveConnectorRequest
        (*RemoveConnectorResponse)(nil), // 14: datasource.RemoveConnectorResponse
        nil,                             // 15: datasource.ConnectorConfig.OptionsEntry
}
var file_connector_proto_depIdxs = []int32{
        11, // 0: datasource.AddConnectorRequest.config:type_name -&gt; datasource.ConnectorConfig
        15, // 1: datasource.ConnectorConfig.options:type_name -&gt; datasource.ConnectorConfig.OptionsEntry
        0,  // 2: datasource.DataSourceService.Connect:input_type -&gt; datasource.ConnectRequest
        2,  // 3: datasource.DataSourceService.Disconnect:input_type -&gt; datasource.DisconnectRequest
        4,  // 4: datasource.DataSourceService.ExecuteQuery:input_type -&gt; datasource.QueryRequest
        6,  // 5: datasource.DataSourceService.ExecuteCommand:input_type -&gt; datasource.CommandRequest
        8,  // 6: datasource.DataSourceService.GetConnectors:input_type -&gt; datasource.GetConnectorsRequest
        10, // 7: datasource.DataSourceService.AddConnector:input_type -&gt; datasource.AddConnectorRequest
        13, // 8: datasource.DataSourceService.RemoveConnector:input_type -&gt; datasource.RemoveConnectorRequest
        1,  // 9: datasource.DataSourceService.Connect:output_type -&gt; datasource.ConnectResponse
        3,  // 10: datasource.DataSourceService.Disconnect:output_type -&gt; datasource.DisconnectResponse
        5,  // 11: datasource.DataSourceService.ExecuteQuery:output_type -&gt; datasource.QueryResponse
        7,  // 12: datasource.DataSourceService.ExecuteCommand:output_type -&gt; datasource.CommandResponse
        9,  // 13: datasource.DataSourceService.GetConnectors:output_type -&gt; datasource.GetConnectorsResponse
        12, // 14: datasource.DataSourceService.AddConnector:output_type -&gt; datasource.AddConnectorResponse
        14, // 15: datasource.DataSourceService.RemoveConnector:output_type -&gt; datasource.RemoveConnectorResponse
        9,  // [9:16] is the sub-list for method output_type
        2,  // [2:9] is the sub-list for method input_type
        2,  // [2:2] is the sub-list for extension type_name
        2,  // [2:2] is the sub-list for extension extendee
        0,  // [0:2] is the sub-list for field type_name
}

func init() <span class="cov0" title="0">{ file_connector_proto_init() }</span>
func file_connector_proto_init() <span class="cov0" title="0">{
        if File_connector_proto != nil </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov0" title="0">if !protoimpl.UnsafeEnabled </span><span class="cov0" title="0">{
                file_connector_proto_msgTypes[0].Exporter = func(v any, i int) any </span><span class="cov0" title="0">{
                        switch v := v.(*ConnectRequest); i </span>{
                        case 0:<span class="cov0" title="0">
                                return &amp;v.state</span>
                        case 1:<span class="cov0" title="0">
                                return &amp;v.sizeCache</span>
                        case 2:<span class="cov0" title="0">
                                return &amp;v.unknownFields</span>
                        default:<span class="cov0" title="0">
                                return nil</span>
                        }
                }
                <span class="cov0" title="0">file_connector_proto_msgTypes[1].Exporter = func(v any, i int) any </span><span class="cov0" title="0">{
                        switch v := v.(*ConnectResponse); i </span>{
                        case 0:<span class="cov0" title="0">
                                return &amp;v.state</span>
                        case 1:<span class="cov0" title="0">
                                return &amp;v.sizeCache</span>
                        case 2:<span class="cov0" title="0">
                                return &amp;v.unknownFields</span>
                        default:<span class="cov0" title="0">
                                return nil</span>
                        }
                }
                <span class="cov0" title="0">file_connector_proto_msgTypes[2].Exporter = func(v any, i int) any </span><span class="cov0" title="0">{
                        switch v := v.(*DisconnectRequest); i </span>{
                        case 0:<span class="cov0" title="0">
                                return &amp;v.state</span>
                        case 1:<span class="cov0" title="0">
                                return &amp;v.sizeCache</span>
                        case 2:<span class="cov0" title="0">
                                return &amp;v.unknownFields</span>
                        default:<span class="cov0" title="0">
                                return nil</span>
                        }
                }
                <span class="cov0" title="0">file_connector_proto_msgTypes[3].Exporter = func(v any, i int) any </span><span class="cov0" title="0">{
                        switch v := v.(*DisconnectResponse); i </span>{
                        case 0:<span class="cov0" title="0">
                                return &amp;v.state</span>
                        case 1:<span class="cov0" title="0">
                                return &amp;v.sizeCache</span>
                        case 2:<span class="cov0" title="0">
                                return &amp;v.unknownFields</span>
                        default:<span class="cov0" title="0">
                                return nil</span>
                        }
                }
                <span class="cov0" title="0">file_connector_proto_msgTypes[4].Exporter = func(v any, i int) any </span><span class="cov0" title="0">{
                        switch v := v.(*QueryRequest); i </span>{
                        case 0:<span class="cov0" title="0">
                                return &amp;v.state</span>
                        case 1:<span class="cov0" title="0">
                                return &amp;v.sizeCache</span>
                        case 2:<span class="cov0" title="0">
                                return &amp;v.unknownFields</span>
                        default:<span class="cov0" title="0">
                                return nil</span>
                        }
                }
                <span class="cov0" title="0">file_connector_proto_msgTypes[5].Exporter = func(v any, i int) any </span><span class="cov0" title="0">{
                        switch v := v.(*QueryResponse); i </span>{
                        case 0:<span class="cov0" title="0">
                                return &amp;v.state</span>
                        case 1:<span class="cov0" title="0">
                                return &amp;v.sizeCache</span>
                        case 2:<span class="cov0" title="0">
                                return &amp;v.unknownFields</span>
                        default:<span class="cov0" title="0">
                                return nil</span>
                        }
                }
                <span class="cov0" title="0">file_connector_proto_msgTypes[6].Exporter = func(v any, i int) any </span><span class="cov0" title="0">{
                        switch v := v.(*CommandRequest); i </span>{
                        case 0:<span class="cov0" title="0">
                                return &amp;v.state</span>
                        case 1:<span class="cov0" title="0">
                                return &amp;v.sizeCache</span>
                        case 2:<span class="cov0" title="0">
                                return &amp;v.unknownFields</span>
                        default:<span class="cov0" title="0">
                                return nil</span>
                        }
                }
                <span class="cov0" title="0">file_connector_proto_msgTypes[7].Exporter = func(v any, i int) any </span><span class="cov0" title="0">{
                        switch v := v.(*CommandResponse); i </span>{
                        case 0:<span class="cov0" title="0">
                                return &amp;v.state</span>
                        case 1:<span class="cov0" title="0">
                                return &amp;v.sizeCache</span>
                        case 2:<span class="cov0" title="0">
                                return &amp;v.unknownFields</span>
                        default:<span class="cov0" title="0">
                                return nil</span>
                        }
                }
                <span class="cov0" title="0">file_connector_proto_msgTypes[8].Exporter = func(v any, i int) any </span><span class="cov0" title="0">{
                        switch v := v.(*GetConnectorsRequest); i </span>{
                        case 0:<span class="cov0" title="0">
                                return &amp;v.state</span>
                        case 1:<span class="cov0" title="0">
                                return &amp;v.sizeCache</span>
                        case 2:<span class="cov0" title="0">
                                return &amp;v.unknownFields</span>
                        default:<span class="cov0" title="0">
                                return nil</span>
                        }
                }
                <span class="cov0" title="0">file_connector_proto_msgTypes[9].Exporter = func(v any, i int) any </span><span class="cov0" title="0">{
                        switch v := v.(*GetConnectorsResponse); i </span>{
                        case 0:<span class="cov0" title="0">
                                return &amp;v.state</span>
                        case 1:<span class="cov0" title="0">
                                return &amp;v.sizeCache</span>
                        case 2:<span class="cov0" title="0">
                                return &amp;v.unknownFields</span>
                        default:<span class="cov0" title="0">
                                return nil</span>
                        }
                }
                <span class="cov0" title="0">file_connector_proto_msgTypes[10].Exporter = func(v any, i int) any </span><span class="cov0" title="0">{
                        switch v := v.(*AddConnectorRequest); i </span>{
                        case 0:<span class="cov0" title="0">
                                return &amp;v.state</span>
                        case 1:<span class="cov0" title="0">
                                return &amp;v.sizeCache</span>
                        case 2:<span class="cov0" title="0">
                                return &amp;v.unknownFields</span>
                        default:<span class="cov0" title="0">
                                return nil</span>
                        }
                }
                <span class="cov0" title="0">file_connector_proto_msgTypes[11].Exporter = func(v any, i int) any </span><span class="cov0" title="0">{
                        switch v := v.(*ConnectorConfig); i </span>{
                        case 0:<span class="cov0" title="0">
                                return &amp;v.state</span>
                        case 1:<span class="cov0" title="0">
                                return &amp;v.sizeCache</span>
                        case 2:<span class="cov0" title="0">
                                return &amp;v.unknownFields</span>
                        default:<span class="cov0" title="0">
                                return nil</span>
                        }
                }
                <span class="cov0" title="0">file_connector_proto_msgTypes[12].Exporter = func(v any, i int) any </span><span class="cov0" title="0">{
                        switch v := v.(*AddConnectorResponse); i </span>{
                        case 0:<span class="cov0" title="0">
                                return &amp;v.state</span>
                        case 1:<span class="cov0" title="0">
                                return &amp;v.sizeCache</span>
                        case 2:<span class="cov0" title="0">
                                return &amp;v.unknownFields</span>
                        default:<span class="cov0" title="0">
                                return nil</span>
                        }
                }
                <span class="cov0" title="0">file_connector_proto_msgTypes[13].Exporter = func(v any, i int) any </span><span class="cov0" title="0">{
                        switch v := v.(*RemoveConnectorRequest); i </span>{
                        case 0:<span class="cov0" title="0">
                                return &amp;v.state</span>
                        case 1:<span class="cov0" title="0">
                                return &amp;v.sizeCache</span>
                        case 2:<span class="cov0" title="0">
                                return &amp;v.unknownFields</span>
                        default:<span class="cov0" title="0">
                                return nil</span>
                        }
                }
                <span class="cov0" title="0">file_connector_proto_msgTypes[14].Exporter = func(v any, i int) any </span><span class="cov0" title="0">{
                        switch v := v.(*RemoveConnectorResponse); i </span>{
                        case 0:<span class="cov0" title="0">
                                return &amp;v.state</span>
                        case 1:<span class="cov0" title="0">
                                return &amp;v.sizeCache</span>
                        case 2:<span class="cov0" title="0">
                                return &amp;v.unknownFields</span>
                        default:<span class="cov0" title="0">
                                return nil</span>
                        }
                }
        }
        <span class="cov0" title="0">type x struct{}
        out := protoimpl.TypeBuilder{
                File: protoimpl.DescBuilder{
                        GoPackagePath: reflect.TypeOf(x{}).PkgPath(),
                        RawDescriptor: file_connector_proto_rawDesc,
                        NumEnums:      0,
                        NumMessages:   16,
                        NumExtensions: 0,
                        NumServices:   1,
                },
                GoTypes:           file_connector_proto_goTypes,
                DependencyIndexes: file_connector_proto_depIdxs,
                MessageInfos:      file_connector_proto_msgTypes,
        }.Build()
        File_connector_proto = out.File
        file_connector_proto_rawDesc = nil
        file_connector_proto_goTypes = nil
        file_connector_proto_depIdxs = nil</span>
}
</pre>
		
		<pre class="file" id="file77" style="display: none">// Code generated by protoc-gen-go-grpc. DO NOT EDIT.
// versions:
// - protoc-gen-go-grpc v1.4.0
// - protoc             v3.21.12
// source: connector.proto

package grpc

import (
        context "context"

        grpc "google.golang.org/grpc"
        codes "google.golang.org/grpc/codes"
        status "google.golang.org/grpc/status"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
// Requires gRPC-Go v1.62.0 or later.
const _ = grpc.SupportPackageIsVersion8

const (
        DataSourceService_Connect_FullMethodName         = "/datasource.DataSourceService/Connect"
        DataSourceService_Disconnect_FullMethodName      = "/datasource.DataSourceService/Disconnect"
        DataSourceService_ExecuteQuery_FullMethodName    = "/datasource.DataSourceService/ExecuteQuery"
        DataSourceService_ExecuteCommand_FullMethodName  = "/datasource.DataSourceService/ExecuteCommand"
        DataSourceService_GetConnectors_FullMethodName   = "/datasource.DataSourceService/GetConnectors"
        DataSourceService_AddConnector_FullMethodName    = "/datasource.DataSourceService/AddConnector"
        DataSourceService_RemoveConnector_FullMethodName = "/datasource.DataSourceService/RemoveConnector"
)

// DataSourceServiceClient is the client API for DataSourceService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type DataSourceServiceClient interface {
        Connect(ctx context.Context, in *ConnectRequest, opts ...grpc.CallOption) (*ConnectResponse, error)
        Disconnect(ctx context.Context, in *DisconnectRequest, opts ...grpc.CallOption) (*DisconnectResponse, error)
        ExecuteQuery(ctx context.Context, in *QueryRequest, opts ...grpc.CallOption) (*QueryResponse, error)
        ExecuteCommand(ctx context.Context, in *CommandRequest, opts ...grpc.CallOption) (*CommandResponse, error)
        GetConnectors(ctx context.Context, in *GetConnectorsRequest, opts ...grpc.CallOption) (*GetConnectorsResponse, error)
        AddConnector(ctx context.Context, in *AddConnectorRequest, opts ...grpc.CallOption) (*AddConnectorResponse, error)
        RemoveConnector(ctx context.Context, in *RemoveConnectorRequest, opts ...grpc.CallOption) (*RemoveConnectorResponse, error)
}

type dataSourceServiceClient struct {
        cc grpc.ClientConnInterface
}

func NewDataSourceServiceClient(cc grpc.ClientConnInterface) DataSourceServiceClient <span class="cov0" title="0">{
        return &amp;dataSourceServiceClient{cc}
}</span>

func (c *dataSourceServiceClient) Connect(ctx context.Context, in *ConnectRequest, opts ...grpc.CallOption) (*ConnectResponse, error) <span class="cov0" title="0">{
        cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
        out := new(ConnectResponse)
        err := c.cc.Invoke(ctx, DataSourceService_Connect_FullMethodName, in, out, cOpts...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return out, nil</span>
}

func (c *dataSourceServiceClient) Disconnect(ctx context.Context, in *DisconnectRequest, opts ...grpc.CallOption) (*DisconnectResponse, error) <span class="cov0" title="0">{
        cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
        out := new(DisconnectResponse)
        err := c.cc.Invoke(ctx, DataSourceService_Disconnect_FullMethodName, in, out, cOpts...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return out, nil</span>
}

func (c *dataSourceServiceClient) ExecuteQuery(ctx context.Context, in *QueryRequest, opts ...grpc.CallOption) (*QueryResponse, error) <span class="cov0" title="0">{
        cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
        out := new(QueryResponse)
        err := c.cc.Invoke(ctx, DataSourceService_ExecuteQuery_FullMethodName, in, out, cOpts...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return out, nil</span>
}

func (c *dataSourceServiceClient) ExecuteCommand(ctx context.Context, in *CommandRequest, opts ...grpc.CallOption) (*CommandResponse, error) <span class="cov0" title="0">{
        cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
        out := new(CommandResponse)
        err := c.cc.Invoke(ctx, DataSourceService_ExecuteCommand_FullMethodName, in, out, cOpts...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return out, nil</span>
}

func (c *dataSourceServiceClient) GetConnectors(ctx context.Context, in *GetConnectorsRequest, opts ...grpc.CallOption) (*GetConnectorsResponse, error) <span class="cov0" title="0">{
        cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
        out := new(GetConnectorsResponse)
        err := c.cc.Invoke(ctx, DataSourceService_GetConnectors_FullMethodName, in, out, cOpts...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return out, nil</span>
}

func (c *dataSourceServiceClient) AddConnector(ctx context.Context, in *AddConnectorRequest, opts ...grpc.CallOption) (*AddConnectorResponse, error) <span class="cov0" title="0">{
        cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
        out := new(AddConnectorResponse)
        err := c.cc.Invoke(ctx, DataSourceService_AddConnector_FullMethodName, in, out, cOpts...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return out, nil</span>
}

func (c *dataSourceServiceClient) RemoveConnector(ctx context.Context, in *RemoveConnectorRequest, opts ...grpc.CallOption) (*RemoveConnectorResponse, error) <span class="cov0" title="0">{
        cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
        out := new(RemoveConnectorResponse)
        err := c.cc.Invoke(ctx, DataSourceService_RemoveConnector_FullMethodName, in, out, cOpts...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return out, nil</span>
}

// DataSourceServiceServer is the server API for DataSourceService service.
// All implementations must embed UnimplementedDataSourceServiceServer
// for forward compatibility
type DataSourceServiceServer interface {
        Connect(context.Context, *ConnectRequest) (*ConnectResponse, error)
        Disconnect(context.Context, *DisconnectRequest) (*DisconnectResponse, error)
        ExecuteQuery(context.Context, *QueryRequest) (*QueryResponse, error)
        ExecuteCommand(context.Context, *CommandRequest) (*CommandResponse, error)
        GetConnectors(context.Context, *GetConnectorsRequest) (*GetConnectorsResponse, error)
        AddConnector(context.Context, *AddConnectorRequest) (*AddConnectorResponse, error)
        RemoveConnector(context.Context, *RemoveConnectorRequest) (*RemoveConnectorResponse, error)
        mustEmbedUnimplementedDataSourceServiceServer()
}

// UnimplementedDataSourceServiceServer must be embedded to have forward compatible implementations.
type UnimplementedDataSourceServiceServer struct {
}

func (UnimplementedDataSourceServiceServer) Connect(context.Context, *ConnectRequest) (*ConnectResponse, error) <span class="cov0" title="0">{
        return nil, status.Errorf(codes.Unimplemented, "method Connect not implemented")
}</span>
func (UnimplementedDataSourceServiceServer) Disconnect(context.Context, *DisconnectRequest) (*DisconnectResponse, error) <span class="cov0" title="0">{
        return nil, status.Errorf(codes.Unimplemented, "method Disconnect not implemented")
}</span>
func (UnimplementedDataSourceServiceServer) ExecuteQuery(context.Context, *QueryRequest) (*QueryResponse, error) <span class="cov0" title="0">{
        return nil, status.Errorf(codes.Unimplemented, "method ExecuteQuery not implemented")
}</span>
func (UnimplementedDataSourceServiceServer) ExecuteCommand(context.Context, *CommandRequest) (*CommandResponse, error) <span class="cov0" title="0">{
        return nil, status.Errorf(codes.Unimplemented, "method ExecuteCommand not implemented")
}</span>
func (UnimplementedDataSourceServiceServer) GetConnectors(context.Context, *GetConnectorsRequest) (*GetConnectorsResponse, error) <span class="cov0" title="0">{
        return nil, status.Errorf(codes.Unimplemented, "method GetConnectors not implemented")
}</span>
func (UnimplementedDataSourceServiceServer) AddConnector(context.Context, *AddConnectorRequest) (*AddConnectorResponse, error) <span class="cov0" title="0">{
        return nil, status.Errorf(codes.Unimplemented, "method AddConnector not implemented")
}</span>
func (UnimplementedDataSourceServiceServer) RemoveConnector(context.Context, *RemoveConnectorRequest) (*RemoveConnectorResponse, error) <span class="cov0" title="0">{
        return nil, status.Errorf(codes.Unimplemented, "method RemoveConnector not implemented")
}</span>
func (UnimplementedDataSourceServiceServer) mustEmbedUnimplementedDataSourceServiceServer() {<span class="cov0" title="0">}</span>

// UnsafeDataSourceServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to DataSourceServiceServer will
// result in compilation errors.
type UnsafeDataSourceServiceServer interface {
        mustEmbedUnimplementedDataSourceServiceServer()
}

func RegisterDataSourceServiceServer(s grpc.ServiceRegistrar, srv DataSourceServiceServer) <span class="cov0" title="0">{
        s.RegisterService(&amp;DataSourceService_ServiceDesc, srv)
}</span>

func _DataSourceService_Connect_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) <span class="cov0" title="0">{
        in := new(ConnectRequest)
        if err := dec(in); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">if interceptor == nil </span><span class="cov0" title="0">{
                return srv.(DataSourceServiceServer).Connect(ctx, in)
        }</span>
        <span class="cov0" title="0">info := &amp;grpc.UnaryServerInfo{
                Server:     srv,
                FullMethod: DataSourceService_Connect_FullMethodName,
        }
        handler := func(ctx context.Context, req interface{}) (interface{}, error) </span><span class="cov0" title="0">{
                return srv.(DataSourceServiceServer).Connect(ctx, req.(*ConnectRequest))
        }</span>
        <span class="cov0" title="0">return interceptor(ctx, in, info, handler)</span>
}

func _DataSourceService_Disconnect_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) <span class="cov0" title="0">{
        in := new(DisconnectRequest)
        if err := dec(in); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">if interceptor == nil </span><span class="cov0" title="0">{
                return srv.(DataSourceServiceServer).Disconnect(ctx, in)
        }</span>
        <span class="cov0" title="0">info := &amp;grpc.UnaryServerInfo{
                Server:     srv,
                FullMethod: DataSourceService_Disconnect_FullMethodName,
        }
        handler := func(ctx context.Context, req interface{}) (interface{}, error) </span><span class="cov0" title="0">{
                return srv.(DataSourceServiceServer).Disconnect(ctx, req.(*DisconnectRequest))
        }</span>
        <span class="cov0" title="0">return interceptor(ctx, in, info, handler)</span>
}

func _DataSourceService_ExecuteQuery_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) <span class="cov0" title="0">{
        in := new(QueryRequest)
        if err := dec(in); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">if interceptor == nil </span><span class="cov0" title="0">{
                return srv.(DataSourceServiceServer).ExecuteQuery(ctx, in)
        }</span>
        <span class="cov0" title="0">info := &amp;grpc.UnaryServerInfo{
                Server:     srv,
                FullMethod: DataSourceService_ExecuteQuery_FullMethodName,
        }
        handler := func(ctx context.Context, req interface{}) (interface{}, error) </span><span class="cov0" title="0">{
                return srv.(DataSourceServiceServer).ExecuteQuery(ctx, req.(*QueryRequest))
        }</span>
        <span class="cov0" title="0">return interceptor(ctx, in, info, handler)</span>
}

func _DataSourceService_ExecuteCommand_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) <span class="cov0" title="0">{
        in := new(CommandRequest)
        if err := dec(in); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">if interceptor == nil </span><span class="cov0" title="0">{
                return srv.(DataSourceServiceServer).ExecuteCommand(ctx, in)
        }</span>
        <span class="cov0" title="0">info := &amp;grpc.UnaryServerInfo{
                Server:     srv,
                FullMethod: DataSourceService_ExecuteCommand_FullMethodName,
        }
        handler := func(ctx context.Context, req interface{}) (interface{}, error) </span><span class="cov0" title="0">{
                return srv.(DataSourceServiceServer).ExecuteCommand(ctx, req.(*CommandRequest))
        }</span>
        <span class="cov0" title="0">return interceptor(ctx, in, info, handler)</span>
}

func _DataSourceService_GetConnectors_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) <span class="cov0" title="0">{
        in := new(GetConnectorsRequest)
        if err := dec(in); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">if interceptor == nil </span><span class="cov0" title="0">{
                return srv.(DataSourceServiceServer).GetConnectors(ctx, in)
        }</span>
        <span class="cov0" title="0">info := &amp;grpc.UnaryServerInfo{
                Server:     srv,
                FullMethod: DataSourceService_GetConnectors_FullMethodName,
        }
        handler := func(ctx context.Context, req interface{}) (interface{}, error) </span><span class="cov0" title="0">{
                return srv.(DataSourceServiceServer).GetConnectors(ctx, req.(*GetConnectorsRequest))
        }</span>
        <span class="cov0" title="0">return interceptor(ctx, in, info, handler)</span>
}

func _DataSourceService_AddConnector_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) <span class="cov0" title="0">{
        in := new(AddConnectorRequest)
        if err := dec(in); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">if interceptor == nil </span><span class="cov0" title="0">{
                return srv.(DataSourceServiceServer).AddConnector(ctx, in)
        }</span>
        <span class="cov0" title="0">info := &amp;grpc.UnaryServerInfo{
                Server:     srv,
                FullMethod: DataSourceService_AddConnector_FullMethodName,
        }
        handler := func(ctx context.Context, req interface{}) (interface{}, error) </span><span class="cov0" title="0">{
                return srv.(DataSourceServiceServer).AddConnector(ctx, req.(*AddConnectorRequest))
        }</span>
        <span class="cov0" title="0">return interceptor(ctx, in, info, handler)</span>
}

func _DataSourceService_RemoveConnector_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) <span class="cov0" title="0">{
        in := new(RemoveConnectorRequest)
        if err := dec(in); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">if interceptor == nil </span><span class="cov0" title="0">{
                return srv.(DataSourceServiceServer).RemoveConnector(ctx, in)
        }</span>
        <span class="cov0" title="0">info := &amp;grpc.UnaryServerInfo{
                Server:     srv,
                FullMethod: DataSourceService_RemoveConnector_FullMethodName,
        }
        handler := func(ctx context.Context, req interface{}) (interface{}, error) </span><span class="cov0" title="0">{
                return srv.(DataSourceServiceServer).RemoveConnector(ctx, req.(*RemoveConnectorRequest))
        }</span>
        <span class="cov0" title="0">return interceptor(ctx, in, info, handler)</span>
}

// DataSourceService_ServiceDesc is the grpc.ServiceDesc for DataSourceService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var DataSourceService_ServiceDesc = grpc.ServiceDesc{
        ServiceName: "datasource.DataSourceService",
        HandlerType: (*DataSourceServiceServer)(nil),
        Methods: []grpc.MethodDesc{
                {
                        MethodName: "Connect",
                        Handler:    _DataSourceService_Connect_Handler,
                },
                {
                        MethodName: "Disconnect",
                        Handler:    _DataSourceService_Disconnect_Handler,
                },
                {
                        MethodName: "ExecuteQuery",
                        Handler:    _DataSourceService_ExecuteQuery_Handler,
                },
                {
                        MethodName: "ExecuteCommand",
                        Handler:    _DataSourceService_ExecuteCommand_Handler,
                },
                {
                        MethodName: "GetConnectors",
                        Handler:    _DataSourceService_GetConnectors_Handler,
                },
                {
                        MethodName: "AddConnector",
                        Handler:    _DataSourceService_AddConnector_Handler,
                },
                {
                        MethodName: "RemoveConnector",
                        Handler:    _DataSourceService_RemoveConnector_Handler,
                },
        },
        Streams:  []grpc.StreamDesc{},
        Metadata: "connector.proto",
}
</pre>
		
		<pre class="file" id="file78" style="display: none">package processor

import (
        "context"
        "fmt"
        "sort"
        "strings"
        "time"
        pb "visualization/api/proto"

        "datasource/managers/query"
)

// Aggregator handles data aggregation.
type Aggregator struct{}

// NewAggregator creates a new Aggregator instance.
func NewAggregator() *Aggregator <span class="cov0" title="0">{
        return &amp;Aggregator{}
}</span>

// Aggregate performs data aggregation based on dimensions and measures.
func (a *Aggregator) Aggregate(data []map[string]interface{}, dimensions, measures []string) (map[string]interface{}, error) <span class="cov0" title="0">{
        result := make(map[string]interface{})
        dimensionValues := make(map[string][]string)
        aggregatedData := make(map[string]map[string]float64)

        // Collect unique dimension values and initialize aggregated data
        for _, item := range data </span><span class="cov0" title="0">{
                key := a.getDimensionKey(item, dimensions)
                if _, exists := aggregatedData[key]; !exists </span><span class="cov0" title="0">{
                        aggregatedData[key] = make(map[string]float64)
                        for _, measure := range measures </span><span class="cov0" title="0">{
                                aggregatedData[key][measure] = 0
                        }</span>
                }

                <span class="cov0" title="0">for _, dim := range dimensions </span><span class="cov0" title="0">{
                        value := fmt.Sprintf("%v", item[dim])
                        if !contains(dimensionValues[dim], value) </span><span class="cov0" title="0">{
                                dimensionValues[dim] = append(dimensionValues[dim], value)
                        }</span>
                }

                <span class="cov0" title="0">for _, measure := range measures </span><span class="cov0" title="0">{
                        if value, ok := item[measure].(float64); ok </span><span class="cov0" title="0">{
                                aggregatedData[key][measure] += value
                        }</span>
                }
        }

        // Sort dimension values
        <span class="cov0" title="0">for dim, values := range dimensionValues </span><span class="cov0" title="0">{
                sort.Strings(values)
                dimensionValues[dim] = values
        }</span>

        <span class="cov0" title="0">result["dimensions"] = dimensionValues
        result["measures"] = measures
        result["data"] = aggregatedData

        return result, nil</span>
}

// getDimensionKey creates a unique key based on dimension values.
func (a *Aggregator) getDimensionKey(item map[string]interface{}, dimensions []string) string <span class="cov0" title="0">{
        var keyParts []string
        for _, dim := range dimensions </span><span class="cov0" title="0">{
                keyParts = append(keyParts, fmt.Sprintf("%v", item[dim]))
        }</span>
        <span class="cov0" title="0">return strings.Join(keyParts, "|")</span>
}

// contains checks if a string slice contains a specific value.
func contains(slice []string, value string) bool <span class="cov0" title="0">{
        for _, item := range slice </span><span class="cov0" title="0">{
                if item == value </span><span class="cov0" title="0">{
                        return true
                }</span>
        }
        <span class="cov0" title="0">return false</span>
}

type TimeSeriesProcessor struct {
        DataProcessor
}

// ProcessTimeSeriesData processes time series data
func (tp *TimeSeriesProcessor) ProcessTimeSeriesData(ctx context.Context, req *pb.CreateVisualizationRequest, timeDimension string, interval string) (map[string]interface{}, error) <span class="cov0" title="0">{
        results, err := tp.DataProcessor.dataSourceClient.ExecuteQuery(ctx, req.DataSourceId, query.Query{
                Type:       query.Select,
                Collection: req.DataSourceId,
                Fields:     append(req.Dimensions, req.Measures...),
                // Conditions: req.Filters,
                // Limit:      int(req.Limit),
                // Offset:     int(req.Offset),
        })
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to execute query: %w", err)
        }</span>

        <span class="cov0" title="0">return tp.processTimeSeriesResults(results, timeDimension, req.Measures, interval)</span>
}

func (tp *TimeSeriesProcessor) processTimeSeriesResults(results []map[string]interface{}, timeDimension string, measures []string, interval string) (map[string]interface{}, error) <span class="cov0" title="0">{
        output := make(map[string]interface{})
        timeSeriesData := make(map[string]map[string]float64)

        for _, result := range results </span><span class="cov0" title="0">{
                timeValue, ok := result[timeDimension].(string)
                if !ok </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("invalid time value for dimension %s", timeDimension)
                }</span>

                <span class="cov0" title="0">t, err := time.Parse(time.RFC3339, timeValue)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("failed to parse time: %w", err)
                }</span>

                <span class="cov0" title="0">bucketKey := tp.getTimeBucketKey(t, interval)
                if _, exists := timeSeriesData[bucketKey]; !exists </span><span class="cov0" title="0">{
                        timeSeriesData[bucketKey] = make(map[string]float64)
                        for _, measure := range measures </span><span class="cov0" title="0">{
                                timeSeriesData[bucketKey][measure] = 0
                        }</span>
                }

                <span class="cov0" title="0">for _, measure := range measures </span><span class="cov0" title="0">{
                        if value, ok := result[measure].(float64); ok </span><span class="cov0" title="0">{
                                timeSeriesData[bucketKey][measure] += value
                        }</span> else<span class="cov0" title="0"> if value, ok := result[measure].(int64); ok </span><span class="cov0" title="0">{
                                timeSeriesData[bucketKey][measure] += float64(value)
                        }</span>
                }
        }

        <span class="cov0" title="0">output["timeDimension"] = timeDimension
        output["interval"] = interval
        output["measures"] = measures
        output["data"] = timeSeriesData

        return output, nil</span>
}

func (tp *TimeSeriesProcessor) getTimeBucketKey(t time.Time, interval string) string <span class="cov0" title="0">{
        switch interval </span>{
        case "hour":<span class="cov0" title="0">
                return t.Format("2006-01-02 15:00")</span>
        case "day":<span class="cov0" title="0">
                return t.Format("2006-01-02")</span>
        case "week":<span class="cov0" title="0">
                year, week := t.ISOWeek()
                return fmt.Sprintf("%d-W%02d", year, week)</span>
        case "month":<span class="cov0" title="0">
                return t.Format("2006-01")</span>
        case "year":<span class="cov0" title="0">
                return t.Format("2006")</span>
        default:<span class="cov0" title="0">
                return t.Format(time.RFC3339)</span>
        }
}

// Close closes the DataSourceClient connection
func (dp *DataProcessor) Close() error <span class="cov0" title="0">{
        return dp.dataSourceClient.Close()
}</span>
</pre>
		
		<pre class="file" id="file79" style="display: none">package processor

import (
        "context"
        "fmt"
        "sort"

        "datasource/managers/query"
        pb "visualization/api/proto"
        client "visualization/data"
)

// DataProcessor handles the processing of data for visualizations.
type DataProcessor struct {
        dataSourceClient *client.DataSourceClient
}

// NewDataProcessor creates a new DataProcessor instance.
func NewDataProcessor(dataSourceAddress string) (*DataProcessor, error) <span class="cov0" title="0">{
        dsClient, err := client.NewDataSourceClient(dataSourceAddress)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to create DataSource client: %w", err)
        }</span>
        <span class="cov0" title="0">return &amp;DataProcessor{
                dataSourceClient: dsClient,
        }, nil</span>
}

// ProcessData processes the data based on the visualization request.
func (dp *DataProcessor) ProcessData(ctx context.Context, req *pb.CreateVisualizationRequest) (map[string]interface{}, error) <span class="cov0" title="0">{
        // Create a query.Query object
        q := query.Query{
                Type:       query.Select,
                Collection: req.DataSourceId,
                Fields:     append(req.Dimensions, req.Measures...),
                // Conditions: req.Filters,
                // Limit:      int(req.Limit),
                // Offset:     int(req.Offset),
        }

        // Execute the query
        results, err := dp.dataSourceClient.ExecuteQuery(ctx, req.DataSourceId, q)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to execute query: %w", err)
        }</span>

        // Process the results
        <span class="cov0" title="0">processedData, err := dp.processQueryResults(results, req.Dimensions, req.Measures)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to process query results: %w", err)
        }</span>

        <span class="cov0" title="0">return processedData, nil</span>
}

// processQueryResults processes the query results into a format suitable for visualization
func (dp *DataProcessor) processQueryResults(results []map[string]interface{}, dimensions, measures []string) (map[string]interface{}, error) <span class="cov0" title="0">{
        output := make(map[string]interface{})
        dimensionValues := make(map[string]map[string]bool)
        aggregatedData := make(map[string]map[string]float64)

        for _, result := range results </span><span class="cov0" title="0">{
                key := dp.getDimensionKey(result, dimensions)
                if _, exists := aggregatedData[key]; !exists </span><span class="cov0" title="0">{
                        aggregatedData[key] = make(map[string]float64)
                        for _, measure := range measures </span><span class="cov0" title="0">{
                                aggregatedData[key][measure] = 0
                        }</span>
                }

                <span class="cov0" title="0">for _, dim := range dimensions </span><span class="cov0" title="0">{
                        if dimensionValues[dim] == nil </span><span class="cov0" title="0">{
                                dimensionValues[dim] = make(map[string]bool)
                        }</span>
                        <span class="cov0" title="0">dimValue := fmt.Sprintf("%v", result[dim])
                        dimensionValues[dim][dimValue] = true</span>
                }

                <span class="cov0" title="0">for _, measure := range measures </span><span class="cov0" title="0">{
                        if value, ok := result[measure].(float64); ok </span><span class="cov0" title="0">{
                                aggregatedData[key][measure] += value
                        }</span> else<span class="cov0" title="0"> if value, ok := result[measure].(int64); ok </span><span class="cov0" title="0">{
                                aggregatedData[key][measure] += float64(value)
                        }</span>
                }
        }

        // Convert dimension values to sorted slices
        <span class="cov0" title="0">dimensionSlices := make(map[string][]string)
        for dim, valueMap := range dimensionValues </span><span class="cov0" title="0">{
                values := make([]string, 0, len(valueMap))
                for value := range valueMap </span><span class="cov0" title="0">{
                        values = append(values, value)
                }</span>
                <span class="cov0" title="0">sort.Strings(values)
                dimensionSlices[dim] = values</span>
        }

        <span class="cov0" title="0">output["dimensions"] = dimensionSlices
        output["measures"] = measures
        output["data"] = aggregatedData

        return output, nil</span>
}

// getDimensionKey creates a unique key based on dimension values
func (dp *DataProcessor) getDimensionKey(item map[string]interface{}, dimensions []string) string <span class="cov0" title="0">{
        var key string
        for _, dim := range dimensions </span><span class="cov0" title="0">{
                key += fmt.Sprintf("%v|", item[dim])
        }</span>
        <span class="cov0" title="0">return key</span>
}

// TimeSeriesProcessor handles time series data processing
</pre>
		
		<pre class="file" id="file80" style="display: none">package service

import (
        "context"
        "time"

        pb "visualization/api/proto"
        "visualization/internal/processor"
        "visualization/renderers"

        "github.com/google/uuid"
        "go.uber.org/zap"
        "google.golang.org/grpc/codes"
        "google.golang.org/grpc/status"
)

// VisualizationStore defines the interface for storing and retrieving visualizations.
type VisualizationStore interface {
        // Store saves a visualization and returns its ID.
        //
        // Parameters:
        //   - ctx: The context for the operation, which can be used for cancellation or timeout.
        //   - visualization: The visualization to be stored.
        //
        // Returns:
        //   - string: The ID of the stored visualization.
        //   - error: An error if the operation failed, or nil if it succeeded.
        //
        // Example:
        //   id, err := store.Store(ctx, &amp;pb.VisualizationResponse{
        //     VisualizationData: []byte("..."),
        //     Metadata: map[string]string{"type": "bar_chart"},
        //   })
        //   if err != nil {
        //     log.Printf("Failed to store visualization: %v", err)
        //     return
        //   }
        //   log.Printf("Stored visualization with ID: %s", id)
        Store(ctx context.Context, visualization *pb.VisualizationResponse) (string, error)

        // CreateVisualization creates a new visualization based on the provided request.
        //
        // Parameters:
        //   - ctx: The context for the operation, which can be used for cancellation or timeout.
        //   - req: The request containing the data and metadata for the visualization.
        //
        // Returns:
        //   - *pb.VisualizationResponse: The created visualization.
        //   - error: An error if the operation failed, or nil if it succeeded.
        //
        // Example:
        //   viz, err := store.CreateVisualization(ctx, &amp;pb.CreateVisualizationRequest{
        //     DataSourceId: "123e4567-e89b-12d3-a456-426614174000",
        //     Dimensions: []string{"country"},
        //     Measures: []string{"revenue"},
        //     VisualizationType: "bar_chart",
        //   })
        CreateVisualization(ctx context.Context, req *pb.CreateVisualizationRequest) (*pb.VisualizationResponse, error)

        // UpdateVisualization updates an existing visualization.
        //
        // Parameters:
        //   - ctx: The context for the operation, which can be used for cancellation or timeout.
        //   - req: The request containing the ID of the visualization to update and the new data.
        //
        // Returns:
        //   - *pb.VisualizationResponse: The updated visualization.
        //   - error: An error if the operation failed, or nil if it succeeded.
        // Example:
        //   viz, err := store.UpdateVisualization(ctx, &amp;pb.UpdateVisualizationRequest{
        //     VisualizationId: "123e4567-e89b-12d3-a456-426614174000",
        //     UpdateData: &amp;pb.CreateVisualizationRequest{
        //       DataSourceId: "123e4567-e89b-12d3-a456-426614174000",
        //       Dimensions: []string{"country"},
        //       Measures: []string{"revenue"},
        //       VisualizationType: "bar_chart",
        //     },
        //   })
        UpdateVisualization(ctx context.Context, req *pb.UpdateVisualizationRequest) (*pb.VisualizationResponse, error)

        // Get retrieves a visualization by its ID.
        //
        // Parameters:
        //   - ctx: The context for the operation, which can be used for cancellation or timeout.
        //   - id: The ID of the visualization to retrieve.
        //
        // Returns:
        //   - *pb.VisualizationResponse: The retrieved visualization, or nil if not found.
        //   - error: An error if the operation failed, or nil if it succeeded.
        //
        // Example:
        //   viz, err := store.Get(ctx, "123e4567-e89b-12d3-a456-426614174000")
        //   if err != nil {
        //     log.Printf("Failed to retrieve visualization: %v", err)
        //     return
        //   }
        //   if viz == nil {
        //     log.Printf("Visualization not found")
        //   } else {
        //     log.Printf("Retrieved visualization of type: %s", viz.Metadata["type"])
        //   }
        Get(ctx context.Context, id string) (*pb.VisualizationResponse, error)

        // Update updates an existing visualization.
        //
        // Parameters:
        //   - ctx: The context for the operation, which can be used for cancellation or timeout.
        //   - visualization: The updated visualization. The ID field must be set.
        //
        // Returns:
        //   - error: An error if the operation failed, or nil if it succeeded.
        //
        // Example:
        //   err := store.Update(ctx, &amp;pb.VisualizationResponse{
        //     VisualizationId: "123e4567-e89b-12d3-a456-426614174000",
        //     VisualizationData: []byte("..."),
        //     Metadata: map[string]string{"type": "line_chart"},
        //   })
        //   if err != nil {
        //     log.Printf("Failed to update visualization: %v", err)
        //     return
        //   }
        //   log.Printf("Successfully updated visualization")
        Update(ctx context.Context, visualization *pb.VisualizationResponse) error

        // Delete removes a visualization by its ID.
        //
        // Parameters:
        //   - ctx: The context for the operation, which can be used for cancellation or timeout.
        //   - id: The ID of the visualization to delete.
        //
        // Returns:
        //   - error: An error if the operation failed, or nil if it succeeded.
        //
        // Example:
        //   err := store.Delete(ctx, "123e4567-e89b-12d3-a456-426614174000")
        //   if err != nil {
        //     log.Printf("Failed to delete visualization: %v", err)
        //     return
        //   }
        //   log.Printf("Successfully deleted visualization")
        Delete(ctx context.Context, id string) error

        // List retrieves a list of visualizations with pagination.
        //
        // Parameters:
        //   - ctx: The context for the operation, which can be used for cancellation or timeout.
        //   - page: The page number to retrieve (1-based).
        //   - pageSize: The number of items per page.
        //
        // Returns:
        //   - []*pb.VisualizationResponse: A slice of visualizations for the requested page.
        //   - int32: The total count of visualizations (across all pages).
        //   - error: An error if the operation failed, or nil if it succeeded.
        //
        // Example:
        //   vizs, total, err := store.List(ctx, 1, 10)
        //   if err != nil {
        //     log.Printf("Failed to list visualizations: %v", err)
        //     return
        //   }
        //   log.Printf("Retrieved %d visualizations (total: %d)", len(vizs), total)
        //   for _, viz := range vizs {
        //     log.Printf("Visualization ID: %s, Type: %s", viz.VisualizationId, viz.Metadata["type"])
        //   }
        List(ctx context.Context, page, pageSize int32) ([]*pb.VisualizationResponse, int32, error)
}

// VisualizationService implements the VisualizationService gRPC service.
type VisualizationService struct {
        pb.UnimplementedVisualizationServiceServer
        processor          *processor.DataProcessor
        visualizationStore VisualizationStore
        logger             *zap.Logger
}

// NewVisualizationService creates a new VisualizationService with the given dependencies.
func NewVisualizationService(processor *processor.DataProcessor, store VisualizationStore, logger *zap.Logger) *VisualizationService <span class="cov0" title="0">{
        return &amp;VisualizationService{
                processor:          processor,
                visualizationStore: store,
                logger:             logger,
        }
}</span>

// CreateVisualization creates a new visualization based on the provided request.
func (s *VisualizationService) CreateVisualization(ctx context.Context, req *pb.CreateVisualizationRequest) (*pb.VisualizationResponse, error) <span class="cov0" title="0">{
        s.logger.Info("Creating new visualization", zap.String("type", req.VisualizationType))

        processedData, err := s.processor.ProcessData(ctx, req)
        if err != nil </span><span class="cov0" title="0">{
                s.logger.Error("Failed to process data", zap.Error(err))
                return nil, status.Errorf(codes.Internal, "failed to process data: %v", err)
        }</span>

        <span class="cov0" title="0">renderer, err := renderers.RendererFactory(req.VisualizationType)
        if err != nil </span><span class="cov0" title="0">{
                s.logger.Error("Failed to create renderer", zap.Error(err))
                return nil, status.Errorf(codes.InvalidArgument, "failed to create renderer: %v", err)
        }</span>

        <span class="cov0" title="0">visualizationData, err := renderer.Render(processedData)
        if err != nil </span><span class="cov0" title="0">{
                s.logger.Error("Failed to render visualization", zap.Error(err))
                return nil, status.Errorf(codes.Internal, "failed to render visualization: %v", err)
        }</span>

        <span class="cov0" title="0">viz := &amp;pb.VisualizationResponse{
                VisualizationId:   uuid.New().String(),
                VisualizationData: []byte(visualizationData),
                Metadata: map[string]string{
                        "type":       req.VisualizationType,
                        "created_at": time.Now().UTC().Format(time.RFC3339),
                },
        }

        id, err := s.visualizationStore.Store(ctx, viz)
        if err != nil </span><span class="cov0" title="0">{
                s.logger.Error("Failed to store visualization", zap.Error(err))
                return nil, status.Errorf(codes.Internal, "failed to store visualization: %v", err)
        }</span>

        <span class="cov0" title="0">viz.VisualizationId = id
        s.logger.Info("Successfully created visualization", zap.String("id", id))
        return viz, nil</span>
}

// UpdateVisualization updates an existing visualization.
func (s *VisualizationService) UpdateVisualization(ctx context.Context, req *pb.UpdateVisualizationRequest) (*pb.VisualizationResponse, error) <span class="cov0" title="0">{
        s.logger.Info("Updating visualization", zap.String("id", req.VisualizationId))

        existing, err := s.visualizationStore.Get(ctx, req.VisualizationId)
        if err != nil </span><span class="cov0" title="0">{
                s.logger.Error("Failed to retrieve existing visualization", zap.Error(err))
                return nil, status.Errorf(codes.NotFound, "visualization not found: %v", err)
        }</span>

        <span class="cov0" title="0">processedData, err := s.processor.ProcessData(ctx, req.UpdateData)
        if err != nil </span><span class="cov0" title="0">{
                s.logger.Error("Failed to process updated data", zap.Error(err))
                return nil, status.Errorf(codes.Internal, "failed to process updated data: %v", err)
        }</span>

        <span class="cov0" title="0">renderer, err := renderers.RendererFactory(req.UpdateData.VisualizationType)
        if err != nil </span><span class="cov0" title="0">{
                s.logger.Error("Failed to create renderer", zap.Error(err))
                return nil, status.Errorf(codes.InvalidArgument, "failed to create renderer: %v", err)
        }</span>

        <span class="cov0" title="0">visualizationData, err := renderer.Render(processedData)
        if err != nil </span><span class="cov0" title="0">{
                s.logger.Error("Failed to render updated visualization", zap.Error(err))
                return nil, status.Errorf(codes.Internal, "failed to render updated visualization: %v", err)
        }</span>

        <span class="cov0" title="0">existing.VisualizationData = []byte(visualizationData)
        existing.Metadata["type"] = req.UpdateData.VisualizationType
        existing.Metadata["updated_at"] = time.Now().UTC().Format(time.RFC3339)

        err = s.visualizationStore.Update(ctx, existing)
        if err != nil </span><span class="cov0" title="0">{
                s.logger.Error("Failed to store updated visualization", zap.Error(err))
                return nil, status.Errorf(codes.Internal, "failed to update visualization: %v", err)
        }</span>

        <span class="cov0" title="0">s.logger.Info("Successfully updated visualization", zap.String("id", req.VisualizationId))
        return existing, nil</span>
}

// GetVisualization retrieves a specific visualization by its ID.
func (s *VisualizationService) GetVisualization(ctx context.Context, req *pb.GetVisualizationRequest) (*pb.VisualizationResponse, error) <span class="cov0" title="0">{
        s.logger.Info("Retrieving visualization", zap.String("id", req.VisualizationId))

        visualization, err := s.visualizationStore.Get(ctx, req.VisualizationId)
        if err != nil </span><span class="cov0" title="0">{
                s.logger.Error("Failed to retrieve visualization", zap.Error(err))
                return nil, status.Errorf(codes.NotFound, "visualization not found: %v", err)
        }</span>

        <span class="cov0" title="0">s.logger.Info("Successfully retrieved visualization", zap.String("id", req.VisualizationId))
        return visualization, nil</span>
}

// ListVisualizations retrieves a list of visualizations with pagination.
func (s *VisualizationService) ListVisualizations(ctx context.Context, req *pb.ListVisualizationsRequest) (*pb.ListVisualizationsResponse, error) <span class="cov0" title="0">{
        s.logger.Info("Listing visualizations", zap.Int32("page", req.Page), zap.Int32("pageSize", req.PageSize))

        visualizations, totalCount, err := s.visualizationStore.List(ctx, req.Page, req.PageSize)
        if err != nil </span><span class="cov0" title="0">{
                s.logger.Error("Failed to list visualizations", zap.Error(err))
                return nil, status.Errorf(codes.Internal, "failed to list visualizations: %v", err)
        }</span>

        <span class="cov0" title="0">s.logger.Info("Successfully listed visualizations", zap.Int("count", len(visualizations)), zap.Int32("totalCount", totalCount))
        return &amp;pb.ListVisualizationsResponse{
                Visualizations: visualizations,
                TotalCount:     totalCount,
        }, nil</span>
}

// DeleteVisualization removes a specific visualization by its ID.
func (s *VisualizationService) DeleteVisualization(ctx context.Context, req *pb.DeleteVisualizationRequest) (*pb.DeleteVisualizationResponse, error) <span class="cov0" title="0">{
        s.logger.Info("Deleting visualization", zap.String("id", req.VisualizationId))

        err := s.visualizationStore.Delete(ctx, req.VisualizationId)
        if err != nil </span><span class="cov0" title="0">{
                s.logger.Error("Failed to delete visualization", zap.Error(err))
                return nil, status.Errorf(codes.Internal, "failed to delete visualization: %v", err)
        }</span>

        <span class="cov0" title="0">s.logger.Info("Successfully deleted visualization", zap.String("id", req.VisualizationId))
        return &amp;pb.DeleteVisualizationResponse{Success: true}, nil</span>
}

// ExportVisualization exports a visualization in the specified format.
func (s *VisualizationService) ExportVisualization(ctx context.Context, req *pb.ExportVisualizationRequest) (*pb.ExportVisualizationResponse, error) <span class="cov0" title="0">{
        s.logger.Info("Exporting visualization", zap.String("id", req.VisualizationId), zap.String("format", req.Format))

        visualization, err := s.visualizationStore.Get(ctx, req.VisualizationId)
        if err != nil </span><span class="cov0" title="0">{
                s.logger.Error("Failed to retrieve visualization for export", zap.Error(err))
                return nil, status.Errorf(codes.NotFound, "visualization not found: %v", err)
        }</span>

        <span class="cov0" title="0">var exportedData []byte
        switch req.Format </span>{
        case "raw":<span class="cov0" title="0">
                exportedData = visualization.VisualizationData</span>
        case "png", "svg", "pdf":<span class="cov0" title="0">
                // TODO: Implement conversion to these formats
                return nil, status.Errorf(codes.Unimplemented, "export format %s not yet implemented", req.Format)</span>
        default:<span class="cov0" title="0">
                return nil, status.Errorf(codes.InvalidArgument, "unsupported export format: %s", req.Format)</span>
        }

        <span class="cov0" title="0">s.logger.Info("Successfully exported visualization", zap.String("id", req.VisualizationId), zap.String("format", req.Format))
        return &amp;pb.ExportVisualizationResponse{
                ExportedData: exportedData,
                Format:       req.Format,
        }, nil</span>
}

// Close closes any resources held by the VisualizationService.
func (s *VisualizationService) Close() error <span class="cov0" title="0">{
        return s.processor.Close()
}</span>
</pre>
		
		<pre class="file" id="file81" style="display: none">package renderers

import (
        "bytes"
        "encoding/base64"
        "fmt"
        "io"
        "sort"

        "github.com/go-echarts/go-echarts/v2/charts"
        "github.com/go-echarts/go-echarts/v2/opts"
)

// Renderer is the interface that all chart renderers must implement
type Renderer interface {
        Render(data map[string]interface{}) (string, error)
}

// BaseRenderer provides common functionality for renderers
type BaseRenderer struct{}

func (br *BaseRenderer) renderToBase64(renderFunc func(w io.Writer) error) (string, error) <span class="cov0" title="0">{
        buffer := new(bytes.Buffer)
        if err := renderFunc(buffer); err != nil </span><span class="cov0" title="0">{
                return "", fmt.Errorf("failed to render chart: %w", err)
        }</span>
        <span class="cov0" title="0">return base64.StdEncoding.EncodeToString(buffer.Bytes()), nil</span>
}

// BarChartRenderer renders bar charts
type BarChartRenderer struct {
        BaseRenderer
}

func (bcr *BarChartRenderer) Render(data map[string]interface{}) (string, error) <span class="cov0" title="0">{
        dimensions, ok := data["dimensions"].(map[string][]string)
        if !ok </span><span class="cov0" title="0">{
                return "", fmt.Errorf("invalid dimensions data")
        }</span>
        <span class="cov0" title="0">measures, ok := data["measures"].([]string)
        if !ok </span><span class="cov0" title="0">{
                return "", fmt.Errorf("invalid measures data")
        }</span>
        <span class="cov0" title="0">chartData, ok := data["data"].(map[string]map[string]float64)
        if !ok </span><span class="cov0" title="0">{
                return "", fmt.Errorf("invalid chart data")
        }</span>

        // Assume we're using the first dimension for x-axis
        <span class="cov0" title="0">xAxisData := dimensions[measures[0]]

        bar := charts.NewBar()
        bar.SetGlobalOptions(
                charts.WithTitleOpts(opts.Title{Title: "Bar Chart"}),
                charts.WithTooltipOpts(opts.Tooltip{}),
                charts.WithLegendOpts(opts.Legend{}),
        )

        bar.SetXAxis(xAxisData)

        for _, measure := range measures </span><span class="cov0" title="0">{
                series := make([]opts.BarData, 0, len(xAxisData))
                for _, x := range xAxisData </span><span class="cov0" title="0">{
                        series = append(series, opts.BarData{Value: chartData[x][measure]})
                }</span>
                <span class="cov0" title="0">bar.AddSeries(measure, series)</span>
        }

        <span class="cov0" title="0">return bcr.renderToBase64(bar.Render)</span>
}

// LineChartRenderer renders line charts
type LineChartRenderer struct {
        BaseRenderer
}

func (lcr *LineChartRenderer) Render(data map[string]interface{}) (string, error) <span class="cov0" title="0">{
        dimensions, ok := data["dimensions"].(map[string][]string)
        if !ok </span><span class="cov0" title="0">{
                return "", fmt.Errorf("invalid dimensions data")
        }</span>
        <span class="cov0" title="0">measures, ok := data["measures"].([]string)
        if !ok </span><span class="cov0" title="0">{
                return "", fmt.Errorf("invalid measures data")
        }</span>
        <span class="cov0" title="0">chartData, ok := data["data"].(map[string]map[string]float64)
        if !ok </span><span class="cov0" title="0">{
                return "", fmt.Errorf("invalid chart data")
        }</span>

        // Assume we're using the first dimension for x-axis
        <span class="cov0" title="0">xAxisData := dimensions[measures[0]]

        line := charts.NewLine()
        line.SetGlobalOptions(
                charts.WithTitleOpts(opts.Title{Title: "Line Chart"}),
                charts.WithTooltipOpts(opts.Tooltip{}),
                charts.WithLegendOpts(opts.Legend{}),
        )

        line.SetXAxis(xAxisData)

        for _, measure := range measures </span><span class="cov0" title="0">{
                series := make([]opts.LineData, 0, len(xAxisData))
                for _, x := range xAxisData </span><span class="cov0" title="0">{
                        series = append(series, opts.LineData{Value: chartData[x][measure]})
                }</span>
                <span class="cov0" title="0">line.AddSeries(measure, series)</span>
        }

        <span class="cov0" title="0">return lcr.renderToBase64(line.Render)</span>
}

// PieChartRenderer renders pie charts
type PieChartRenderer struct {
        BaseRenderer
}

func (pcr *PieChartRenderer) Render(data map[string]interface{}) (string, error) <span class="cov0" title="0">{
        dimensions, ok := data["dimensions"].(map[string][]string)
        if !ok </span><span class="cov0" title="0">{
                return "", fmt.Errorf("invalid dimensions data")
        }</span>
        <span class="cov0" title="0">measures, ok := data["measures"].([]string)
        if !ok || len(measures) == 0 </span><span class="cov0" title="0">{
                return "", fmt.Errorf("invalid measures data")
        }</span>
        <span class="cov0" title="0">chartData, ok := data["data"].(map[string]map[string]float64)
        if !ok </span><span class="cov0" title="0">{
                return "", fmt.Errorf("invalid chart data")
        }</span>

        // Use the first dimension and measure for the pie chart
        <span class="cov0" title="0">dimension := measures[0]
        measure := measures[0]

        pie := charts.NewPie()
        pie.SetGlobalOptions(
                charts.WithTitleOpts(opts.Title{Title: "Pie Chart"}),
                charts.WithTooltipOpts(opts.Tooltip{}),
                charts.WithLegendOpts(opts.Legend{}),
        )

        pieData := make([]opts.PieData, 0, len(dimensions[dimension]))
        for _, label := range dimensions[dimension] </span><span class="cov0" title="0">{
                pieData = append(pieData, opts.PieData{Name: label, Value: chartData[label][measure]})
        }</span>
        <span class="cov0" title="0">pie.AddSeries("Category", pieData)

        return pcr.renderToBase64(pie.Render)</span>
}

// ScatterPlotRenderer renders scatter plots
type ScatterPlotRenderer struct {
        BaseRenderer
}

func (spr *ScatterPlotRenderer) Render(data map[string]interface{}) (string, error) <span class="cov0" title="0">{
        dimensions, ok := data["dimensions"].(map[string][]string)
        if !ok </span><span class="cov0" title="0">{
                return "", fmt.Errorf("invalid dimensions data")
        }</span>
        <span class="cov0" title="0">if len(dimensions) &lt; 2 </span><span class="cov0" title="0">{
                return "", fmt.Errorf("need at least two dimensions for scatter plot")
        }</span>
        <span class="cov0" title="0">measures, ok := data["measures"].([]string)
        if !ok || len(measures) &lt; 2 </span><span class="cov0" title="0">{
                return "", fmt.Errorf("invalid measures data, need at least two measures")
        }</span>
        <span class="cov0" title="0">chartData, ok := data["data"].(map[string]map[string]float64)
        if !ok </span><span class="cov0" title="0">{
                return "", fmt.Errorf("invalid chart data")
        }</span>

        // Use the first two measures for x and y axes
        <span class="cov0" title="0">xMeasure, yMeasure := measures[0], measures[1]

        scatter := charts.NewScatter()
        scatter.SetGlobalOptions(
                charts.WithTitleOpts(opts.Title{Title: "Scatter Plot"}),
                charts.WithTooltipOpts(opts.Tooltip{}),
                charts.WithLegendOpts(opts.Legend{}),
                charts.WithXAxisOpts(opts.XAxis{Name: xMeasure}),
                charts.WithYAxisOpts(opts.YAxis{Name: yMeasure}),
        )

        scatterData := make([]opts.ScatterData, 0, len(chartData))
        for _, dataPoint := range chartData </span><span class="cov0" title="0">{
                scatterData = append(scatterData, opts.ScatterData{
                        Value:      []interface{}{dataPoint[xMeasure], dataPoint[yMeasure]},
                        Symbol:     "circle",
                        SymbolSize: 10,
                        // ItemStyle:    &amp;opts.ItemStyle{Color: "blue"},
                        SymbolRotate: 0,
                })
        }</span>
        <span class="cov0" title="0">scatter.AddSeries("Data Points", scatterData)

        return spr.renderToBase64(scatter.Render)</span>
}

// TimeSeriesRenderer renders time series charts
type TimeSeriesRenderer struct {
        BaseRenderer
}

func (tsr *TimeSeriesRenderer) Render(data map[string]interface{}) (string, error) <span class="cov0" title="0">{
        timeDimension, ok := data["timeDimension"].(string)
        if !ok </span><span class="cov0" title="0">{
                return "", fmt.Errorf("invalid time dimension")
        }</span>
        <span class="cov0" title="0">measures, ok := data["measures"].([]string)
        if !ok </span><span class="cov0" title="0">{
                return "", fmt.Errorf("invalid measures data")
        }</span>
        <span class="cov0" title="0">chartData, ok := data["data"].(map[string]map[string]float64)
        if !ok </span><span class="cov0" title="0">{
                return "", fmt.Errorf("invalid chart data")
        }</span>

        // Sort time keys
        <span class="cov0" title="0">timeKeys := make([]string, 0, len(chartData))
        for k := range chartData </span><span class="cov0" title="0">{
                timeKeys = append(timeKeys, k)
        }</span>
        <span class="cov0" title="0">sort.Strings(timeKeys)

        line := charts.NewLine()
        line.SetGlobalOptions(
                charts.WithTitleOpts(opts.Title{Title: "Time Series Chart"}),
                charts.WithTooltipOpts(opts.Tooltip{}),
                charts.WithLegendOpts(opts.Legend{}),
                charts.WithXAxisOpts(opts.XAxis{Name: timeDimension}),
        )

        line.SetXAxis(timeKeys)

        for _, measure := range measures </span><span class="cov0" title="0">{
                series := make([]opts.LineData, 0, len(timeKeys))
                for _, time := range timeKeys </span><span class="cov0" title="0">{
                        series = append(series, opts.LineData{Value: chartData[time][measure]})
                }</span>
                <span class="cov0" title="0">line.AddSeries(measure, series)</span>
        }

        <span class="cov0" title="0">return tsr.renderToBase64(line.Render)</span>
}

// RendererFactory creates renderers based on the visualization type
func RendererFactory(visualizationType string) (Renderer, error) <span class="cov0" title="0">{
        switch visualizationType </span>{
        case "bar":<span class="cov0" title="0">
                return &amp;BarChartRenderer{}, nil</span>
        case "line":<span class="cov0" title="0">
                return &amp;LineChartRenderer{}, nil</span>
        case "pie":<span class="cov0" title="0">
                return &amp;PieChartRenderer{}, nil</span>
        case "scatter":<span class="cov0" title="0">
                return &amp;ScatterPlotRenderer{}, nil</span>
        case "timeseries":<span class="cov0" title="0">
                return &amp;TimeSeriesRenderer{}, nil</span>
        default:<span class="cov0" title="0">
                return nil, fmt.Errorf("unsupported visualization type: %s", visualizationType)</span>
        }
}
</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
